# ifndef __dawn_VK_TYPES_HPP__
# define __dawn_VK_TYPES_HPP__
# include "vulkan/vulkan.h"
# include "dawn/common.hpp"
namespace dawn{ namespace vk{

namespace detail{
    inL int set_next(void const** dst_, void* ptr_){
        if (*dst_ == nullptr) { *dst_ = ptr_; return 0; }
        ((VkBaseOutStructure*)ptr_)->pNext = (VkBaseOutStructure*)*dst_;
        *dst_ = ptr_;
        return 0;
    }
    template<typename T__> struct names_map;
    template<typename T__> using names_map_t = typename names_map<T__>::T;
}
struct E_DiscardRectangleModeEXT : public E<VkDiscardRectangleModeEXT> {
    using E::E; 
    static constexpr OEtype e_inclusive_ext = VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT;
    static constexpr OEtype e_exclusive_ext = VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT;
};
template<> struct detail::names_map<VkDiscardRectangleModeEXT> { using T = E_DiscardRectangleModeEXT; };
struct E_ValidationFeatureDisableEXT : public E<VkValidationFeatureDisableEXT> {
    using E::E; 
    static constexpr OEtype e_all_ext = VK_VALIDATION_FEATURE_DISABLE_ALL_EXT;
    static constexpr OEtype e_shaders_ext = VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT;
    static constexpr OEtype e_thread_safety_ext = VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT;
    static constexpr OEtype e_api_parameters_ext = VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT;
    static constexpr OEtype e_object_lifetimes_ext = VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT;
    static constexpr OEtype e_core_checks_ext = VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT;
    static constexpr OEtype e_unique_handles_ext = VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT;
};
template<> struct detail::names_map<VkValidationFeatureDisableEXT> { using T = E_ValidationFeatureDisableEXT; };
struct E_SharingMode : public E<VkSharingMode> {
    using E::E; 
    static constexpr OEtype e_exclusive = VK_SHARING_MODE_EXCLUSIVE;
    static constexpr OEtype e_concurrent = VK_SHARING_MODE_CONCURRENT;
};
template<> struct detail::names_map<VkSharingMode> { using T = E_SharingMode; };
struct E_PerformanceValueTypeINTEL : public E<VkPerformanceValueTypeINTEL> {
    using E::E; 
    static constexpr OEtype e_uint32_intel = VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL;
    static constexpr OEtype e_uint64_intel = VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL;
    static constexpr OEtype e_float_intel = VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL;
    static constexpr OEtype e_bool_intel = VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL;
    static constexpr OEtype e_string_intel = VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL;
};
template<> struct detail::names_map<VkPerformanceValueTypeINTEL> { using T = E_PerformanceValueTypeINTEL; };
struct E_ColorSpaceKHR : public E<VkColorSpaceKHR> {
    using E::E; 
    static constexpr OEtype e_srgb_nonlinear_khr = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
    static constexpr OEtype e_colorspace_srgb_nonlinear_khr = VK_COLORSPACE_SRGB_NONLINEAR_KHR;
    static constexpr OEtype e_display_p3_nonlinear_ext = VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT;
    static constexpr OEtype e_extended_srgb_linear_ext = VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT;
    static constexpr OEtype e_display_p3_linear_ext = VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT;
    static constexpr OEtype e_dci_p3_nonlinear_ext = VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT;
    static constexpr OEtype e_bt709_linear_ext = VK_COLOR_SPACE_BT709_LINEAR_EXT;
    static constexpr OEtype e_bt709_nonlinear_ext = VK_COLOR_SPACE_BT709_NONLINEAR_EXT;
    static constexpr OEtype e_bt2020_linear_ext = VK_COLOR_SPACE_BT2020_LINEAR_EXT;
    static constexpr OEtype e_hdr10_st2084_ext = VK_COLOR_SPACE_HDR10_ST2084_EXT;
    static constexpr OEtype e_dolbyvision_ext = VK_COLOR_SPACE_DOLBYVISION_EXT;
    static constexpr OEtype e_hdr10_hlg_ext = VK_COLOR_SPACE_HDR10_HLG_EXT;
    static constexpr OEtype e_adobergb_linear_ext = VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT;
    static constexpr OEtype e_adobergb_nonlinear_ext = VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT;
    static constexpr OEtype e_pass_through_ext = VK_COLOR_SPACE_PASS_THROUGH_EXT;
    static constexpr OEtype e_extended_srgb_nonlinear_ext = VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT;
    static constexpr OEtype e_dci_p3_linear_ext = VK_COLOR_SPACE_DCI_P3_LINEAR_EXT;
    static constexpr OEtype e_display_native_amd = VK_COLOR_SPACE_DISPLAY_NATIVE_AMD;
};
template<> struct detail::names_map<VkColorSpaceKHR> { using T = E_ColorSpaceKHR; };
struct E_PhysicalDeviceType : public E<VkPhysicalDeviceType> {
    using E::E; 
    static constexpr OEtype e_other = VK_PHYSICAL_DEVICE_TYPE_OTHER;
    static constexpr OEtype e_integrated_gpu = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU;
    static constexpr OEtype e_discrete_gpu = VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU;
    static constexpr OEtype e_virtual_gpu = VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU;
    static constexpr OEtype e_cpu = VK_PHYSICAL_DEVICE_TYPE_CPU;
};
template<> struct detail::names_map<VkPhysicalDeviceType> { using T = E_PhysicalDeviceType; };
struct E_ImageLayout : public E<VkImageLayout> {
    using E::E; 
    static constexpr OEtype e_undefined = VK_IMAGE_LAYOUT_UNDEFINED;
    static constexpr OEtype e_general = VK_IMAGE_LAYOUT_GENERAL;
    static constexpr OEtype e_color_attachment_optimal = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
    static constexpr OEtype e_depth_stencil_attachment_optimal = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
    static constexpr OEtype e_depth_stencil_read_only_optimal = VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL;
    static constexpr OEtype e_shader_read_only_optimal = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    static constexpr OEtype e_transfer_src_optimal = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
    static constexpr OEtype e_transfer_dst_optimal = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    static constexpr OEtype e_preinitialized = VK_IMAGE_LAYOUT_PREINITIALIZED;
    static constexpr OEtype e_depth_read_only_stencil_attachment_optimal = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL;
    static constexpr OEtype e_depth_attachment_stencil_read_only_optimal = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL;
    static constexpr OEtype e_present_src_khr = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
    static constexpr OEtype e_shared_present_khr = VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR;
    static constexpr OEtype e_depth_read_only_stencil_attachment_optimal_khr = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR;
    static constexpr OEtype e_depth_attachment_stencil_read_only_optimal_khr = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR;
    static constexpr OEtype e_shading_rate_optimal_nv = VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV;
    static constexpr OEtype e_fragment_density_map_optimal_ext = VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT;
};
template<> struct detail::names_map<VkImageLayout> { using T = E_ImageLayout; };
struct E_ValidationCacheHeaderVersionEXT : public E<VkValidationCacheHeaderVersionEXT> {
    using E::E; 
    static constexpr OEtype e_one_ext = VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT;
};
template<> struct detail::names_map<VkValidationCacheHeaderVersionEXT> { using T = E_ValidationCacheHeaderVersionEXT; };
struct E_CoverageModulationModeNV : public E<VkCoverageModulationModeNV> {
    using E::E; 
    static constexpr OEtype e_none_nv = VK_COVERAGE_MODULATION_MODE_NONE_NV;
    static constexpr OEtype e_rgb_nv = VK_COVERAGE_MODULATION_MODE_RGB_NV;
    static constexpr OEtype e_alpha_nv = VK_COVERAGE_MODULATION_MODE_ALPHA_NV;
    static constexpr OEtype e_rgba_nv = VK_COVERAGE_MODULATION_MODE_RGBA_NV;
};
template<> struct detail::names_map<VkCoverageModulationModeNV> { using T = E_CoverageModulationModeNV; };
struct E_MemoryOverallocationBehaviorAMD : public E<VkMemoryOverallocationBehaviorAMD> {
    using E::E; 
    static constexpr OEtype e_default_amd = VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD;
    static constexpr OEtype e_allowed_amd = VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD;
    static constexpr OEtype e_disallowed_amd = VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD;
};
template<> struct detail::names_map<VkMemoryOverallocationBehaviorAMD> { using T = E_MemoryOverallocationBehaviorAMD; };
struct E_BlendOverlapEXT : public E<VkBlendOverlapEXT> {
    using E::E; 
    static constexpr OEtype e_uncorrelated_ext = VK_BLEND_OVERLAP_UNCORRELATED_EXT;
    static constexpr OEtype e_disjoint_ext = VK_BLEND_OVERLAP_DISJOINT_EXT;
    static constexpr OEtype e_conjoint_ext = VK_BLEND_OVERLAP_CONJOINT_EXT;
};
template<> struct detail::names_map<VkBlendOverlapEXT> { using T = E_BlendOverlapEXT; };
struct E_QueryPoolSamplingModeINTEL : public E<VkQueryPoolSamplingModeINTEL> {
    using E::E; 
    static constexpr OEtype e_manual_intel = VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL;
};
template<> struct detail::names_map<VkQueryPoolSamplingModeINTEL> { using T = E_QueryPoolSamplingModeINTEL; };
struct E_DebugReportObjectTypeEXT : public E<VkDebugReportObjectTypeEXT> {
    using E::E; 
    static constexpr OEtype e_unknown_ext = VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT;
    static constexpr OEtype e_instance_ext = VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT;
    static constexpr OEtype e_physical_device_ext = VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT;
    static constexpr OEtype e_device_ext = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT;
    static constexpr OEtype e_queue_ext = VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT;
    static constexpr OEtype e_semaphore_ext = VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT;
    static constexpr OEtype e_command_buffer_ext = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT;
    static constexpr OEtype e_fence_ext = VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT;
    static constexpr OEtype e_device_memory_ext = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT;
    static constexpr OEtype e_buffer_ext = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT;
    static constexpr OEtype e_image_ext = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT;
    static constexpr OEtype e_event_ext = VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT;
    static constexpr OEtype e_query_pool_ext = VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT;
    static constexpr OEtype e_buffer_view_ext = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT;
    static constexpr OEtype e_image_view_ext = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT;
    static constexpr OEtype e_shader_module_ext = VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT;
    static constexpr OEtype e_pipeline_cache_ext = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT;
    static constexpr OEtype e_pipeline_layout_ext = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT;
    static constexpr OEtype e_render_pass_ext = VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT;
    static constexpr OEtype e_pipeline_ext = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT;
    static constexpr OEtype e_descriptor_set_layout_ext = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT;
    static constexpr OEtype e_sampler_ext = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT;
    static constexpr OEtype e_descriptor_pool_ext = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT;
    static constexpr OEtype e_descriptor_set_ext = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT;
    static constexpr OEtype e_framebuffer_ext = VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT;
    static constexpr OEtype e_command_pool_ext = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT;
    static constexpr OEtype e_surface_khr_ext = VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT;
    static constexpr OEtype e_swapchain_khr_ext = VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT;
    static constexpr OEtype e_debug_report_callback_ext_ext = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT;
    static constexpr OEtype e_debug_report_ext = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT;
    static constexpr OEtype e_display_khr_ext = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT;
    static constexpr OEtype e_display_mode_khr_ext = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT;
    static constexpr OEtype e_object_table_nvx_ext = VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT;
    static constexpr OEtype e_indirect_commands_layout_nvx_ext = VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT;
    static constexpr OEtype e_validation_cache_ext_ext = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT;
    static constexpr OEtype e_validation_cache_ext = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT;
    static constexpr OEtype e_sampler_ycbcr_conversion_ext = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT;
    static constexpr OEtype e_descriptor_update_template_ext = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT;
    static constexpr OEtype e_descriptor_update_template_khr_ext = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT;
    static constexpr OEtype e_sampler_ycbcr_conversion_khr_ext = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT;
    static constexpr OEtype e_acceleration_structure_nv_ext = VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT;
};
template<> struct detail::names_map<VkDebugReportObjectTypeEXT> { using T = E_DebugReportObjectTypeEXT; };
struct E_GeometryTypeNV : public E<VkGeometryTypeNV> {
    using E::E; 
    static constexpr OEtype e_triangles_nv = VK_GEOMETRY_TYPE_TRIANGLES_NV;
    static constexpr OEtype e_aabbs_nv = VK_GEOMETRY_TYPE_AABBS_NV;
};
template<> struct detail::names_map<VkGeometryTypeNV> { using T = E_GeometryTypeNV; };
struct E_AccelerationStructureTypeNV : public E<VkAccelerationStructureTypeNV> {
    using E::E; 
    static constexpr OEtype e_top_level_nv = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV;
    static constexpr OEtype e_bottom_level_nv = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV;
};
template<> struct detail::names_map<VkAccelerationStructureTypeNV> { using T = E_AccelerationStructureTypeNV; };
struct E_PerformanceConfigurationTypeINTEL : public E<VkPerformanceConfigurationTypeINTEL> {
    using E::E; 
    static constexpr OEtype e_command_queue_metrics_discovery_activated_intel = VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL;
};
template<> struct detail::names_map<VkPerformanceConfigurationTypeINTEL> { using T = E_PerformanceConfigurationTypeINTEL; };
struct E_DriverIdKHR : public E<VkDriverIdKHR> {
    using E::E; 
    static constexpr OEtype e_amd_proprietary_khr = VK_DRIVER_ID_AMD_PROPRIETARY_KHR;
    static constexpr OEtype e_amd_open_source_khr = VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR;
    static constexpr OEtype e_mesa_radv_khr = VK_DRIVER_ID_MESA_RADV_KHR;
    static constexpr OEtype e_nvidia_proprietary_khr = VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR;
    static constexpr OEtype e_intel_proprietary_windows_khr = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR;
    static constexpr OEtype e_intel_open_source_mesa_khr = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR;
    static constexpr OEtype e_imagination_proprietary_khr = VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR;
    static constexpr OEtype e_qualcomm_proprietary_khr = VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR;
    static constexpr OEtype e_arm_proprietary_khr = VK_DRIVER_ID_ARM_PROPRIETARY_KHR;
    static constexpr OEtype e_google_swiftshader_khr = VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR;
    static constexpr OEtype e_ggp_proprietary_khr = VK_DRIVER_ID_GGP_PROPRIETARY_KHR;
    static constexpr OEtype e_broadcom_proprietary_khr = VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR;
};
template<> struct detail::names_map<VkDriverIdKHR> { using T = E_DriverIdKHR; };
struct E_SamplerYcbcrModelConversion : public E<VkSamplerYcbcrModelConversion> {
    using E::E; 
    static constexpr OEtype e_rgb_identity = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY;
    static constexpr OEtype e_ycbcr_identity = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY;
    static constexpr OEtype e_ycbcr_709 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709;
    static constexpr OEtype e_ycbcr_601 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601;
    static constexpr OEtype e_ycbcr_2020 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020;
    static constexpr OEtype e_rgb_identity_khr = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR;
    static constexpr OEtype e_ycbcr_identity_khr = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR;
    static constexpr OEtype e_ycbcr_709_khr = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR;
    static constexpr OEtype e_ycbcr_601_khr = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR;
    static constexpr OEtype e_ycbcr_2020_khr = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR;
};
template<> struct detail::names_map<VkSamplerYcbcrModelConversion> { using T = E_SamplerYcbcrModelConversion; };
struct E_SubpassContents : public E<VkSubpassContents> {
    using E::E; 
    static constexpr OEtype e_inline = VK_SUBPASS_CONTENTS_INLINE;
    static constexpr OEtype e_secondary_command_buffers = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS;
};
template<> struct detail::names_map<VkSubpassContents> { using T = E_SubpassContents; };
struct E_ScopeNV : public E<VkScopeNV> {
    using E::E; 
    static constexpr OEtype e_device_nv = VK_SCOPE_DEVICE_NV;
    static constexpr OEtype e_workgroup_nv = VK_SCOPE_WORKGROUP_NV;
    static constexpr OEtype e_subgroup_nv = VK_SCOPE_SUBGROUP_NV;
    static constexpr OEtype e_queue_family_nv = VK_SCOPE_QUEUE_FAMILY_NV;
};
template<> struct detail::names_map<VkScopeNV> { using T = E_ScopeNV; };
struct E_SamplerMipmapMode : public E<VkSamplerMipmapMode> {
    using E::E; 
    static constexpr OEtype e_nearest = VK_SAMPLER_MIPMAP_MODE_NEAREST;
    static constexpr OEtype e_linear = VK_SAMPLER_MIPMAP_MODE_LINEAR;
};
template<> struct detail::names_map<VkSamplerMipmapMode> { using T = E_SamplerMipmapMode; };
struct E_PipelineExecutableStatisticFormatKHR : public E<VkPipelineExecutableStatisticFormatKHR> {
    using E::E; 
    static constexpr OEtype e_bool32_khr = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR;
    static constexpr OEtype e_int64_khr = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR;
    static constexpr OEtype e_uint64_khr = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR;
    static constexpr OEtype e_float64_khr = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR;
};
template<> struct detail::names_map<VkPipelineExecutableStatisticFormatKHR> { using T = E_PipelineExecutableStatisticFormatKHR; };
struct E_ShaderFloatControlsIndependenceKHR : public E<VkShaderFloatControlsIndependenceKHR> {
    using E::E; 
    static constexpr OEtype e_32_bit_only_khr = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR;
    static constexpr OEtype e_all_khr = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR;
    static constexpr OEtype e_none_khr = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR;
};
template<> struct detail::names_map<VkShaderFloatControlsIndependenceKHR> { using T = E_ShaderFloatControlsIndependenceKHR; };
struct E_TimeDomainEXT : public E<VkTimeDomainEXT> {
    using E::E; 
    static constexpr OEtype e_device_ext = VK_TIME_DOMAIN_DEVICE_EXT;
    static constexpr OEtype e_clock_monotonic_ext = VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT;
    static constexpr OEtype e_clock_monotonic_raw_ext = VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT;
    static constexpr OEtype e_query_performance_counter_ext = VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT;
};
template<> struct detail::names_map<VkTimeDomainEXT> { using T = E_TimeDomainEXT; };
struct E_TessellationDomainOrigin : public E<VkTessellationDomainOrigin> {
    using E::E; 
    static constexpr OEtype e_upper_left = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT;
    static constexpr OEtype e_lower_left = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT;
    static constexpr OEtype e_upper_left_khr = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR;
    static constexpr OEtype e_lower_left_khr = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR;
};
template<> struct detail::names_map<VkTessellationDomainOrigin> { using T = E_TessellationDomainOrigin; };
struct E_DescriptorType : public E<VkDescriptorType> {
    using E::E; 
    static constexpr OEtype e_sampler = VK_DESCRIPTOR_TYPE_SAMPLER;
    static constexpr OEtype e_combined_image_sampler = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    static constexpr OEtype e_sampled_image = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE;
    static constexpr OEtype e_storage_image = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
    static constexpr OEtype e_uniform_texel_buffer = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER;
    static constexpr OEtype e_storage_texel_buffer = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER;
    static constexpr OEtype e_uniform_buffer = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    static constexpr OEtype e_storage_buffer = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
    static constexpr OEtype e_uniform_buffer_dynamic = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC;
    static constexpr OEtype e_storage_buffer_dynamic = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC;
    static constexpr OEtype e_input_attachment = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT;
    static constexpr OEtype e_inline_uniform_block_ext = VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT;
    static constexpr OEtype e_acceleration_structure_nv = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV;
};
template<> struct detail::names_map<VkDescriptorType> { using T = E_DescriptorType; };
struct E_CoverageReductionModeNV : public E<VkCoverageReductionModeNV> {
    using E::E; 
    static constexpr OEtype e_merge_nv = VK_COVERAGE_REDUCTION_MODE_MERGE_NV;
    static constexpr OEtype e_truncate_nv = VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV;
};
template<> struct detail::names_map<VkCoverageReductionModeNV> { using T = E_CoverageReductionModeNV; };
struct E_PerformanceParameterTypeINTEL : public E<VkPerformanceParameterTypeINTEL> {
    using E::E; 
    static constexpr OEtype e_hw_counters_supported_intel = VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL;
    static constexpr OEtype e_stream_marker_valid_bits_intel = VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL;
};
template<> struct detail::names_map<VkPerformanceParameterTypeINTEL> { using T = E_PerformanceParameterTypeINTEL; };
struct E_ImageViewType : public E<VkImageViewType> {
    using E::E; 
    static constexpr OEtype e_1d = VK_IMAGE_VIEW_TYPE_1D;
    static constexpr OEtype e_2d = VK_IMAGE_VIEW_TYPE_2D;
    static constexpr OEtype e_3d = VK_IMAGE_VIEW_TYPE_3D;
    static constexpr OEtype e_cube = VK_IMAGE_VIEW_TYPE_CUBE;
    static constexpr OEtype e_1d_array = VK_IMAGE_VIEW_TYPE_1D_ARRAY;
    static constexpr OEtype e_2d_array = VK_IMAGE_VIEW_TYPE_2D_ARRAY;
    static constexpr OEtype e_cube_array = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY;
};
template<> struct detail::names_map<VkImageViewType> { using T = E_ImageViewType; };
struct E_ShadingRatePaletteEntryNV : public E<VkShadingRatePaletteEntryNV> {
    using E::E; 
    static constexpr OEtype e_no_invocations_nv = VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV;
    static constexpr OEtype e_16_invocations_per_pixel_nv = VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV;
    static constexpr OEtype e_8_invocations_per_pixel_nv = VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV;
    static constexpr OEtype e_4_invocations_per_pixel_nv = VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV;
    static constexpr OEtype e_2_invocations_per_pixel_nv = VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV;
    static constexpr OEtype e_1_invocation_per_pixel_nv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV;
    static constexpr OEtype e_1_invocation_per_2x1_pixels_nv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV;
    static constexpr OEtype e_1_invocation_per_1x2_pixels_nv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV;
    static constexpr OEtype e_1_invocation_per_2x2_pixels_nv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV;
    static constexpr OEtype e_1_invocation_per_4x2_pixels_nv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV;
    static constexpr OEtype e_1_invocation_per_2x4_pixels_nv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV;
    static constexpr OEtype e_1_invocation_per_4x4_pixels_nv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV;
};
template<> struct detail::names_map<VkShadingRatePaletteEntryNV> { using T = E_ShadingRatePaletteEntryNV; };
struct E_Filter : public E<VkFilter> {
    using E::E; 
    static constexpr OEtype e_nearest = VK_FILTER_NEAREST;
    static constexpr OEtype e_linear = VK_FILTER_LINEAR;
    static constexpr OEtype e_cubic_img = VK_FILTER_CUBIC_IMG;
    static constexpr OEtype e_cubic_ext = VK_FILTER_CUBIC_EXT;
};
template<> struct detail::names_map<VkFilter> { using T = E_Filter; };
struct E_ChromaLocation : public E<VkChromaLocation> {
    using E::E; 
    static constexpr OEtype e_cosited_even = VK_CHROMA_LOCATION_COSITED_EVEN;
    static constexpr OEtype e_midpoint = VK_CHROMA_LOCATION_MIDPOINT;
    static constexpr OEtype e_cosited_even_khr = VK_CHROMA_LOCATION_COSITED_EVEN_KHR;
    static constexpr OEtype e_midpoint_khr = VK_CHROMA_LOCATION_MIDPOINT_KHR;
};
template<> struct detail::names_map<VkChromaLocation> { using T = E_ChromaLocation; };
struct E_PrimitiveTopology : public E<VkPrimitiveTopology> {
    using E::E; 
    static constexpr OEtype e_point_list = VK_PRIMITIVE_TOPOLOGY_POINT_LIST;
    static constexpr OEtype e_line_list = VK_PRIMITIVE_TOPOLOGY_LINE_LIST;
    static constexpr OEtype e_line_strip = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP;
    static constexpr OEtype e_triangle_list = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    static constexpr OEtype e_triangle_strip = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP;
    static constexpr OEtype e_triangle_fan = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN;
    static constexpr OEtype e_line_list_with_adjacency = VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY;
    static constexpr OEtype e_line_strip_with_adjacency = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY;
    static constexpr OEtype e_triangle_list_with_adjacency = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY;
    static constexpr OEtype e_triangle_strip_with_adjacency = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY;
    static constexpr OEtype e_patch_list = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST;
};
template<> struct detail::names_map<VkPrimitiveTopology> { using T = E_PrimitiveTopology; };
struct E_DeviceEventTypeEXT : public E<VkDeviceEventTypeEXT> {
    using E::E; 
    static constexpr OEtype e_display_hotplug_ext = VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;
};
template<> struct detail::names_map<VkDeviceEventTypeEXT> { using T = E_DeviceEventTypeEXT; };
struct E_AccelerationStructureMemoryRequirementsTypeNV : public E<VkAccelerationStructureMemoryRequirementsTypeNV> {
    using E::E; 
    static constexpr OEtype e_object_nv = VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV;
    static constexpr OEtype e_build_scratch_nv = VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV;
    static constexpr OEtype e_update_scratch_nv = VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV;
};
template<> struct detail::names_map<VkAccelerationStructureMemoryRequirementsTypeNV> { using T = E_AccelerationStructureMemoryRequirementsTypeNV; };
struct E_PolygonMode : public E<VkPolygonMode> {
    using E::E; 
    static constexpr OEtype e_fill = VK_POLYGON_MODE_FILL;
    static constexpr OEtype e_line = VK_POLYGON_MODE_LINE;
    static constexpr OEtype e_point = VK_POLYGON_MODE_POINT;
    static constexpr OEtype e_fill_rectangle_nv = VK_POLYGON_MODE_FILL_RECTANGLE_NV;
};
template<> struct detail::names_map<VkPolygonMode> { using T = E_PolygonMode; };
struct E_ObjectEntryTypeNVX : public E<VkObjectEntryTypeNVX> {
    using E::E; 
    static constexpr OEtype e_descriptor_set_nvx = VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX;
    static constexpr OEtype e_pipeline_nvx = VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX;
    static constexpr OEtype e_index_buffer_nvx = VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX;
    static constexpr OEtype e_vertex_buffer_nvx = VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX;
    static constexpr OEtype e_push_constant_nvx = VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX;
};
template<> struct detail::names_map<VkObjectEntryTypeNVX> { using T = E_ObjectEntryTypeNVX; };
struct E_QueryType : public E<VkQueryType> {
    using E::E; 
    static constexpr OEtype e_occlusion = VK_QUERY_TYPE_OCCLUSION;
    static constexpr OEtype e_pipeline_statistics = VK_QUERY_TYPE_PIPELINE_STATISTICS;
    static constexpr OEtype e_timestamp = VK_QUERY_TYPE_TIMESTAMP;
    static constexpr OEtype e_transform_feedback_stream_ext = VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT;
    static constexpr OEtype e_acceleration_structure_compacted_size_nv = VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV;
};
template<> struct detail::names_map<VkQueryType> { using T = E_QueryType; };
struct E_ObjectType : public E<VkObjectType> {
    using E::E; 
    static constexpr OEtype e_unknown = VK_OBJECT_TYPE_UNKNOWN;
    static constexpr OEtype e_instance = VK_OBJECT_TYPE_INSTANCE;
    static constexpr OEtype e_physical_device = VK_OBJECT_TYPE_PHYSICAL_DEVICE;
    static constexpr OEtype e_device = VK_OBJECT_TYPE_DEVICE;
    static constexpr OEtype e_queue = VK_OBJECT_TYPE_QUEUE;
    static constexpr OEtype e_semaphore = VK_OBJECT_TYPE_SEMAPHORE;
    static constexpr OEtype e_command_buffer = VK_OBJECT_TYPE_COMMAND_BUFFER;
    static constexpr OEtype e_fence = VK_OBJECT_TYPE_FENCE;
    static constexpr OEtype e_device_memory = VK_OBJECT_TYPE_DEVICE_MEMORY;
    static constexpr OEtype e_buffer = VK_OBJECT_TYPE_BUFFER;
    static constexpr OEtype e_image = VK_OBJECT_TYPE_IMAGE;
    static constexpr OEtype e_event = VK_OBJECT_TYPE_EVENT;
    static constexpr OEtype e_query_pool = VK_OBJECT_TYPE_QUERY_POOL;
    static constexpr OEtype e_buffer_view = VK_OBJECT_TYPE_BUFFER_VIEW;
    static constexpr OEtype e_image_view = VK_OBJECT_TYPE_IMAGE_VIEW;
    static constexpr OEtype e_shader_module = VK_OBJECT_TYPE_SHADER_MODULE;
    static constexpr OEtype e_pipeline_cache = VK_OBJECT_TYPE_PIPELINE_CACHE;
    static constexpr OEtype e_pipeline_layout = VK_OBJECT_TYPE_PIPELINE_LAYOUT;
    static constexpr OEtype e_render_pass = VK_OBJECT_TYPE_RENDER_PASS;
    static constexpr OEtype e_pipeline = VK_OBJECT_TYPE_PIPELINE;
    static constexpr OEtype e_descriptor_set_layout = VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT;
    static constexpr OEtype e_sampler = VK_OBJECT_TYPE_SAMPLER;
    static constexpr OEtype e_descriptor_pool = VK_OBJECT_TYPE_DESCRIPTOR_POOL;
    static constexpr OEtype e_descriptor_set = VK_OBJECT_TYPE_DESCRIPTOR_SET;
    static constexpr OEtype e_framebuffer = VK_OBJECT_TYPE_FRAMEBUFFER;
    static constexpr OEtype e_command_pool = VK_OBJECT_TYPE_COMMAND_POOL;
    static constexpr OEtype e_sampler_ycbcr_conversion = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION;
    static constexpr OEtype e_descriptor_update_template = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE;
    static constexpr OEtype e_surface_khr = VK_OBJECT_TYPE_SURFACE_KHR;
    static constexpr OEtype e_swapchain_khr = VK_OBJECT_TYPE_SWAPCHAIN_KHR;
    static constexpr OEtype e_display_khr = VK_OBJECT_TYPE_DISPLAY_KHR;
    static constexpr OEtype e_display_mode_khr = VK_OBJECT_TYPE_DISPLAY_MODE_KHR;
    static constexpr OEtype e_debug_report_callback_ext = VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT;
    static constexpr OEtype e_descriptor_update_template_khr = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR;
    static constexpr OEtype e_object_table_nvx = VK_OBJECT_TYPE_OBJECT_TABLE_NVX;
    static constexpr OEtype e_indirect_commands_layout_nvx = VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX;
    static constexpr OEtype e_debug_utils_messenger_ext = VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT;
    static constexpr OEtype e_sampler_ycbcr_conversion_khr = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR;
    static constexpr OEtype e_validation_cache_ext = VK_OBJECT_TYPE_VALIDATION_CACHE_EXT;
    static constexpr OEtype e_acceleration_structure_nv = VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV;
    static constexpr OEtype e_performance_configuration_intel = VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL;
};
template<> struct detail::names_map<VkObjectType> { using T = E_ObjectType; };
struct E_PipelineBindPoint : public E<VkPipelineBindPoint> {
    using E::E; 
    static constexpr OEtype e_graphics = VK_PIPELINE_BIND_POINT_GRAPHICS;
    static constexpr OEtype e_compute = VK_PIPELINE_BIND_POINT_COMPUTE;
    static constexpr OEtype e_ray_tracing_nv = VK_PIPELINE_BIND_POINT_RAY_TRACING_NV;
};
template<> struct detail::names_map<VkPipelineBindPoint> { using T = E_PipelineBindPoint; };
struct E_ComponentSwizzle : public E<VkComponentSwizzle> {
    using E::E; 
    static constexpr OEtype e_identity = VK_COMPONENT_SWIZZLE_IDENTITY;
    static constexpr OEtype e_zero = VK_COMPONENT_SWIZZLE_ZERO;
    static constexpr OEtype e_one = VK_COMPONENT_SWIZZLE_ONE;
    static constexpr OEtype e_r = VK_COMPONENT_SWIZZLE_R;
    static constexpr OEtype e_g = VK_COMPONENT_SWIZZLE_G;
    static constexpr OEtype e_b = VK_COMPONENT_SWIZZLE_B;
    static constexpr OEtype e_a = VK_COMPONENT_SWIZZLE_A;
};
template<> struct detail::names_map<VkComponentSwizzle> { using T = E_ComponentSwizzle; };
struct E_CommandBufferLevel : public E<VkCommandBufferLevel> {
    using E::E; 
    static constexpr OEtype e_primary = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    static constexpr OEtype e_secondary = VK_COMMAND_BUFFER_LEVEL_SECONDARY;
};
template<> struct detail::names_map<VkCommandBufferLevel> { using T = E_CommandBufferLevel; };
struct E_DisplayPowerStateEXT : public E<VkDisplayPowerStateEXT> {
    using E::E; 
    static constexpr OEtype e_off_ext = VK_DISPLAY_POWER_STATE_OFF_EXT;
    static constexpr OEtype e_suspend_ext = VK_DISPLAY_POWER_STATE_SUSPEND_EXT;
    static constexpr OEtype e_on_ext = VK_DISPLAY_POWER_STATE_ON_EXT;
};
template<> struct detail::names_map<VkDisplayPowerStateEXT> { using T = E_DisplayPowerStateEXT; };
struct E_Format : public E<VkFormat> {
    using E::E; 
    static constexpr OEtype e_undefined = VK_FORMAT_UNDEFINED;
    static constexpr OEtype e_r4g4_unorm_pack8 = VK_FORMAT_R4G4_UNORM_PACK8;
    static constexpr OEtype e_r4g4b4a4_unorm_pack16 = VK_FORMAT_R4G4B4A4_UNORM_PACK16;
    static constexpr OEtype e_b4g4r4a4_unorm_pack16 = VK_FORMAT_B4G4R4A4_UNORM_PACK16;
    static constexpr OEtype e_r5g6b5_unorm_pack16 = VK_FORMAT_R5G6B5_UNORM_PACK16;
    static constexpr OEtype e_b5g6r5_unorm_pack16 = VK_FORMAT_B5G6R5_UNORM_PACK16;
    static constexpr OEtype e_r5g5b5a1_unorm_pack16 = VK_FORMAT_R5G5B5A1_UNORM_PACK16;
    static constexpr OEtype e_b5g5r5a1_unorm_pack16 = VK_FORMAT_B5G5R5A1_UNORM_PACK16;
    static constexpr OEtype e_a1r5g5b5_unorm_pack16 = VK_FORMAT_A1R5G5B5_UNORM_PACK16;
    static constexpr OEtype e_r8_unorm = VK_FORMAT_R8_UNORM;
    static constexpr OEtype e_r8_snorm = VK_FORMAT_R8_SNORM;
    static constexpr OEtype e_r8_uscaled = VK_FORMAT_R8_USCALED;
    static constexpr OEtype e_r8_sscaled = VK_FORMAT_R8_SSCALED;
    static constexpr OEtype e_r8_uint = VK_FORMAT_R8_UINT;
    static constexpr OEtype e_r8_sint = VK_FORMAT_R8_SINT;
    static constexpr OEtype e_r8_srgb = VK_FORMAT_R8_SRGB;
    static constexpr OEtype e_r8g8_unorm = VK_FORMAT_R8G8_UNORM;
    static constexpr OEtype e_r8g8_snorm = VK_FORMAT_R8G8_SNORM;
    static constexpr OEtype e_r8g8_uscaled = VK_FORMAT_R8G8_USCALED;
    static constexpr OEtype e_r8g8_sscaled = VK_FORMAT_R8G8_SSCALED;
    static constexpr OEtype e_r8g8_uint = VK_FORMAT_R8G8_UINT;
    static constexpr OEtype e_r8g8_sint = VK_FORMAT_R8G8_SINT;
    static constexpr OEtype e_r8g8_srgb = VK_FORMAT_R8G8_SRGB;
    static constexpr OEtype e_r8g8b8_unorm = VK_FORMAT_R8G8B8_UNORM;
    static constexpr OEtype e_r8g8b8_snorm = VK_FORMAT_R8G8B8_SNORM;
    static constexpr OEtype e_r8g8b8_uscaled = VK_FORMAT_R8G8B8_USCALED;
    static constexpr OEtype e_r8g8b8_sscaled = VK_FORMAT_R8G8B8_SSCALED;
    static constexpr OEtype e_r8g8b8_uint = VK_FORMAT_R8G8B8_UINT;
    static constexpr OEtype e_r8g8b8_sint = VK_FORMAT_R8G8B8_SINT;
    static constexpr OEtype e_r8g8b8_srgb = VK_FORMAT_R8G8B8_SRGB;
    static constexpr OEtype e_b8g8r8_unorm = VK_FORMAT_B8G8R8_UNORM;
    static constexpr OEtype e_b8g8r8_snorm = VK_FORMAT_B8G8R8_SNORM;
    static constexpr OEtype e_b8g8r8_uscaled = VK_FORMAT_B8G8R8_USCALED;
    static constexpr OEtype e_b8g8r8_sscaled = VK_FORMAT_B8G8R8_SSCALED;
    static constexpr OEtype e_b8g8r8_uint = VK_FORMAT_B8G8R8_UINT;
    static constexpr OEtype e_b8g8r8_sint = VK_FORMAT_B8G8R8_SINT;
    static constexpr OEtype e_b8g8r8_srgb = VK_FORMAT_B8G8R8_SRGB;
    static constexpr OEtype e_r8g8b8a8_unorm = VK_FORMAT_R8G8B8A8_UNORM;
    static constexpr OEtype e_r8g8b8a8_snorm = VK_FORMAT_R8G8B8A8_SNORM;
    static constexpr OEtype e_r8g8b8a8_uscaled = VK_FORMAT_R8G8B8A8_USCALED;
    static constexpr OEtype e_r8g8b8a8_sscaled = VK_FORMAT_R8G8B8A8_SSCALED;
    static constexpr OEtype e_r8g8b8a8_uint = VK_FORMAT_R8G8B8A8_UINT;
    static constexpr OEtype e_r8g8b8a8_sint = VK_FORMAT_R8G8B8A8_SINT;
    static constexpr OEtype e_r8g8b8a8_srgb = VK_FORMAT_R8G8B8A8_SRGB;
    static constexpr OEtype e_b8g8r8a8_unorm = VK_FORMAT_B8G8R8A8_UNORM;
    static constexpr OEtype e_b8g8r8a8_snorm = VK_FORMAT_B8G8R8A8_SNORM;
    static constexpr OEtype e_b8g8r8a8_uscaled = VK_FORMAT_B8G8R8A8_USCALED;
    static constexpr OEtype e_b8g8r8a8_sscaled = VK_FORMAT_B8G8R8A8_SSCALED;
    static constexpr OEtype e_b8g8r8a8_uint = VK_FORMAT_B8G8R8A8_UINT;
    static constexpr OEtype e_b8g8r8a8_sint = VK_FORMAT_B8G8R8A8_SINT;
    static constexpr OEtype e_b8g8r8a8_srgb = VK_FORMAT_B8G8R8A8_SRGB;
    static constexpr OEtype e_a8b8g8r8_unorm_pack32 = VK_FORMAT_A8B8G8R8_UNORM_PACK32;
    static constexpr OEtype e_a8b8g8r8_snorm_pack32 = VK_FORMAT_A8B8G8R8_SNORM_PACK32;
    static constexpr OEtype e_a8b8g8r8_uscaled_pack32 = VK_FORMAT_A8B8G8R8_USCALED_PACK32;
    static constexpr OEtype e_a8b8g8r8_sscaled_pack32 = VK_FORMAT_A8B8G8R8_SSCALED_PACK32;
    static constexpr OEtype e_a8b8g8r8_uint_pack32 = VK_FORMAT_A8B8G8R8_UINT_PACK32;
    static constexpr OEtype e_a8b8g8r8_sint_pack32 = VK_FORMAT_A8B8G8R8_SINT_PACK32;
    static constexpr OEtype e_a8b8g8r8_srgb_pack32 = VK_FORMAT_A8B8G8R8_SRGB_PACK32;
    static constexpr OEtype e_a2r10g10b10_unorm_pack32 = VK_FORMAT_A2R10G10B10_UNORM_PACK32;
    static constexpr OEtype e_a2r10g10b10_snorm_pack32 = VK_FORMAT_A2R10G10B10_SNORM_PACK32;
    static constexpr OEtype e_a2r10g10b10_uscaled_pack32 = VK_FORMAT_A2R10G10B10_USCALED_PACK32;
    static constexpr OEtype e_a2r10g10b10_sscaled_pack32 = VK_FORMAT_A2R10G10B10_SSCALED_PACK32;
    static constexpr OEtype e_a2r10g10b10_uint_pack32 = VK_FORMAT_A2R10G10B10_UINT_PACK32;
    static constexpr OEtype e_a2r10g10b10_sint_pack32 = VK_FORMAT_A2R10G10B10_SINT_PACK32;
    static constexpr OEtype e_a2b10g10r10_unorm_pack32 = VK_FORMAT_A2B10G10R10_UNORM_PACK32;
    static constexpr OEtype e_a2b10g10r10_snorm_pack32 = VK_FORMAT_A2B10G10R10_SNORM_PACK32;
    static constexpr OEtype e_a2b10g10r10_uscaled_pack32 = VK_FORMAT_A2B10G10R10_USCALED_PACK32;
    static constexpr OEtype e_a2b10g10r10_sscaled_pack32 = VK_FORMAT_A2B10G10R10_SSCALED_PACK32;
    static constexpr OEtype e_a2b10g10r10_uint_pack32 = VK_FORMAT_A2B10G10R10_UINT_PACK32;
    static constexpr OEtype e_a2b10g10r10_sint_pack32 = VK_FORMAT_A2B10G10R10_SINT_PACK32;
    static constexpr OEtype e_r16_unorm = VK_FORMAT_R16_UNORM;
    static constexpr OEtype e_r16_snorm = VK_FORMAT_R16_SNORM;
    static constexpr OEtype e_r16_uscaled = VK_FORMAT_R16_USCALED;
    static constexpr OEtype e_r16_sscaled = VK_FORMAT_R16_SSCALED;
    static constexpr OEtype e_r16_uint = VK_FORMAT_R16_UINT;
    static constexpr OEtype e_r16_sint = VK_FORMAT_R16_SINT;
    static constexpr OEtype e_r16_sfloat = VK_FORMAT_R16_SFLOAT;
    static constexpr OEtype e_r16g16_unorm = VK_FORMAT_R16G16_UNORM;
    static constexpr OEtype e_r16g16_snorm = VK_FORMAT_R16G16_SNORM;
    static constexpr OEtype e_r16g16_uscaled = VK_FORMAT_R16G16_USCALED;
    static constexpr OEtype e_r16g16_sscaled = VK_FORMAT_R16G16_SSCALED;
    static constexpr OEtype e_r16g16_uint = VK_FORMAT_R16G16_UINT;
    static constexpr OEtype e_r16g16_sint = VK_FORMAT_R16G16_SINT;
    static constexpr OEtype e_r16g16_sfloat = VK_FORMAT_R16G16_SFLOAT;
    static constexpr OEtype e_r16g16b16_unorm = VK_FORMAT_R16G16B16_UNORM;
    static constexpr OEtype e_r16g16b16_snorm = VK_FORMAT_R16G16B16_SNORM;
    static constexpr OEtype e_r16g16b16_uscaled = VK_FORMAT_R16G16B16_USCALED;
    static constexpr OEtype e_r16g16b16_sscaled = VK_FORMAT_R16G16B16_SSCALED;
    static constexpr OEtype e_r16g16b16_uint = VK_FORMAT_R16G16B16_UINT;
    static constexpr OEtype e_r16g16b16_sint = VK_FORMAT_R16G16B16_SINT;
    static constexpr OEtype e_r16g16b16_sfloat = VK_FORMAT_R16G16B16_SFLOAT;
    static constexpr OEtype e_r16g16b16a16_unorm = VK_FORMAT_R16G16B16A16_UNORM;
    static constexpr OEtype e_r16g16b16a16_snorm = VK_FORMAT_R16G16B16A16_SNORM;
    static constexpr OEtype e_r16g16b16a16_uscaled = VK_FORMAT_R16G16B16A16_USCALED;
    static constexpr OEtype e_r16g16b16a16_sscaled = VK_FORMAT_R16G16B16A16_SSCALED;
    static constexpr OEtype e_r16g16b16a16_uint = VK_FORMAT_R16G16B16A16_UINT;
    static constexpr OEtype e_r16g16b16a16_sint = VK_FORMAT_R16G16B16A16_SINT;
    static constexpr OEtype e_r16g16b16a16_sfloat = VK_FORMAT_R16G16B16A16_SFLOAT;
    static constexpr OEtype e_r32_uint = VK_FORMAT_R32_UINT;
    static constexpr OEtype e_r32_sint = VK_FORMAT_R32_SINT;
    static constexpr OEtype e_r32_sfloat = VK_FORMAT_R32_SFLOAT;
    static constexpr OEtype e_r32g32_uint = VK_FORMAT_R32G32_UINT;
    static constexpr OEtype e_r32g32_sint = VK_FORMAT_R32G32_SINT;
    static constexpr OEtype e_r32g32_sfloat = VK_FORMAT_R32G32_SFLOAT;
    static constexpr OEtype e_r32g32b32_uint = VK_FORMAT_R32G32B32_UINT;
    static constexpr OEtype e_r32g32b32_sint = VK_FORMAT_R32G32B32_SINT;
    static constexpr OEtype e_r32g32b32_sfloat = VK_FORMAT_R32G32B32_SFLOAT;
    static constexpr OEtype e_r32g32b32a32_uint = VK_FORMAT_R32G32B32A32_UINT;
    static constexpr OEtype e_r32g32b32a32_sint = VK_FORMAT_R32G32B32A32_SINT;
    static constexpr OEtype e_r32g32b32a32_sfloat = VK_FORMAT_R32G32B32A32_SFLOAT;
    static constexpr OEtype e_r64_uint = VK_FORMAT_R64_UINT;
    static constexpr OEtype e_r64_sint = VK_FORMAT_R64_SINT;
    static constexpr OEtype e_r64_sfloat = VK_FORMAT_R64_SFLOAT;
    static constexpr OEtype e_r64g64_uint = VK_FORMAT_R64G64_UINT;
    static constexpr OEtype e_r64g64_sint = VK_FORMAT_R64G64_SINT;
    static constexpr OEtype e_r64g64_sfloat = VK_FORMAT_R64G64_SFLOAT;
    static constexpr OEtype e_r64g64b64_uint = VK_FORMAT_R64G64B64_UINT;
    static constexpr OEtype e_r64g64b64_sint = VK_FORMAT_R64G64B64_SINT;
    static constexpr OEtype e_r64g64b64_sfloat = VK_FORMAT_R64G64B64_SFLOAT;
    static constexpr OEtype e_r64g64b64a64_uint = VK_FORMAT_R64G64B64A64_UINT;
    static constexpr OEtype e_r64g64b64a64_sint = VK_FORMAT_R64G64B64A64_SINT;
    static constexpr OEtype e_r64g64b64a64_sfloat = VK_FORMAT_R64G64B64A64_SFLOAT;
    static constexpr OEtype e_b10g11r11_ufloat_pack32 = VK_FORMAT_B10G11R11_UFLOAT_PACK32;
    static constexpr OEtype e_e5b9g9r9_ufloat_pack32 = VK_FORMAT_E5B9G9R9_UFLOAT_PACK32;
    static constexpr OEtype e_d16_unorm = VK_FORMAT_D16_UNORM;
    static constexpr OEtype e_x8_d24_unorm_pack32 = VK_FORMAT_X8_D24_UNORM_PACK32;
    static constexpr OEtype e_d32_sfloat = VK_FORMAT_D32_SFLOAT;
    static constexpr OEtype e_s8_uint = VK_FORMAT_S8_UINT;
    static constexpr OEtype e_d16_unorm_s8_uint = VK_FORMAT_D16_UNORM_S8_UINT;
    static constexpr OEtype e_d24_unorm_s8_uint = VK_FORMAT_D24_UNORM_S8_UINT;
    static constexpr OEtype e_d32_sfloat_s8_uint = VK_FORMAT_D32_SFLOAT_S8_UINT;
    static constexpr OEtype e_bc1_rgb_unorm_block = VK_FORMAT_BC1_RGB_UNORM_BLOCK;
    static constexpr OEtype e_bc1_rgb_srgb_block = VK_FORMAT_BC1_RGB_SRGB_BLOCK;
    static constexpr OEtype e_bc1_rgba_unorm_block = VK_FORMAT_BC1_RGBA_UNORM_BLOCK;
    static constexpr OEtype e_bc1_rgba_srgb_block = VK_FORMAT_BC1_RGBA_SRGB_BLOCK;
    static constexpr OEtype e_bc2_unorm_block = VK_FORMAT_BC2_UNORM_BLOCK;
    static constexpr OEtype e_bc2_srgb_block = VK_FORMAT_BC2_SRGB_BLOCK;
    static constexpr OEtype e_bc3_unorm_block = VK_FORMAT_BC3_UNORM_BLOCK;
    static constexpr OEtype e_bc3_srgb_block = VK_FORMAT_BC3_SRGB_BLOCK;
    static constexpr OEtype e_bc4_unorm_block = VK_FORMAT_BC4_UNORM_BLOCK;
    static constexpr OEtype e_bc4_snorm_block = VK_FORMAT_BC4_SNORM_BLOCK;
    static constexpr OEtype e_bc5_unorm_block = VK_FORMAT_BC5_UNORM_BLOCK;
    static constexpr OEtype e_bc5_snorm_block = VK_FORMAT_BC5_SNORM_BLOCK;
    static constexpr OEtype e_bc6h_ufloat_block = VK_FORMAT_BC6H_UFLOAT_BLOCK;
    static constexpr OEtype e_bc6h_sfloat_block = VK_FORMAT_BC6H_SFLOAT_BLOCK;
    static constexpr OEtype e_bc7_unorm_block = VK_FORMAT_BC7_UNORM_BLOCK;
    static constexpr OEtype e_bc7_srgb_block = VK_FORMAT_BC7_SRGB_BLOCK;
    static constexpr OEtype e_etc2_r8g8b8_unorm_block = VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK;
    static constexpr OEtype e_etc2_r8g8b8_srgb_block = VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK;
    static constexpr OEtype e_etc2_r8g8b8a1_unorm_block = VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK;
    static constexpr OEtype e_etc2_r8g8b8a1_srgb_block = VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK;
    static constexpr OEtype e_etc2_r8g8b8a8_unorm_block = VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK;
    static constexpr OEtype e_etc2_r8g8b8a8_srgb_block = VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK;
    static constexpr OEtype e_eac_r11_unorm_block = VK_FORMAT_EAC_R11_UNORM_BLOCK;
    static constexpr OEtype e_eac_r11_snorm_block = VK_FORMAT_EAC_R11_SNORM_BLOCK;
    static constexpr OEtype e_eac_r11g11_unorm_block = VK_FORMAT_EAC_R11G11_UNORM_BLOCK;
    static constexpr OEtype e_eac_r11g11_snorm_block = VK_FORMAT_EAC_R11G11_SNORM_BLOCK;
    static constexpr OEtype e_astc_4x4_unorm_block = VK_FORMAT_ASTC_4x4_UNORM_BLOCK;
    static constexpr OEtype e_astc_4x4_srgb_block = VK_FORMAT_ASTC_4x4_SRGB_BLOCK;
    static constexpr OEtype e_astc_5x4_unorm_block = VK_FORMAT_ASTC_5x4_UNORM_BLOCK;
    static constexpr OEtype e_astc_5x4_srgb_block = VK_FORMAT_ASTC_5x4_SRGB_BLOCK;
    static constexpr OEtype e_astc_5x5_unorm_block = VK_FORMAT_ASTC_5x5_UNORM_BLOCK;
    static constexpr OEtype e_astc_5x5_srgb_block = VK_FORMAT_ASTC_5x5_SRGB_BLOCK;
    static constexpr OEtype e_astc_6x5_unorm_block = VK_FORMAT_ASTC_6x5_UNORM_BLOCK;
    static constexpr OEtype e_astc_6x5_srgb_block = VK_FORMAT_ASTC_6x5_SRGB_BLOCK;
    static constexpr OEtype e_astc_6x6_unorm_block = VK_FORMAT_ASTC_6x6_UNORM_BLOCK;
    static constexpr OEtype e_astc_6x6_srgb_block = VK_FORMAT_ASTC_6x6_SRGB_BLOCK;
    static constexpr OEtype e_astc_8x5_unorm_block = VK_FORMAT_ASTC_8x5_UNORM_BLOCK;
    static constexpr OEtype e_astc_8x5_srgb_block = VK_FORMAT_ASTC_8x5_SRGB_BLOCK;
    static constexpr OEtype e_astc_8x6_unorm_block = VK_FORMAT_ASTC_8x6_UNORM_BLOCK;
    static constexpr OEtype e_astc_8x6_srgb_block = VK_FORMAT_ASTC_8x6_SRGB_BLOCK;
    static constexpr OEtype e_astc_8x8_unorm_block = VK_FORMAT_ASTC_8x8_UNORM_BLOCK;
    static constexpr OEtype e_astc_8x8_srgb_block = VK_FORMAT_ASTC_8x8_SRGB_BLOCK;
    static constexpr OEtype e_astc_10x5_unorm_block = VK_FORMAT_ASTC_10x5_UNORM_BLOCK;
    static constexpr OEtype e_astc_10x5_srgb_block = VK_FORMAT_ASTC_10x5_SRGB_BLOCK;
    static constexpr OEtype e_astc_10x6_unorm_block = VK_FORMAT_ASTC_10x6_UNORM_BLOCK;
    static constexpr OEtype e_astc_10x6_srgb_block = VK_FORMAT_ASTC_10x6_SRGB_BLOCK;
    static constexpr OEtype e_astc_10x8_unorm_block = VK_FORMAT_ASTC_10x8_UNORM_BLOCK;
    static constexpr OEtype e_astc_10x8_srgb_block = VK_FORMAT_ASTC_10x8_SRGB_BLOCK;
    static constexpr OEtype e_astc_10x10_unorm_block = VK_FORMAT_ASTC_10x10_UNORM_BLOCK;
    static constexpr OEtype e_astc_10x10_srgb_block = VK_FORMAT_ASTC_10x10_SRGB_BLOCK;
    static constexpr OEtype e_astc_12x10_unorm_block = VK_FORMAT_ASTC_12x10_UNORM_BLOCK;
    static constexpr OEtype e_astc_12x10_srgb_block = VK_FORMAT_ASTC_12x10_SRGB_BLOCK;
    static constexpr OEtype e_astc_12x12_unorm_block = VK_FORMAT_ASTC_12x12_UNORM_BLOCK;
    static constexpr OEtype e_astc_12x12_srgb_block = VK_FORMAT_ASTC_12x12_SRGB_BLOCK;
    static constexpr OEtype e_g8b8g8r8_422_unorm = VK_FORMAT_G8B8G8R8_422_UNORM;
    static constexpr OEtype e_b8g8r8g8_422_unorm = VK_FORMAT_B8G8R8G8_422_UNORM;
    static constexpr OEtype e_g8_b8_r8_3plane_420_unorm = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM;
    static constexpr OEtype e_g8_b8r8_2plane_420_unorm = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM;
    static constexpr OEtype e_g8_b8_r8_3plane_422_unorm = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM;
    static constexpr OEtype e_g8_b8r8_2plane_422_unorm = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM;
    static constexpr OEtype e_g8_b8_r8_3plane_444_unorm = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM;
    static constexpr OEtype e_r10x6_unorm_pack16 = VK_FORMAT_R10X6_UNORM_PACK16;
    static constexpr OEtype e_r10x6g10x6_unorm_2pack16 = VK_FORMAT_R10X6G10X6_UNORM_2PACK16;
    static constexpr OEtype e_r10x6g10x6b10x6a10x6_unorm_4pack16 = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16;
    static constexpr OEtype e_g10x6b10x6g10x6r10x6_422_unorm_4pack16 = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16;
    static constexpr OEtype e_b10x6g10x6r10x6g10x6_422_unorm_4pack16 = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16;
    static constexpr OEtype e_g10x6_b10x6_r10x6_3plane_420_unorm_3pack16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16;
    static constexpr OEtype e_g10x6_b10x6r10x6_2plane_420_unorm_3pack16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16;
    static constexpr OEtype e_g10x6_b10x6_r10x6_3plane_422_unorm_3pack16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16;
    static constexpr OEtype e_g10x6_b10x6r10x6_2plane_422_unorm_3pack16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16;
    static constexpr OEtype e_g10x6_b10x6_r10x6_3plane_444_unorm_3pack16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16;
    static constexpr OEtype e_r12x4_unorm_pack16 = VK_FORMAT_R12X4_UNORM_PACK16;
    static constexpr OEtype e_r12x4g12x4_unorm_2pack16 = VK_FORMAT_R12X4G12X4_UNORM_2PACK16;
    static constexpr OEtype e_r12x4g12x4b12x4a12x4_unorm_4pack16 = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16;
    static constexpr OEtype e_g12x4b12x4g12x4r12x4_422_unorm_4pack16 = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16;
    static constexpr OEtype e_b12x4g12x4r12x4g12x4_422_unorm_4pack16 = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16;
    static constexpr OEtype e_g12x4_b12x4_r12x4_3plane_420_unorm_3pack16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16;
    static constexpr OEtype e_g12x4_b12x4r12x4_2plane_420_unorm_3pack16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16;
    static constexpr OEtype e_g12x4_b12x4_r12x4_3plane_422_unorm_3pack16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16;
    static constexpr OEtype e_g12x4_b12x4r12x4_2plane_422_unorm_3pack16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16;
    static constexpr OEtype e_g12x4_b12x4_r12x4_3plane_444_unorm_3pack16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16;
    static constexpr OEtype e_g16b16g16r16_422_unorm = VK_FORMAT_G16B16G16R16_422_UNORM;
    static constexpr OEtype e_b16g16r16g16_422_unorm = VK_FORMAT_B16G16R16G16_422_UNORM;
    static constexpr OEtype e_g16_b16_r16_3plane_420_unorm = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM;
    static constexpr OEtype e_g16_b16r16_2plane_420_unorm = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM;
    static constexpr OEtype e_g16_b16_r16_3plane_422_unorm = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM;
    static constexpr OEtype e_g16_b16r16_2plane_422_unorm = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM;
    static constexpr OEtype e_g16_b16_r16_3plane_444_unorm = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM;
    static constexpr OEtype e_pvrtc1_2bpp_unorm_block_img = VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG;
    static constexpr OEtype e_pvrtc1_4bpp_unorm_block_img = VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG;
    static constexpr OEtype e_pvrtc2_2bpp_unorm_block_img = VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG;
    static constexpr OEtype e_pvrtc2_4bpp_unorm_block_img = VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG;
    static constexpr OEtype e_pvrtc1_2bpp_srgb_block_img = VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG;
    static constexpr OEtype e_pvrtc1_4bpp_srgb_block_img = VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG;
    static constexpr OEtype e_pvrtc2_2bpp_srgb_block_img = VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG;
    static constexpr OEtype e_pvrtc2_4bpp_srgb_block_img = VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG;
    static constexpr OEtype e_astc_4x4_sfloat_block_ext = VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_astc_5x4_sfloat_block_ext = VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_astc_5x5_sfloat_block_ext = VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_astc_6x5_sfloat_block_ext = VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_astc_6x6_sfloat_block_ext = VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_astc_8x5_sfloat_block_ext = VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_astc_8x6_sfloat_block_ext = VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_astc_8x8_sfloat_block_ext = VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_astc_10x5_sfloat_block_ext = VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_astc_10x6_sfloat_block_ext = VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_astc_10x8_sfloat_block_ext = VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_astc_10x10_sfloat_block_ext = VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_astc_12x10_sfloat_block_ext = VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_astc_12x12_sfloat_block_ext = VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT;
    static constexpr OEtype e_g8b8g8r8_422_unorm_khr = VK_FORMAT_G8B8G8R8_422_UNORM_KHR;
    static constexpr OEtype e_b8g8r8g8_422_unorm_khr = VK_FORMAT_B8G8R8G8_422_UNORM_KHR;
    static constexpr OEtype e_g8_b8_r8_3plane_420_unorm_khr = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR;
    static constexpr OEtype e_g8_b8r8_2plane_420_unorm_khr = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR;
    static constexpr OEtype e_g8_b8_r8_3plane_422_unorm_khr = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR;
    static constexpr OEtype e_g8_b8r8_2plane_422_unorm_khr = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR;
    static constexpr OEtype e_g8_b8_r8_3plane_444_unorm_khr = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR;
    static constexpr OEtype e_r10x6_unorm_pack16_khr = VK_FORMAT_R10X6_UNORM_PACK16_KHR;
    static constexpr OEtype e_r10x6g10x6_unorm_2pack16_khr = VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR;
    static constexpr OEtype e_r10x6g10x6b10x6a10x6_unorm_4pack16_khr = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR;
    static constexpr OEtype e_g10x6b10x6g10x6r10x6_422_unorm_4pack16_khr = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR;
    static constexpr OEtype e_b10x6g10x6r10x6g10x6_422_unorm_4pack16_khr = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR;
    static constexpr OEtype e_g10x6_b10x6_r10x6_3plane_420_unorm_3pack16_khr = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR;
    static constexpr OEtype e_g10x6_b10x6r10x6_2plane_420_unorm_3pack16_khr = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR;
    static constexpr OEtype e_g10x6_b10x6_r10x6_3plane_422_unorm_3pack16_khr = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR;
    static constexpr OEtype e_g10x6_b10x6r10x6_2plane_422_unorm_3pack16_khr = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR;
    static constexpr OEtype e_g10x6_b10x6_r10x6_3plane_444_unorm_3pack16_khr = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR;
    static constexpr OEtype e_r12x4_unorm_pack16_khr = VK_FORMAT_R12X4_UNORM_PACK16_KHR;
    static constexpr OEtype e_r12x4g12x4_unorm_2pack16_khr = VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR;
    static constexpr OEtype e_r12x4g12x4b12x4a12x4_unorm_4pack16_khr = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR;
    static constexpr OEtype e_g12x4b12x4g12x4r12x4_422_unorm_4pack16_khr = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR;
    static constexpr OEtype e_b12x4g12x4r12x4g12x4_422_unorm_4pack16_khr = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR;
    static constexpr OEtype e_g12x4_b12x4_r12x4_3plane_420_unorm_3pack16_khr = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR;
    static constexpr OEtype e_g12x4_b12x4r12x4_2plane_420_unorm_3pack16_khr = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR;
    static constexpr OEtype e_g12x4_b12x4_r12x4_3plane_422_unorm_3pack16_khr = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR;
    static constexpr OEtype e_g12x4_b12x4r12x4_2plane_422_unorm_3pack16_khr = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR;
    static constexpr OEtype e_g12x4_b12x4_r12x4_3plane_444_unorm_3pack16_khr = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR;
    static constexpr OEtype e_g16b16g16r16_422_unorm_khr = VK_FORMAT_G16B16G16R16_422_UNORM_KHR;
    static constexpr OEtype e_b16g16r16g16_422_unorm_khr = VK_FORMAT_B16G16R16G16_422_UNORM_KHR;
    static constexpr OEtype e_g16_b16_r16_3plane_420_unorm_khr = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR;
    static constexpr OEtype e_g16_b16r16_2plane_420_unorm_khr = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR;
    static constexpr OEtype e_g16_b16_r16_3plane_422_unorm_khr = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR;
    static constexpr OEtype e_g16_b16r16_2plane_422_unorm_khr = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR;
    static constexpr OEtype e_g16_b16_r16_3plane_444_unorm_khr = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR;
};
template<> struct detail::names_map<VkFormat> { using T = E_Format; };
struct E_VendorId : public E<VkVendorId> {
    using E::E; 
    static constexpr OEtype e_viv = VK_VENDOR_ID_VIV;
    static constexpr OEtype e_vsi = VK_VENDOR_ID_VSI;
    static constexpr OEtype e_kazan = VK_VENDOR_ID_KAZAN;
};
template<> struct detail::names_map<VkVendorId> { using T = E_VendorId; };
struct E_RasterizationOrderAMD : public E<VkRasterizationOrderAMD> {
    using E::E; 
    static constexpr OEtype e_strict_amd = VK_RASTERIZATION_ORDER_STRICT_AMD;
    static constexpr OEtype e_relaxed_amd = VK_RASTERIZATION_ORDER_RELAXED_AMD;
};
template<> struct detail::names_map<VkRasterizationOrderAMD> { using T = E_RasterizationOrderAMD; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct E_FullScreenExclusiveEXT : public E<VkFullScreenExclusiveEXT> {
    using E::E; 
    static constexpr OEtype e_default_ext = VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT;
    static constexpr OEtype e_allowed_ext = VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT;
    static constexpr OEtype e_disallowed_ext = VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT;
    static constexpr OEtype e_application_controlled_ext = VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT;
};
template<> struct detail::names_map<VkFullScreenExclusiveEXT> { using T = E_FullScreenExclusiveEXT; };

# endif
struct E_SamplerAddressMode : public E<VkSamplerAddressMode> {
    using E::E; 
    static constexpr OEtype e_repeat = VK_SAMPLER_ADDRESS_MODE_REPEAT;
    static constexpr OEtype e_mirrored_repeat = VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT;
    static constexpr OEtype e_clamp_to_edge = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
    static constexpr OEtype e_clamp_to_border = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
    static constexpr OEtype e_mirror_clamp_to_edge = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;
    static constexpr OEtype e_mirror_clamp_to_edge_khr = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR;
};
template<> struct detail::names_map<VkSamplerAddressMode> { using T = E_SamplerAddressMode; };
struct E_ImageType : public E<VkImageType> {
    using E::E; 
    static constexpr OEtype e_1d = VK_IMAGE_TYPE_1D;
    static constexpr OEtype e_2d = VK_IMAGE_TYPE_2D;
    static constexpr OEtype e_3d = VK_IMAGE_TYPE_3D;
};
template<> struct detail::names_map<VkImageType> { using T = E_ImageType; };
struct E_PipelineCacheHeaderVersion : public E<VkPipelineCacheHeaderVersion> {
    using E::E; 
    static constexpr OEtype e_one = VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
};
template<> struct detail::names_map<VkPipelineCacheHeaderVersion> { using T = E_PipelineCacheHeaderVersion; };
struct E_ViewportCoordinateSwizzleNV : public E<VkViewportCoordinateSwizzleNV> {
    using E::E; 
    static constexpr OEtype e_positive_x_nv = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV;
    static constexpr OEtype e_negative_x_nv = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV;
    static constexpr OEtype e_positive_y_nv = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV;
    static constexpr OEtype e_negative_y_nv = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV;
    static constexpr OEtype e_positive_z_nv = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV;
    static constexpr OEtype e_negative_z_nv = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV;
    static constexpr OEtype e_positive_w_nv = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV;
    static constexpr OEtype e_negative_w_nv = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV;
};
template<> struct detail::names_map<VkViewportCoordinateSwizzleNV> { using T = E_ViewportCoordinateSwizzleNV; };
struct E_IndirectCommandsTokenTypeNVX : public E<VkIndirectCommandsTokenTypeNVX> {
    using E::E; 
    static constexpr OEtype e_pipeline_nvx = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX;
    static constexpr OEtype e_descriptor_set_nvx = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX;
    static constexpr OEtype e_index_buffer_nvx = VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX;
    static constexpr OEtype e_vertex_buffer_nvx = VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX;
    static constexpr OEtype e_push_constant_nvx = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX;
    static constexpr OEtype e_draw_indexed_nvx = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX;
    static constexpr OEtype e_draw_nvx = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX;
    static constexpr OEtype e_dispatch_nvx = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX;
};
template<> struct detail::names_map<VkIndirectCommandsTokenTypeNVX> { using T = E_IndirectCommandsTokenTypeNVX; };
struct E_ShaderInfoTypeAMD : public E<VkShaderInfoTypeAMD> {
    using E::E; 
    static constexpr OEtype e_statistics_amd = VK_SHADER_INFO_TYPE_STATISTICS_AMD;
    static constexpr OEtype e_binary_amd = VK_SHADER_INFO_TYPE_BINARY_AMD;
    static constexpr OEtype e_disassembly_amd = VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD;
};
template<> struct detail::names_map<VkShaderInfoTypeAMD> { using T = E_ShaderInfoTypeAMD; };
struct E_ImageTiling : public E<VkImageTiling> {
    using E::E; 
    static constexpr OEtype e_optimal = VK_IMAGE_TILING_OPTIMAL;
    static constexpr OEtype e_linear = VK_IMAGE_TILING_LINEAR;
    static constexpr OEtype e_drm_format_modifier_ext = VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT;
};
template<> struct detail::names_map<VkImageTiling> { using T = E_ImageTiling; };
struct E_StencilOp : public E<VkStencilOp> {
    using E::E; 
    static constexpr OEtype e_keep = VK_STENCIL_OP_KEEP;
    static constexpr OEtype e_zero = VK_STENCIL_OP_ZERO;
    static constexpr OEtype e_replace = VK_STENCIL_OP_REPLACE;
    static constexpr OEtype e_increment_and_clamp = VK_STENCIL_OP_INCREMENT_AND_CLAMP;
    static constexpr OEtype e_decrement_and_clamp = VK_STENCIL_OP_DECREMENT_AND_CLAMP;
    static constexpr OEtype e_invert = VK_STENCIL_OP_INVERT;
    static constexpr OEtype e_increment_and_wrap = VK_STENCIL_OP_INCREMENT_AND_WRAP;
    static constexpr OEtype e_decrement_and_wrap = VK_STENCIL_OP_DECREMENT_AND_WRAP;
};
template<> struct detail::names_map<VkStencilOp> { using T = E_StencilOp; };
struct E_ValidationCheckEXT : public E<VkValidationCheckEXT> {
    using E::E; 
    static constexpr OEtype e_all_ext = VK_VALIDATION_CHECK_ALL_EXT;
    static constexpr OEtype e_shaders_ext = VK_VALIDATION_CHECK_SHADERS_EXT;
};
template<> struct detail::names_map<VkValidationCheckEXT> { using T = E_ValidationCheckEXT; };
struct E_Result : public E<VkResult> {
    using E::E; 
    static constexpr OEtype e_success = VK_SUCCESS;
    static constexpr OEtype e_not_ready = VK_NOT_READY;
    static constexpr OEtype e_timeout = VK_TIMEOUT;
    static constexpr OEtype e_event_set = VK_EVENT_SET;
    static constexpr OEtype e_event_reset = VK_EVENT_RESET;
    static constexpr OEtype e_incomplete = VK_INCOMPLETE;
    static constexpr OEtype e_error_out_of_host_memory = VK_ERROR_OUT_OF_HOST_MEMORY;
    static constexpr OEtype e_error_out_of_device_memory = VK_ERROR_OUT_OF_DEVICE_MEMORY;
    static constexpr OEtype e_error_initialization_failed = VK_ERROR_INITIALIZATION_FAILED;
    static constexpr OEtype e_error_device_lost = VK_ERROR_DEVICE_LOST;
    static constexpr OEtype e_error_memory_map_failed = VK_ERROR_MEMORY_MAP_FAILED;
    static constexpr OEtype e_error_layer_not_present = VK_ERROR_LAYER_NOT_PRESENT;
    static constexpr OEtype e_error_extension_not_present = VK_ERROR_EXTENSION_NOT_PRESENT;
    static constexpr OEtype e_error_feature_not_present = VK_ERROR_FEATURE_NOT_PRESENT;
    static constexpr OEtype e_error_incompatible_driver = VK_ERROR_INCOMPATIBLE_DRIVER;
    static constexpr OEtype e_error_too_many_objects = VK_ERROR_TOO_MANY_OBJECTS;
    static constexpr OEtype e_error_format_not_supported = VK_ERROR_FORMAT_NOT_SUPPORTED;
    static constexpr OEtype e_error_fragmented_pool = VK_ERROR_FRAGMENTED_POOL;
    static constexpr OEtype e_error_out_of_pool_memory = VK_ERROR_OUT_OF_POOL_MEMORY;
    static constexpr OEtype e_error_invalid_external_handle = VK_ERROR_INVALID_EXTERNAL_HANDLE;
    static constexpr OEtype e_error_surface_lost_khr = VK_ERROR_SURFACE_LOST_KHR;
    static constexpr OEtype e_error_native_window_in_use_khr = VK_ERROR_NATIVE_WINDOW_IN_USE_KHR;
    static constexpr OEtype e_suboptimal_khr = VK_SUBOPTIMAL_KHR;
    static constexpr OEtype e_error_out_of_date_khr = VK_ERROR_OUT_OF_DATE_KHR;
    static constexpr OEtype e_error_incompatible_display_khr = VK_ERROR_INCOMPATIBLE_DISPLAY_KHR;
    static constexpr OEtype e_error_validation_failed_ext = VK_ERROR_VALIDATION_FAILED_EXT;
    static constexpr OEtype e_error_invalid_shader_nv = VK_ERROR_INVALID_SHADER_NV;
    static constexpr OEtype e_error_out_of_pool_memory_khr = VK_ERROR_OUT_OF_POOL_MEMORY_KHR;
    static constexpr OEtype e_error_invalid_external_handle_khr = VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR;
    static constexpr OEtype e_error_invalid_drm_format_modifier_plane_layout_ext = VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT;
    static constexpr OEtype e_error_fragmentation_ext = VK_ERROR_FRAGMENTATION_EXT;
    static constexpr OEtype e_error_not_permitted_ext = VK_ERROR_NOT_PERMITTED_EXT;
    static constexpr OEtype e_error_invalid_device_address_ext = VK_ERROR_INVALID_DEVICE_ADDRESS_EXT;
    static constexpr OEtype e_error_full_screen_exclusive_mode_lost_ext = VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT;
};
template<> struct detail::names_map<VkResult> { using T = E_Result; };
struct E_IndexType : public E<VkIndexType> {
    using E::E; 
    static constexpr OEtype e_uint16 = VK_INDEX_TYPE_UINT16;
    static constexpr OEtype e_uint32 = VK_INDEX_TYPE_UINT32;
    static constexpr OEtype e_none_nv = VK_INDEX_TYPE_NONE_NV;
};
template<> struct detail::names_map<VkIndexType> { using T = E_IndexType; };
struct E_QueueGlobalPriorityEXT : public E<VkQueueGlobalPriorityEXT> {
    using E::E; 
    static constexpr OEtype e_low_ext = VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT;
    static constexpr OEtype e_medium_ext = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT;
    static constexpr OEtype e_high_ext = VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT;
    static constexpr OEtype e_realtime_ext = VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT;
};
template<> struct detail::names_map<VkQueueGlobalPriorityEXT> { using T = E_QueueGlobalPriorityEXT; };
struct E_SamplerYcbcrRange : public E<VkSamplerYcbcrRange> {
    using E::E; 
    static constexpr OEtype e_itu_full = VK_SAMPLER_YCBCR_RANGE_ITU_FULL;
    static constexpr OEtype e_itu_narrow = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW;
    static constexpr OEtype e_itu_full_khr = VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR;
    static constexpr OEtype e_itu_narrow_khr = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR;
};
template<> struct detail::names_map<VkSamplerYcbcrRange> { using T = E_SamplerYcbcrRange; };
struct E_DescriptorUpdateTemplateType : public E<VkDescriptorUpdateTemplateType> {
    using E::E; 
    static constexpr OEtype e_descriptor_set = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
    static constexpr OEtype e_push_descriptors_khr = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR;
    static constexpr OEtype e_descriptor_set_khr = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR;
};
template<> struct detail::names_map<VkDescriptorUpdateTemplateType> { using T = E_DescriptorUpdateTemplateType; };
struct E_VertexInputRate : public E<VkVertexInputRate> {
    using E::E; 
    static constexpr OEtype e_vertex = VK_VERTEX_INPUT_RATE_VERTEX;
    static constexpr OEtype e_instance = VK_VERTEX_INPUT_RATE_INSTANCE;
};
template<> struct detail::names_map<VkVertexInputRate> { using T = E_VertexInputRate; };
struct E_BlendFactor : public E<VkBlendFactor> {
    using E::E; 
    static constexpr OEtype e_zero = VK_BLEND_FACTOR_ZERO;
    static constexpr OEtype e_one = VK_BLEND_FACTOR_ONE;
    static constexpr OEtype e_src_color = VK_BLEND_FACTOR_SRC_COLOR;
    static constexpr OEtype e_one_minus_src_color = VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR;
    static constexpr OEtype e_dst_color = VK_BLEND_FACTOR_DST_COLOR;
    static constexpr OEtype e_one_minus_dst_color = VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR;
    static constexpr OEtype e_src_alpha = VK_BLEND_FACTOR_SRC_ALPHA;
    static constexpr OEtype e_one_minus_src_alpha = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;
    static constexpr OEtype e_dst_alpha = VK_BLEND_FACTOR_DST_ALPHA;
    static constexpr OEtype e_one_minus_dst_alpha = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA;
    static constexpr OEtype e_constant_color = VK_BLEND_FACTOR_CONSTANT_COLOR;
    static constexpr OEtype e_one_minus_constant_color = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR;
    static constexpr OEtype e_constant_alpha = VK_BLEND_FACTOR_CONSTANT_ALPHA;
    static constexpr OEtype e_one_minus_constant_alpha = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA;
    static constexpr OEtype e_src_alpha_saturate = VK_BLEND_FACTOR_SRC_ALPHA_SATURATE;
    static constexpr OEtype e_src1_color = VK_BLEND_FACTOR_SRC1_COLOR;
    static constexpr OEtype e_one_minus_src1_color = VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR;
    static constexpr OEtype e_src1_alpha = VK_BLEND_FACTOR_SRC1_ALPHA;
    static constexpr OEtype e_one_minus_src1_alpha = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA;
};
template<> struct detail::names_map<VkBlendFactor> { using T = E_BlendFactor; };
struct E_CompareOp : public E<VkCompareOp> {
    using E::E; 
    static constexpr OEtype e_never = VK_COMPARE_OP_NEVER;
    static constexpr OEtype e_less = VK_COMPARE_OP_LESS;
    static constexpr OEtype e_equal = VK_COMPARE_OP_EQUAL;
    static constexpr OEtype e_less_or_equal = VK_COMPARE_OP_LESS_OR_EQUAL;
    static constexpr OEtype e_greater = VK_COMPARE_OP_GREATER;
    static constexpr OEtype e_not_equal = VK_COMPARE_OP_NOT_EQUAL;
    static constexpr OEtype e_greater_or_equal = VK_COMPARE_OP_GREATER_OR_EQUAL;
    static constexpr OEtype e_always = VK_COMPARE_OP_ALWAYS;
};
template<> struct detail::names_map<VkCompareOp> { using T = E_CompareOp; };
struct E_CoarseSampleOrderTypeNV : public E<VkCoarseSampleOrderTypeNV> {
    using E::E; 
    static constexpr OEtype e_default_nv = VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV;
    static constexpr OEtype e_custom_nv = VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV;
    static constexpr OEtype e_pixel_major_nv = VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV;
    static constexpr OEtype e_sample_major_nv = VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV;
};
template<> struct detail::names_map<VkCoarseSampleOrderTypeNV> { using T = E_CoarseSampleOrderTypeNV; };
struct E_InternalAllocationType : public E<VkInternalAllocationType> {
    using E::E; 
    static constexpr OEtype e_executable = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
};
template<> struct detail::names_map<VkInternalAllocationType> { using T = E_InternalAllocationType; };
struct E_SamplerReductionModeEXT : public E<VkSamplerReductionModeEXT> {
    using E::E; 
    static constexpr OEtype e_weighted_average_ext = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT;
    static constexpr OEtype e_min_ext = VK_SAMPLER_REDUCTION_MODE_MIN_EXT;
    static constexpr OEtype e_max_ext = VK_SAMPLER_REDUCTION_MODE_MAX_EXT;
};
template<> struct detail::names_map<VkSamplerReductionModeEXT> { using T = E_SamplerReductionModeEXT; };
struct E_LineRasterizationModeEXT : public E<VkLineRasterizationModeEXT> {
    using E::E; 
    static constexpr OEtype e_default_ext = VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT;
    static constexpr OEtype e_rectangular_ext = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT;
    static constexpr OEtype e_bresenham_ext = VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT;
    static constexpr OEtype e_rectangular_smooth_ext = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT;
};
template<> struct detail::names_map<VkLineRasterizationModeEXT> { using T = E_LineRasterizationModeEXT; };
struct E_BlendOp : public E<VkBlendOp> {
    using E::E; 
    static constexpr OEtype e_add = VK_BLEND_OP_ADD;
    static constexpr OEtype e_subtract = VK_BLEND_OP_SUBTRACT;
    static constexpr OEtype e_reverse_subtract = VK_BLEND_OP_REVERSE_SUBTRACT;
    static constexpr OEtype e_min = VK_BLEND_OP_MIN;
    static constexpr OEtype e_max = VK_BLEND_OP_MAX;
    static constexpr OEtype e_zero_ext = VK_BLEND_OP_ZERO_EXT;
    static constexpr OEtype e_src_ext = VK_BLEND_OP_SRC_EXT;
    static constexpr OEtype e_dst_ext = VK_BLEND_OP_DST_EXT;
    static constexpr OEtype e_src_over_ext = VK_BLEND_OP_SRC_OVER_EXT;
    static constexpr OEtype e_dst_over_ext = VK_BLEND_OP_DST_OVER_EXT;
    static constexpr OEtype e_src_in_ext = VK_BLEND_OP_SRC_IN_EXT;
    static constexpr OEtype e_dst_in_ext = VK_BLEND_OP_DST_IN_EXT;
    static constexpr OEtype e_src_out_ext = VK_BLEND_OP_SRC_OUT_EXT;
    static constexpr OEtype e_dst_out_ext = VK_BLEND_OP_DST_OUT_EXT;
    static constexpr OEtype e_src_atop_ext = VK_BLEND_OP_SRC_ATOP_EXT;
    static constexpr OEtype e_dst_atop_ext = VK_BLEND_OP_DST_ATOP_EXT;
    static constexpr OEtype e_xor_ext = VK_BLEND_OP_XOR_EXT;
    static constexpr OEtype e_multiply_ext = VK_BLEND_OP_MULTIPLY_EXT;
    static constexpr OEtype e_screen_ext = VK_BLEND_OP_SCREEN_EXT;
    static constexpr OEtype e_overlay_ext = VK_BLEND_OP_OVERLAY_EXT;
    static constexpr OEtype e_darken_ext = VK_BLEND_OP_DARKEN_EXT;
    static constexpr OEtype e_lighten_ext = VK_BLEND_OP_LIGHTEN_EXT;
    static constexpr OEtype e_colordodge_ext = VK_BLEND_OP_COLORDODGE_EXT;
    static constexpr OEtype e_colorburn_ext = VK_BLEND_OP_COLORBURN_EXT;
    static constexpr OEtype e_hardlight_ext = VK_BLEND_OP_HARDLIGHT_EXT;
    static constexpr OEtype e_softlight_ext = VK_BLEND_OP_SOFTLIGHT_EXT;
    static constexpr OEtype e_difference_ext = VK_BLEND_OP_DIFFERENCE_EXT;
    static constexpr OEtype e_exclusion_ext = VK_BLEND_OP_EXCLUSION_EXT;
    static constexpr OEtype e_invert_ext = VK_BLEND_OP_INVERT_EXT;
    static constexpr OEtype e_invert_rgb_ext = VK_BLEND_OP_INVERT_RGB_EXT;
    static constexpr OEtype e_lineardodge_ext = VK_BLEND_OP_LINEARDODGE_EXT;
    static constexpr OEtype e_linearburn_ext = VK_BLEND_OP_LINEARBURN_EXT;
    static constexpr OEtype e_vividlight_ext = VK_BLEND_OP_VIVIDLIGHT_EXT;
    static constexpr OEtype e_linearlight_ext = VK_BLEND_OP_LINEARLIGHT_EXT;
    static constexpr OEtype e_pinlight_ext = VK_BLEND_OP_PINLIGHT_EXT;
    static constexpr OEtype e_hardmix_ext = VK_BLEND_OP_HARDMIX_EXT;
    static constexpr OEtype e_hsl_hue_ext = VK_BLEND_OP_HSL_HUE_EXT;
    static constexpr OEtype e_hsl_saturation_ext = VK_BLEND_OP_HSL_SATURATION_EXT;
    static constexpr OEtype e_hsl_color_ext = VK_BLEND_OP_HSL_COLOR_EXT;
    static constexpr OEtype e_hsl_luminosity_ext = VK_BLEND_OP_HSL_LUMINOSITY_EXT;
    static constexpr OEtype e_plus_ext = VK_BLEND_OP_PLUS_EXT;
    static constexpr OEtype e_plus_clamped_ext = VK_BLEND_OP_PLUS_CLAMPED_EXT;
    static constexpr OEtype e_plus_clamped_alpha_ext = VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT;
    static constexpr OEtype e_plus_darker_ext = VK_BLEND_OP_PLUS_DARKER_EXT;
    static constexpr OEtype e_minus_ext = VK_BLEND_OP_MINUS_EXT;
    static constexpr OEtype e_minus_clamped_ext = VK_BLEND_OP_MINUS_CLAMPED_EXT;
    static constexpr OEtype e_contrast_ext = VK_BLEND_OP_CONTRAST_EXT;
    static constexpr OEtype e_invert_ovg_ext = VK_BLEND_OP_INVERT_OVG_EXT;
    static constexpr OEtype e_red_ext = VK_BLEND_OP_RED_EXT;
    static constexpr OEtype e_green_ext = VK_BLEND_OP_GREEN_EXT;
    static constexpr OEtype e_blue_ext = VK_BLEND_OP_BLUE_EXT;
};
template<> struct detail::names_map<VkBlendOp> { using T = E_BlendOp; };
struct E_FrontFace : public E<VkFrontFace> {
    using E::E; 
    static constexpr OEtype e_counter_clockwise = VK_FRONT_FACE_COUNTER_CLOCKWISE;
    static constexpr OEtype e_clockwise = VK_FRONT_FACE_CLOCKWISE;
};
template<> struct detail::names_map<VkFrontFace> { using T = E_FrontFace; };
struct E_PerformanceOverrideTypeINTEL : public E<VkPerformanceOverrideTypeINTEL> {
    using E::E; 
    static constexpr OEtype e_null_hardware_intel = VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL;
    static constexpr OEtype e_flush_gpu_caches_intel = VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL;
};
template<> struct detail::names_map<VkPerformanceOverrideTypeINTEL> { using T = E_PerformanceOverrideTypeINTEL; };
struct E_AttachmentLoadOp : public E<VkAttachmentLoadOp> {
    using E::E; 
    static constexpr OEtype e_load = VK_ATTACHMENT_LOAD_OP_LOAD;
    static constexpr OEtype e_clear = VK_ATTACHMENT_LOAD_OP_CLEAR;
    static constexpr OEtype e_dont_care = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
};
template<> struct detail::names_map<VkAttachmentLoadOp> { using T = E_AttachmentLoadOp; };
struct E_CopyAccelerationStructureModeNV : public E<VkCopyAccelerationStructureModeNV> {
    using E::E; 
    static constexpr OEtype e_clone_nv = VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV;
    static constexpr OEtype e_compact_nv = VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV;
};
template<> struct detail::names_map<VkCopyAccelerationStructureModeNV> { using T = E_CopyAccelerationStructureModeNV; };
struct E_LogicOp : public E<VkLogicOp> {
    using E::E; 
    static constexpr OEtype e_clear = VK_LOGIC_OP_CLEAR;
    static constexpr OEtype e_and = VK_LOGIC_OP_AND;
    static constexpr OEtype e_and_reverse = VK_LOGIC_OP_AND_REVERSE;
    static constexpr OEtype e_copy = VK_LOGIC_OP_COPY;
    static constexpr OEtype e_and_inverted = VK_LOGIC_OP_AND_INVERTED;
    static constexpr OEtype e_no_op = VK_LOGIC_OP_NO_OP;
    static constexpr OEtype e_xor = VK_LOGIC_OP_XOR;
    static constexpr OEtype e_or = VK_LOGIC_OP_OR;
    static constexpr OEtype e_nor = VK_LOGIC_OP_NOR;
    static constexpr OEtype e_equivalent = VK_LOGIC_OP_EQUIVALENT;
    static constexpr OEtype e_invert = VK_LOGIC_OP_INVERT;
    static constexpr OEtype e_or_reverse = VK_LOGIC_OP_OR_REVERSE;
    static constexpr OEtype e_copy_inverted = VK_LOGIC_OP_COPY_INVERTED;
    static constexpr OEtype e_or_inverted = VK_LOGIC_OP_OR_INVERTED;
    static constexpr OEtype e_nand = VK_LOGIC_OP_NAND;
    static constexpr OEtype e_set = VK_LOGIC_OP_SET;
};
template<> struct detail::names_map<VkLogicOp> { using T = E_LogicOp; };
struct E_RayTracingShaderGroupTypeNV : public E<VkRayTracingShaderGroupTypeNV> {
    using E::E; 
    static constexpr OEtype e_general_nv = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV;
    static constexpr OEtype e_triangles_hit_group_nv = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV;
    static constexpr OEtype e_procedural_hit_group_nv = VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV;
};
template<> struct detail::names_map<VkRayTracingShaderGroupTypeNV> { using T = E_RayTracingShaderGroupTypeNV; };
struct E_DisplayEventTypeEXT : public E<VkDisplayEventTypeEXT> {
    using E::E; 
    static constexpr OEtype e_first_pixel_out_ext = VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;
};
template<> struct detail::names_map<VkDisplayEventTypeEXT> { using T = E_DisplayEventTypeEXT; };
struct E_PresentModeKHR : public E<VkPresentModeKHR> {
    using E::E; 
    static constexpr OEtype e_immediate_khr = VK_PRESENT_MODE_IMMEDIATE_KHR;
    static constexpr OEtype e_mailbox_khr = VK_PRESENT_MODE_MAILBOX_KHR;
    static constexpr OEtype e_fifo_khr = VK_PRESENT_MODE_FIFO_KHR;
    static constexpr OEtype e_fifo_relaxed_khr = VK_PRESENT_MODE_FIFO_RELAXED_KHR;
    static constexpr OEtype e_shared_demand_refresh_khr = VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR;
    static constexpr OEtype e_shared_continuous_refresh_khr = VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR;
};
template<> struct detail::names_map<VkPresentModeKHR> { using T = E_PresentModeKHR; };
struct E_ComponentTypeNV : public E<VkComponentTypeNV> {
    using E::E; 
    static constexpr OEtype e_float16_nv = VK_COMPONENT_TYPE_FLOAT16_NV;
    static constexpr OEtype e_float32_nv = VK_COMPONENT_TYPE_FLOAT32_NV;
    static constexpr OEtype e_float64_nv = VK_COMPONENT_TYPE_FLOAT64_NV;
    static constexpr OEtype e_sint8_nv = VK_COMPONENT_TYPE_SINT8_NV;
    static constexpr OEtype e_sint16_nv = VK_COMPONENT_TYPE_SINT16_NV;
    static constexpr OEtype e_sint32_nv = VK_COMPONENT_TYPE_SINT32_NV;
    static constexpr OEtype e_sint64_nv = VK_COMPONENT_TYPE_SINT64_NV;
    static constexpr OEtype e_uint8_nv = VK_COMPONENT_TYPE_UINT8_NV;
    static constexpr OEtype e_uint16_nv = VK_COMPONENT_TYPE_UINT16_NV;
    static constexpr OEtype e_uint32_nv = VK_COMPONENT_TYPE_UINT32_NV;
    static constexpr OEtype e_uint64_nv = VK_COMPONENT_TYPE_UINT64_NV;
};
template<> struct detail::names_map<VkComponentTypeNV> { using T = E_ComponentTypeNV; };
struct E_DynamicState : public E<VkDynamicState> {
    using E::E; 
    static constexpr OEtype e_viewport = VK_DYNAMIC_STATE_VIEWPORT;
    static constexpr OEtype e_scissor = VK_DYNAMIC_STATE_SCISSOR;
    static constexpr OEtype e_line_width = VK_DYNAMIC_STATE_LINE_WIDTH;
    static constexpr OEtype e_depth_bias = VK_DYNAMIC_STATE_DEPTH_BIAS;
    static constexpr OEtype e_blend_constants = VK_DYNAMIC_STATE_BLEND_CONSTANTS;
    static constexpr OEtype e_depth_bounds = VK_DYNAMIC_STATE_DEPTH_BOUNDS;
    static constexpr OEtype e_stencil_compare_mask = VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK;
    static constexpr OEtype e_stencil_write_mask = VK_DYNAMIC_STATE_STENCIL_WRITE_MASK;
    static constexpr OEtype e_stencil_reference = VK_DYNAMIC_STATE_STENCIL_REFERENCE;
    static constexpr OEtype e_viewport_w_scaling_nv = VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV;
    static constexpr OEtype e_discard_rectangle_ext = VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT;
    static constexpr OEtype e_sample_locations_ext = VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT;
    static constexpr OEtype e_viewport_shading_rate_palette_nv = VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV;
    static constexpr OEtype e_viewport_coarse_sample_order_nv = VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV;
    static constexpr OEtype e_exclusive_scissor_nv = VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV;
    static constexpr OEtype e_line_stipple_ext = VK_DYNAMIC_STATE_LINE_STIPPLE_EXT;
};
template<> struct detail::names_map<VkDynamicState> { using T = E_DynamicState; };
struct E_ValidationFeatureEnableEXT : public E<VkValidationFeatureEnableEXT> {
    using E::E; 
    static constexpr OEtype e_gpu_assisted_ext = VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT;
    static constexpr OEtype e_gpu_assisted_reserve_binding_slot_ext = VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT;
    static constexpr OEtype e_best_practices_ext = VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT;
};
template<> struct detail::names_map<VkValidationFeatureEnableEXT> { using T = E_ValidationFeatureEnableEXT; };
struct E_ConservativeRasterizationModeEXT : public E<VkConservativeRasterizationModeEXT> {
    using E::E; 
    static constexpr OEtype e_disabled_ext = VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT;
    static constexpr OEtype e_overestimate_ext = VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT;
    static constexpr OEtype e_underestimate_ext = VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT;
};
template<> struct detail::names_map<VkConservativeRasterizationModeEXT> { using T = E_ConservativeRasterizationModeEXT; };
struct E_AttachmentStoreOp : public E<VkAttachmentStoreOp> {
    using E::E; 
    static constexpr OEtype e_store = VK_ATTACHMENT_STORE_OP_STORE;
    static constexpr OEtype e_dont_care = VK_ATTACHMENT_STORE_OP_DONT_CARE;
};
template<> struct detail::names_map<VkAttachmentStoreOp> { using T = E_AttachmentStoreOp; };
struct E_SystemAllocationScope : public E<VkSystemAllocationScope> {
    using E::E; 
    static constexpr OEtype e_command = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND;
    static constexpr OEtype e_object = VK_SYSTEM_ALLOCATION_SCOPE_OBJECT;
    static constexpr OEtype e_cache = VK_SYSTEM_ALLOCATION_SCOPE_CACHE;
    static constexpr OEtype e_device = VK_SYSTEM_ALLOCATION_SCOPE_DEVICE;
    static constexpr OEtype e_instance = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE;
};
template<> struct detail::names_map<VkSystemAllocationScope> { using T = E_SystemAllocationScope; };
struct E_PointClippingBehavior : public E<VkPointClippingBehavior> {
    using E::E; 
    static constexpr OEtype e_all_clip_planes = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES;
    static constexpr OEtype e_user_clip_planes_only = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY;
    static constexpr OEtype e_all_clip_planes_khr = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR;
    static constexpr OEtype e_user_clip_planes_only_khr = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR;
};
template<> struct detail::names_map<VkPointClippingBehavior> { using T = E_PointClippingBehavior; };
struct E_BorderColor : public E<VkBorderColor> {
    using E::E; 
    static constexpr OEtype e_float_transparent_black = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK;
    static constexpr OEtype e_int_transparent_black = VK_BORDER_COLOR_INT_TRANSPARENT_BLACK;
    static constexpr OEtype e_float_opaque_black = VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK;
    static constexpr OEtype e_int_opaque_black = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
    static constexpr OEtype e_float_opaque_white = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;
    static constexpr OEtype e_int_opaque_white = VK_BORDER_COLOR_INT_OPAQUE_WHITE;
};
template<> struct detail::names_map<VkBorderColor> { using T = E_BorderColor; };
struct E_StructureType : public E<VkStructureType> {
    using E::E; 
    static constexpr OEtype e_application_info = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    static constexpr OEtype e_instance_create_info = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    static constexpr OEtype e_device_queue_create_info = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    static constexpr OEtype e_device_create_info = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    static constexpr OEtype e_submit_info = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    static constexpr OEtype e_memory_allocate_info = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
    static constexpr OEtype e_mapped_memory_range = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
    static constexpr OEtype e_bind_sparse_info = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;
    static constexpr OEtype e_fence_create_info = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
    static constexpr OEtype e_semaphore_create_info = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
    static constexpr OEtype e_event_create_info = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
    static constexpr OEtype e_query_pool_create_info = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
    static constexpr OEtype e_buffer_create_info = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    static constexpr OEtype e_buffer_view_create_info = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
    static constexpr OEtype e_image_create_info = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    static constexpr OEtype e_image_view_create_info = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    static constexpr OEtype e_shader_module_create_info = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    static constexpr OEtype e_pipeline_cache_create_info = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
    static constexpr OEtype e_pipeline_shader_stage_create_info = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    static constexpr OEtype e_pipeline_vertex_input_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    static constexpr OEtype e_pipeline_input_assembly_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    static constexpr OEtype e_pipeline_tessellation_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
    static constexpr OEtype e_pipeline_viewport_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
    static constexpr OEtype e_pipeline_rasterization_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    static constexpr OEtype e_pipeline_multisample_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
    static constexpr OEtype e_pipeline_depth_stencil_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    static constexpr OEtype e_pipeline_color_blend_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
    static constexpr OEtype e_pipeline_dynamic_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    static constexpr OEtype e_graphics_pipeline_create_info = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    static constexpr OEtype e_compute_pipeline_create_info = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
    static constexpr OEtype e_pipeline_layout_create_info = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
    static constexpr OEtype e_sampler_create_info = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    static constexpr OEtype e_descriptor_set_layout_create_info = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
    static constexpr OEtype e_descriptor_pool_create_info = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
    static constexpr OEtype e_descriptor_set_allocate_info = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
    static constexpr OEtype e_write_descriptor_set = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    static constexpr OEtype e_copy_descriptor_set = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
    static constexpr OEtype e_framebuffer_create_info = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    static constexpr OEtype e_render_pass_create_info = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
    static constexpr OEtype e_command_pool_create_info = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    static constexpr OEtype e_command_buffer_allocate_info = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    static constexpr OEtype e_command_buffer_inheritance_info = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;
    static constexpr OEtype e_command_buffer_begin_info = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    static constexpr OEtype e_render_pass_begin_info = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    static constexpr OEtype e_buffer_memory_barrier = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
    static constexpr OEtype e_image_memory_barrier = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
    static constexpr OEtype e_memory_barrier = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
    static constexpr OEtype e_loader_instance_create_info = VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO;
    static constexpr OEtype e_loader_device_create_info = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO;
    static constexpr OEtype e_physical_device_subgroup_properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
    static constexpr OEtype e_bind_buffer_memory_info = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
    static constexpr OEtype e_bind_image_memory_info = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
    static constexpr OEtype e_physical_device_16bit_storage_features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
    static constexpr OEtype e_memory_dedicated_requirements = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
    static constexpr OEtype e_memory_dedicated_allocate_info = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
    static constexpr OEtype e_memory_allocate_flags_info = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
    static constexpr OEtype e_device_group_render_pass_begin_info = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
    static constexpr OEtype e_device_group_command_buffer_begin_info = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
    static constexpr OEtype e_device_group_submit_info = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
    static constexpr OEtype e_device_group_bind_sparse_info = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
    static constexpr OEtype e_bind_buffer_memory_device_group_info = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
    static constexpr OEtype e_bind_image_memory_device_group_info = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
    static constexpr OEtype e_physical_device_group_properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
    static constexpr OEtype e_device_group_device_create_info = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
    static constexpr OEtype e_buffer_memory_requirements_info_2 = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;
    static constexpr OEtype e_image_memory_requirements_info_2 = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;
    static constexpr OEtype e_image_sparse_memory_requirements_info_2 = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
    static constexpr OEtype e_memory_requirements_2 = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
    static constexpr OEtype e_sparse_image_memory_requirements_2 = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
    static constexpr OEtype e_physical_device_features_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
    static constexpr OEtype e_physical_device_properties_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
    static constexpr OEtype e_format_properties_2 = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
    static constexpr OEtype e_image_format_properties_2 = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
    static constexpr OEtype e_physical_device_image_format_info_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
    static constexpr OEtype e_queue_family_properties_2 = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
    static constexpr OEtype e_physical_device_memory_properties_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
    static constexpr OEtype e_sparse_image_format_properties_2 = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;
    static constexpr OEtype e_physical_device_sparse_image_format_info_2 = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
    static constexpr OEtype e_physical_device_point_clipping_properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
    static constexpr OEtype e_render_pass_input_attachment_aspect_create_info = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
    static constexpr OEtype e_image_view_usage_create_info = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
    static constexpr OEtype e_pipeline_tessellation_domain_origin_state_create_info = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
    static constexpr OEtype e_render_pass_multiview_create_info = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
    static constexpr OEtype e_physical_device_multiview_features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
    static constexpr OEtype e_physical_device_multiview_properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
    static constexpr OEtype e_physical_device_variable_pointers_features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
    static constexpr OEtype e_physical_device_variable_pointer_features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES;
    static constexpr OEtype e_protected_submit_info = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
    static constexpr OEtype e_physical_device_protected_memory_features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
    static constexpr OEtype e_physical_device_protected_memory_properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
    static constexpr OEtype e_device_queue_info_2 = VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2;
    static constexpr OEtype e_sampler_ycbcr_conversion_create_info = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
    static constexpr OEtype e_sampler_ycbcr_conversion_info = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
    static constexpr OEtype e_bind_image_plane_memory_info = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
    static constexpr OEtype e_image_plane_memory_requirements_info = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
    static constexpr OEtype e_physical_device_sampler_ycbcr_conversion_features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
    static constexpr OEtype e_sampler_ycbcr_conversion_image_format_properties = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
    static constexpr OEtype e_descriptor_update_template_create_info = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
    static constexpr OEtype e_physical_device_external_image_format_info = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
    static constexpr OEtype e_external_image_format_properties = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
    static constexpr OEtype e_physical_device_external_buffer_info = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
    static constexpr OEtype e_external_buffer_properties = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
    static constexpr OEtype e_physical_device_id_properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
    static constexpr OEtype e_external_memory_buffer_create_info = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
    static constexpr OEtype e_external_memory_image_create_info = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
    static constexpr OEtype e_export_memory_allocate_info = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
    static constexpr OEtype e_physical_device_external_fence_info = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
    static constexpr OEtype e_external_fence_properties = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
    static constexpr OEtype e_export_fence_create_info = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
    static constexpr OEtype e_export_semaphore_create_info = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
    static constexpr OEtype e_physical_device_external_semaphore_info = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
    static constexpr OEtype e_external_semaphore_properties = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
    static constexpr OEtype e_physical_device_maintenance_3_properties = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
    static constexpr OEtype e_descriptor_set_layout_support = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
    static constexpr OEtype e_physical_device_shader_draw_parameters_features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
    static constexpr OEtype e_physical_device_shader_draw_parameter_features = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES;
    static constexpr OEtype e_swapchain_create_info_khr = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
    static constexpr OEtype e_present_info_khr = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
    static constexpr OEtype e_device_group_present_capabilities_khr = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR;
    static constexpr OEtype e_image_swapchain_create_info_khr = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR;
    static constexpr OEtype e_bind_image_memory_swapchain_info_khr = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
    static constexpr OEtype e_acquire_next_image_info_khr = VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR;
    static constexpr OEtype e_device_group_present_info_khr = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR;
    static constexpr OEtype e_device_group_swapchain_create_info_khr = VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR;
    static constexpr OEtype e_display_mode_create_info_khr = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;
    static constexpr OEtype e_display_surface_create_info_khr = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;
    static constexpr OEtype e_display_present_info_khr = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR;
    static constexpr OEtype e_xlib_surface_create_info_khr = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
    static constexpr OEtype e_xcb_surface_create_info_khr = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
    static constexpr OEtype e_wayland_surface_create_info_khr = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
    static constexpr OEtype e_android_surface_create_info_khr = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
    static constexpr OEtype e_win32_surface_create_info_khr = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
    static constexpr OEtype e_debug_report_callback_create_info_ext = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
    static constexpr OEtype e_debug_report_create_info_ext = VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT;
    static constexpr OEtype e_pipeline_rasterization_state_rasterization_order_amd = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD;
    static constexpr OEtype e_debug_marker_object_name_info_ext = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT;
    static constexpr OEtype e_debug_marker_object_tag_info_ext = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT;
    static constexpr OEtype e_debug_marker_marker_info_ext = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT;
    static constexpr OEtype e_dedicated_allocation_image_create_info_nv = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
    static constexpr OEtype e_dedicated_allocation_buffer_create_info_nv = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
    static constexpr OEtype e_dedicated_allocation_memory_allocate_info_nv = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
    static constexpr OEtype e_physical_device_transform_feedback_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
    static constexpr OEtype e_physical_device_transform_feedback_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT;
    static constexpr OEtype e_pipeline_rasterization_state_stream_create_info_ext = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT;
    static constexpr OEtype e_image_view_handle_info_nvx = VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX;
    static constexpr OEtype e_texture_lod_gather_format_properties_amd = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD;
    static constexpr OEtype e_stream_descriptor_surface_create_info_ggp = VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP;
    static constexpr OEtype e_physical_device_corner_sampled_image_features_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
    static constexpr OEtype e_render_pass_multiview_create_info_khr = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR;
    static constexpr OEtype e_physical_device_multiview_features_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR;
    static constexpr OEtype e_physical_device_multiview_properties_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR;
    static constexpr OEtype e_external_memory_image_create_info_nv = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV;
    static constexpr OEtype e_export_memory_allocate_info_nv = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV;
    static constexpr OEtype e_import_memory_win32_handle_info_nv = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV;
    static constexpr OEtype e_export_memory_win32_handle_info_nv = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV;
    static constexpr OEtype e_win32_keyed_mutex_acquire_release_info_nv = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV;
    static constexpr OEtype e_physical_device_features_2_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR;
    static constexpr OEtype e_physical_device_properties_2_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR;
    static constexpr OEtype e_format_properties_2_khr = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR;
    static constexpr OEtype e_image_format_properties_2_khr = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR;
    static constexpr OEtype e_physical_device_image_format_info_2_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR;
    static constexpr OEtype e_queue_family_properties_2_khr = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR;
    static constexpr OEtype e_physical_device_memory_properties_2_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR;
    static constexpr OEtype e_sparse_image_format_properties_2_khr = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR;
    static constexpr OEtype e_physical_device_sparse_image_format_info_2_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR;
    static constexpr OEtype e_memory_allocate_flags_info_khr = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR;
    static constexpr OEtype e_device_group_render_pass_begin_info_khr = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR;
    static constexpr OEtype e_device_group_command_buffer_begin_info_khr = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR;
    static constexpr OEtype e_device_group_submit_info_khr = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR;
    static constexpr OEtype e_device_group_bind_sparse_info_khr = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR;
    static constexpr OEtype e_bind_buffer_memory_device_group_info_khr = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR;
    static constexpr OEtype e_bind_image_memory_device_group_info_khr = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR;
    static constexpr OEtype e_validation_flags_ext = VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT;
    static constexpr OEtype e_vi_surface_create_info_nn = VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN;
    static constexpr OEtype e_physical_device_texture_compression_astc_hdr_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT;
    static constexpr OEtype e_image_view_astc_decode_mode_ext = VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT;
    static constexpr OEtype e_physical_device_astc_decode_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
    static constexpr OEtype e_physical_device_group_properties_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR;
    static constexpr OEtype e_device_group_device_create_info_khr = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR;
    static constexpr OEtype e_physical_device_external_image_format_info_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR;
    static constexpr OEtype e_external_image_format_properties_khr = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR;
    static constexpr OEtype e_physical_device_external_buffer_info_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR;
    static constexpr OEtype e_external_buffer_properties_khr = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR;
    static constexpr OEtype e_physical_device_id_properties_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR;
    static constexpr OEtype e_external_memory_buffer_create_info_khr = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR;
    static constexpr OEtype e_external_memory_image_create_info_khr = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR;
    static constexpr OEtype e_export_memory_allocate_info_khr = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR;
    static constexpr OEtype e_import_memory_win32_handle_info_khr = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
    static constexpr OEtype e_export_memory_win32_handle_info_khr = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
    static constexpr OEtype e_memory_win32_handle_properties_khr = VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR;
    static constexpr OEtype e_memory_get_win32_handle_info_khr = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR;
    static constexpr OEtype e_import_memory_fd_info_khr = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
    static constexpr OEtype e_memory_fd_properties_khr = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR;
    static constexpr OEtype e_memory_get_fd_info_khr = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
    static constexpr OEtype e_win32_keyed_mutex_acquire_release_info_khr = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
    static constexpr OEtype e_physical_device_external_semaphore_info_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR;
    static constexpr OEtype e_external_semaphore_properties_khr = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR;
    static constexpr OEtype e_export_semaphore_create_info_khr = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR;
    static constexpr OEtype e_import_semaphore_win32_handle_info_khr = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
    static constexpr OEtype e_export_semaphore_win32_handle_info_khr = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
    static constexpr OEtype e_d3d12_fence_submit_info_khr = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR;
    static constexpr OEtype e_semaphore_get_win32_handle_info_khr = VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR;
    static constexpr OEtype e_import_semaphore_fd_info_khr = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
    static constexpr OEtype e_semaphore_get_fd_info_khr = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
    static constexpr OEtype e_physical_device_push_descriptor_properties_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR;
    static constexpr OEtype e_command_buffer_inheritance_conditional_rendering_info_ext = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT;
    static constexpr OEtype e_physical_device_conditional_rendering_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
    static constexpr OEtype e_conditional_rendering_begin_info_ext = VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT;
    static constexpr OEtype e_physical_device_shader_float16_int8_features_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR;
    static constexpr OEtype e_physical_device_float16_int8_features_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR;
    static constexpr OEtype e_physical_device_16bit_storage_features_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR;
    static constexpr OEtype e_present_regions_khr = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR;
    static constexpr OEtype e_descriptor_update_template_create_info_khr = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR;
    static constexpr OEtype e_object_table_create_info_nvx = VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX;
    static constexpr OEtype e_indirect_commands_layout_create_info_nvx = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX;
    static constexpr OEtype e_cmd_process_commands_info_nvx = VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX;
    static constexpr OEtype e_cmd_reserve_space_for_commands_info_nvx = VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX;
    static constexpr OEtype e_device_generated_commands_limits_nvx = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX;
    static constexpr OEtype e_device_generated_commands_features_nvx = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX;
    static constexpr OEtype e_pipeline_viewport_w_scaling_state_create_info_nv = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV;
    static constexpr OEtype e_surface_capabilities_2_ext = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT;
    static constexpr OEtype e_surface_capabilities2_ext = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT;
    static constexpr OEtype e_display_power_info_ext = VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT;
    static constexpr OEtype e_device_event_info_ext = VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT;
    static constexpr OEtype e_display_event_info_ext = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT;
    static constexpr OEtype e_swapchain_counter_create_info_ext = VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT;
    static constexpr OEtype e_present_times_info_google = VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE;
    static constexpr OEtype e_physical_device_multiview_per_view_attributes_properties_nvx = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX;
    static constexpr OEtype e_pipeline_viewport_swizzle_state_create_info_nv = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV;
    static constexpr OEtype e_physical_device_discard_rectangle_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
    static constexpr OEtype e_pipeline_discard_rectangle_state_create_info_ext = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
    static constexpr OEtype e_physical_device_conservative_rasterization_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
    static constexpr OEtype e_pipeline_rasterization_conservative_state_create_info_ext = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT;
    static constexpr OEtype e_physical_device_depth_clip_enable_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
    static constexpr OEtype e_pipeline_rasterization_depth_clip_state_create_info_ext = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT;
    static constexpr OEtype e_hdr_metadata_ext = VK_STRUCTURE_TYPE_HDR_METADATA_EXT;
    static constexpr OEtype e_physical_device_imageless_framebuffer_features_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR;
    static constexpr OEtype e_framebuffer_attachments_create_info_khr = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR;
    static constexpr OEtype e_framebuffer_attachment_image_info_khr = VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR;
    static constexpr OEtype e_render_pass_attachment_begin_info_khr = VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR;
    static constexpr OEtype e_attachment_description_2_khr = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR;
    static constexpr OEtype e_attachment_reference_2_khr = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR;
    static constexpr OEtype e_subpass_description_2_khr = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR;
    static constexpr OEtype e_subpass_dependency_2_khr = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR;
    static constexpr OEtype e_render_pass_create_info_2_khr = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR;
    static constexpr OEtype e_subpass_begin_info_khr = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR;
    static constexpr OEtype e_subpass_end_info_khr = VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR;
    static constexpr OEtype e_shared_present_surface_capabilities_khr = VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR;
    static constexpr OEtype e_physical_device_external_fence_info_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR;
    static constexpr OEtype e_external_fence_properties_khr = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR;
    static constexpr OEtype e_export_fence_create_info_khr = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR;
    static constexpr OEtype e_import_fence_win32_handle_info_khr = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;
    static constexpr OEtype e_export_fence_win32_handle_info_khr = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
    static constexpr OEtype e_fence_get_win32_handle_info_khr = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR;
    static constexpr OEtype e_import_fence_fd_info_khr = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
    static constexpr OEtype e_fence_get_fd_info_khr = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR;
    static constexpr OEtype e_physical_device_point_clipping_properties_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR;
    static constexpr OEtype e_render_pass_input_attachment_aspect_create_info_khr = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR;
    static constexpr OEtype e_image_view_usage_create_info_khr = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR;
    static constexpr OEtype e_pipeline_tessellation_domain_origin_state_create_info_khr = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR;
    static constexpr OEtype e_physical_device_surface_info_2_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR;
    static constexpr OEtype e_surface_capabilities_2_khr = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR;
    static constexpr OEtype e_surface_format_2_khr = VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR;
    static constexpr OEtype e_physical_device_variable_pointer_features_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR;
    static constexpr OEtype e_physical_device_variable_pointers_features_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR;
    static constexpr OEtype e_display_properties_2_khr = VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR;
    static constexpr OEtype e_display_plane_properties_2_khr = VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR;
    static constexpr OEtype e_display_mode_properties_2_khr = VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR;
    static constexpr OEtype e_display_plane_info_2_khr = VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR;
    static constexpr OEtype e_display_plane_capabilities_2_khr = VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR;
    static constexpr OEtype e_ios_surface_create_info_mvk = VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK;
    static constexpr OEtype e_macos_surface_create_info_mvk = VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK;
    static constexpr OEtype e_memory_dedicated_requirements_khr = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR;
    static constexpr OEtype e_memory_dedicated_allocate_info_khr = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR;
    static constexpr OEtype e_debug_utils_object_name_info_ext = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
    static constexpr OEtype e_debug_utils_object_tag_info_ext = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT;
    static constexpr OEtype e_debug_utils_label_ext = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT;
    static constexpr OEtype e_debug_utils_messenger_callback_data_ext = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT;
    static constexpr OEtype e_debug_utils_messenger_create_info_ext = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
    static constexpr OEtype e_android_hardware_buffer_usage_android = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID;
    static constexpr OEtype e_android_hardware_buffer_properties_android = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID;
    static constexpr OEtype e_android_hardware_buffer_format_properties_android = VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID;
    static constexpr OEtype e_import_android_hardware_buffer_info_android = VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
    static constexpr OEtype e_memory_get_android_hardware_buffer_info_android = VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID;
    static constexpr OEtype e_external_format_android = VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID;
    static constexpr OEtype e_physical_device_sampler_filter_minmax_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT;
    static constexpr OEtype e_sampler_reduction_mode_create_info_ext = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT;
    static constexpr OEtype e_physical_device_inline_uniform_block_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT;
    static constexpr OEtype e_physical_device_inline_uniform_block_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT;
    static constexpr OEtype e_write_descriptor_set_inline_uniform_block_ext = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT;
    static constexpr OEtype e_descriptor_pool_inline_uniform_block_create_info_ext = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT;
    static constexpr OEtype e_sample_locations_info_ext = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT;
    static constexpr OEtype e_render_pass_sample_locations_begin_info_ext = VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT;
    static constexpr OEtype e_pipeline_sample_locations_state_create_info_ext = VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT;
    static constexpr OEtype e_physical_device_sample_locations_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
    static constexpr OEtype e_multisample_properties_ext = VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT;
    static constexpr OEtype e_buffer_memory_requirements_info_2_khr = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR;
    static constexpr OEtype e_image_memory_requirements_info_2_khr = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR;
    static constexpr OEtype e_image_sparse_memory_requirements_info_2_khr = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR;
    static constexpr OEtype e_memory_requirements_2_khr = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR;
    static constexpr OEtype e_sparse_image_memory_requirements_2_khr = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR;
    static constexpr OEtype e_image_format_list_create_info_khr = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR;
    static constexpr OEtype e_physical_device_blend_operation_advanced_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
    static constexpr OEtype e_physical_device_blend_operation_advanced_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
    static constexpr OEtype e_pipeline_color_blend_advanced_state_create_info_ext = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT;
    static constexpr OEtype e_pipeline_coverage_to_color_state_create_info_nv = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV;
    static constexpr OEtype e_pipeline_coverage_modulation_state_create_info_nv = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV;
    static constexpr OEtype e_physical_device_shader_sm_builtins_features_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
    static constexpr OEtype e_physical_device_shader_sm_builtins_properties_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV;
    static constexpr OEtype e_sampler_ycbcr_conversion_create_info_khr = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR;
    static constexpr OEtype e_sampler_ycbcr_conversion_info_khr = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR;
    static constexpr OEtype e_bind_image_plane_memory_info_khr = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR;
    static constexpr OEtype e_image_plane_memory_requirements_info_khr = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR;
    static constexpr OEtype e_physical_device_sampler_ycbcr_conversion_features_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR;
    static constexpr OEtype e_sampler_ycbcr_conversion_image_format_properties_khr = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR;
    static constexpr OEtype e_bind_buffer_memory_info_khr = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR;
    static constexpr OEtype e_bind_image_memory_info_khr = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR;
    static constexpr OEtype e_drm_format_modifier_properties_list_ext = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT;
    static constexpr OEtype e_drm_format_modifier_properties_ext = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT;
    static constexpr OEtype e_physical_device_image_drm_format_modifier_info_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT;
    static constexpr OEtype e_image_drm_format_modifier_list_create_info_ext = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT;
    static constexpr OEtype e_image_drm_format_modifier_explicit_create_info_ext = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT;
    static constexpr OEtype e_image_drm_format_modifier_properties_ext = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT;
    static constexpr OEtype e_validation_cache_create_info_ext = VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT;
    static constexpr OEtype e_shader_module_validation_cache_create_info_ext = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
    static constexpr OEtype e_descriptor_set_layout_binding_flags_create_info_ext = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT;
    static constexpr OEtype e_physical_device_descriptor_indexing_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT;
    static constexpr OEtype e_physical_device_descriptor_indexing_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT;
    static constexpr OEtype e_descriptor_set_variable_descriptor_count_allocate_info_ext = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT;
    static constexpr OEtype e_descriptor_set_variable_descriptor_count_layout_support_ext = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT;
    static constexpr OEtype e_pipeline_viewport_shading_rate_image_state_create_info_nv = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV;
    static constexpr OEtype e_physical_device_shading_rate_image_features_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
    static constexpr OEtype e_physical_device_shading_rate_image_properties_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV;
    static constexpr OEtype e_pipeline_viewport_coarse_sample_order_state_create_info_nv = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV;
    static constexpr OEtype e_ray_tracing_pipeline_create_info_nv = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV;
    static constexpr OEtype e_acceleration_structure_create_info_nv = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV;
    static constexpr OEtype e_geometry_nv = VK_STRUCTURE_TYPE_GEOMETRY_NV;
    static constexpr OEtype e_geometry_triangles_nv = VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV;
    static constexpr OEtype e_geometry_aabb_nv = VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV;
    static constexpr OEtype e_bind_acceleration_structure_memory_info_nv = VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV;
    static constexpr OEtype e_write_descriptor_set_acceleration_structure_nv = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV;
    static constexpr OEtype e_acceleration_structure_memory_requirements_info_nv = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV;
    static constexpr OEtype e_physical_device_ray_tracing_properties_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV;
    static constexpr OEtype e_ray_tracing_shader_group_create_info_nv = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV;
    static constexpr OEtype e_acceleration_structure_info_nv = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV;
    static constexpr OEtype e_physical_device_representative_fragment_test_features_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
    static constexpr OEtype e_pipeline_representative_fragment_test_state_create_info_nv = VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV;
    static constexpr OEtype e_physical_device_maintenance_3_properties_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR;
    static constexpr OEtype e_descriptor_set_layout_support_khr = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR;
    static constexpr OEtype e_physical_device_image_view_image_format_info_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT;
    static constexpr OEtype e_filter_cubic_image_view_image_format_properties_ext = VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT;
    static constexpr OEtype e_device_queue_global_priority_create_info_ext = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT;
    static constexpr OEtype e_physical_device_8bit_storage_features_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR;
    static constexpr OEtype e_import_memory_host_pointer_info_ext = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
    static constexpr OEtype e_memory_host_pointer_properties_ext = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT;
    static constexpr OEtype e_physical_device_external_memory_host_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT;
    static constexpr OEtype e_physical_device_shader_atomic_int64_features_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR;
    static constexpr OEtype e_pipeline_compiler_control_create_info_amd = VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD;
    static constexpr OEtype e_calibrated_timestamp_info_ext = VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT;
    static constexpr OEtype e_physical_device_shader_core_properties_amd = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;
    static constexpr OEtype e_device_memory_overallocation_create_info_amd = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD;
    static constexpr OEtype e_physical_device_vertex_attribute_divisor_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
    static constexpr OEtype e_pipeline_vertex_input_divisor_state_create_info_ext = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT;
    static constexpr OEtype e_physical_device_vertex_attribute_divisor_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT;
    static constexpr OEtype e_present_frame_token_ggp = VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP;
    static constexpr OEtype e_pipeline_creation_feedback_create_info_ext = VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT;
    static constexpr OEtype e_physical_device_driver_properties_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR;
    static constexpr OEtype e_physical_device_float_controls_properties_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR;
    static constexpr OEtype e_physical_device_depth_stencil_resolve_properties_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR;
    static constexpr OEtype e_subpass_description_depth_stencil_resolve_khr = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR;
    static constexpr OEtype e_physical_device_compute_shader_derivatives_features_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV;
    static constexpr OEtype e_physical_device_mesh_shader_features_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
    static constexpr OEtype e_physical_device_mesh_shader_properties_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV;
    static constexpr OEtype e_physical_device_fragment_shader_barycentric_features_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV;
    static constexpr OEtype e_physical_device_shader_image_footprint_features_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
    static constexpr OEtype e_pipeline_viewport_exclusive_scissor_state_create_info_nv = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV;
    static constexpr OEtype e_physical_device_exclusive_scissor_features_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
    static constexpr OEtype e_checkpoint_data_nv = VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV;
    static constexpr OEtype e_queue_family_checkpoint_properties_nv = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV;
    static constexpr OEtype e_physical_device_shader_integer_functions_2_features_intel = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
    static constexpr OEtype e_query_pool_create_info_intel = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL;
    static constexpr OEtype e_initialize_performance_api_info_intel = VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL;
    static constexpr OEtype e_performance_marker_info_intel = VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL;
    static constexpr OEtype e_performance_stream_marker_info_intel = VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL;
    static constexpr OEtype e_performance_override_info_intel = VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL;
    static constexpr OEtype e_performance_configuration_acquire_info_intel = VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL;
    static constexpr OEtype e_physical_device_vulkan_memory_model_features_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR;
    static constexpr OEtype e_physical_device_pci_bus_info_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT;
    static constexpr OEtype e_display_native_hdr_surface_capabilities_amd = VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD;
    static constexpr OEtype e_swapchain_display_native_hdr_create_info_amd = VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD;
    static constexpr OEtype e_imagepipe_surface_create_info_fuchsia = VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA;
    static constexpr OEtype e_metal_surface_create_info_ext = VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT;
    static constexpr OEtype e_physical_device_fragment_density_map_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
    static constexpr OEtype e_physical_device_fragment_density_map_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT;
    static constexpr OEtype e_render_pass_fragment_density_map_create_info_ext = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT;
    static constexpr OEtype e_physical_device_scalar_block_layout_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT;
    static constexpr OEtype e_physical_device_subgroup_size_control_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT;
    static constexpr OEtype e_pipeline_shader_stage_required_subgroup_size_create_info_ext = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT;
    static constexpr OEtype e_physical_device_subgroup_size_control_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT;
    static constexpr OEtype e_physical_device_shader_core_properties_2_amd = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD;
    static constexpr OEtype e_physical_device_coherent_memory_features_amd = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
    static constexpr OEtype e_physical_device_memory_budget_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT;
    static constexpr OEtype e_physical_device_memory_priority_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
    static constexpr OEtype e_memory_priority_allocate_info_ext = VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT;
    static constexpr OEtype e_surface_protected_capabilities_khr = VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR;
    static constexpr OEtype e_physical_device_dedicated_allocation_image_aliasing_features_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
    static constexpr OEtype e_physical_device_buffer_device_address_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
    static constexpr OEtype e_physical_device_buffer_address_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT;
    static constexpr OEtype e_buffer_device_address_info_ext = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT;
    static constexpr OEtype e_buffer_device_address_create_info_ext = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT;
    static constexpr OEtype e_image_stencil_usage_create_info_ext = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT;
    static constexpr OEtype e_validation_features_ext = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT;
    static constexpr OEtype e_physical_device_cooperative_matrix_features_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
    static constexpr OEtype e_cooperative_matrix_properties_nv = VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV;
    static constexpr OEtype e_physical_device_cooperative_matrix_properties_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV;
    static constexpr OEtype e_physical_device_coverage_reduction_mode_features_nv = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
    static constexpr OEtype e_pipeline_coverage_reduction_state_create_info_nv = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV;
    static constexpr OEtype e_framebuffer_mixed_samples_combination_nv = VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV;
    static constexpr OEtype e_physical_device_fragment_shader_interlock_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
    static constexpr OEtype e_physical_device_ycbcr_image_arrays_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
    static constexpr OEtype e_physical_device_uniform_buffer_standard_layout_features_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR;
    static constexpr OEtype e_surface_full_screen_exclusive_info_ext = VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT;
    static constexpr OEtype e_surface_capabilities_full_screen_exclusive_ext = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT;
    static constexpr OEtype e_surface_full_screen_exclusive_win32_info_ext = VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT;
    static constexpr OEtype e_headless_surface_create_info_ext = VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT;
    static constexpr OEtype e_physical_device_line_rasterization_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT;
    static constexpr OEtype e_pipeline_rasterization_line_state_create_info_ext = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT;
    static constexpr OEtype e_physical_device_line_rasterization_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT;
    static constexpr OEtype e_physical_device_host_query_reset_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT;
    static constexpr OEtype e_physical_device_index_type_uint8_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT;
    static constexpr OEtype e_physical_device_pipeline_executable_properties_features_khr = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
    static constexpr OEtype e_pipeline_info_khr = VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR;
    static constexpr OEtype e_pipeline_executable_properties_khr = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR;
    static constexpr OEtype e_pipeline_executable_info_khr = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR;
    static constexpr OEtype e_pipeline_executable_statistic_khr = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR;
    static constexpr OEtype e_pipeline_executable_internal_representation_khr = VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR;
    static constexpr OEtype e_physical_device_shader_demote_to_helper_invocation_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT;
    static constexpr OEtype e_physical_device_texel_buffer_alignment_features_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
    static constexpr OEtype e_physical_device_texel_buffer_alignment_properties_ext = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT;
};
template<> struct detail::names_map<VkStructureType> { using T = E_StructureType; };
struct F_MemoryHeap : public E<VkMemoryHeapFlagBits> {
    using E::E;
    using New_type = F_MemoryHeap;
    static constexpr OEtype b_device_local = VK_MEMORY_HEAP_DEVICE_LOCAL_BIT;
    static constexpr OEtype b_multi_instance = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT;
    static constexpr OEtype b_multi_instance_khr = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR;
    New_type& on_device_local(){ flag |= VK_MEMORY_HEAP_DEVICE_LOCAL_BIT; return *this; } 
    New_type& off_device_local(){ flag |= ~(VK_MEMORY_HEAP_DEVICE_LOCAL_BIT); return *this; }
    New_type& on_multi_instance(){ flag |= VK_MEMORY_HEAP_MULTI_INSTANCE_BIT; return *this; } 
    New_type& off_multi_instance(){ flag |= ~(VK_MEMORY_HEAP_MULTI_INSTANCE_BIT); return *this; }
    New_type& on_multi_instance_khr(){ flag |= VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR; return *this; } 
    New_type& off_multi_instance_khr(){ flag |= ~(VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_MEMORY_HEAP_DEVICE_LOCAL_BIT| VK_MEMORY_HEAP_MULTI_INSTANCE_BIT| VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR;
};
inL constexpr F_MemoryHeap operator|(F_MemoryHeap::Otype const b1, F_MemoryHeap const b2) { return b1 | b2.flag; }
inL constexpr F_MemoryHeap operator|(F_MemoryHeap const b1, F_MemoryHeap::Otype const b2) { return b1.flag | b2; }
inL constexpr F_MemoryHeap operator&(F_MemoryHeap::Otype const b1, F_MemoryHeap const b2) { return b1 & b2.flag; }
inL constexpr F_MemoryHeap operator&(F_MemoryHeap const b1, F_MemoryHeap::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkMemoryHeapFlagBits> { using T = F_MemoryHeap; };
struct F_SwapchainCreateKHR : public E<VkSwapchainCreateFlagBitsKHR> {
    using E::E;
    using New_type = F_SwapchainCreateKHR;
    static constexpr OEtype b_split_instance_bind_regions_khr = VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR;
    static constexpr OEtype b_protected_khr = VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR;
    static constexpr OEtype b_mutable_format_khr = VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR;
    New_type& on_split_instance_bind_regions_khr(){ flag |= VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR; return *this; } 
    New_type& off_split_instance_bind_regions_khr(){ flag |= ~(VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR); return *this; }
    New_type& on_protected_khr(){ flag |= VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR; return *this; } 
    New_type& off_protected_khr(){ flag |= ~(VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR); return *this; }
    New_type& on_mutable_format_khr(){ flag |= VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR; return *this; } 
    New_type& off_mutable_format_khr(){ flag |= ~(VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR| VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR| VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR;
};
inL constexpr F_SwapchainCreateKHR operator|(F_SwapchainCreateKHR::Otype const b1, F_SwapchainCreateKHR const b2) { return b1 | b2.flag; }
inL constexpr F_SwapchainCreateKHR operator|(F_SwapchainCreateKHR const b1, F_SwapchainCreateKHR::Otype const b2) { return b1.flag | b2; }
inL constexpr F_SwapchainCreateKHR operator&(F_SwapchainCreateKHR::Otype const b1, F_SwapchainCreateKHR const b2) { return b1 & b2.flag; }
inL constexpr F_SwapchainCreateKHR operator&(F_SwapchainCreateKHR const b1, F_SwapchainCreateKHR::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkSwapchainCreateFlagBitsKHR> { using T = F_SwapchainCreateKHR; };
struct F_ExternalSemaphoreHandleType : public E<VkExternalSemaphoreHandleTypeFlagBits> {
    using E::E;
    using New_type = F_ExternalSemaphoreHandleType;
    static constexpr OEtype b_opaque_fd = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
    static constexpr OEtype b_opaque_win32 = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
    static constexpr OEtype b_opaque_win32_kmt = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
    static constexpr OEtype b_d3d12_fence = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
    static constexpr OEtype b_sync_fd = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
    static constexpr OEtype b_opaque_fd_khr = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    static constexpr OEtype b_opaque_win32_khr = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    static constexpr OEtype b_opaque_win32_kmt_khr = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    static constexpr OEtype b_d3d12_fence_khr = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR;
    static constexpr OEtype b_sync_fd_khr = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
    New_type& on_opaque_fd(){ flag |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT; return *this; } 
    New_type& off_opaque_fd(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT); return *this; }
    New_type& on_opaque_win32(){ flag |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT; return *this; } 
    New_type& off_opaque_win32(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT); return *this; }
    New_type& on_opaque_win32_kmt(){ flag |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT; return *this; } 
    New_type& off_opaque_win32_kmt(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT); return *this; }
    New_type& on_d3d12_fence(){ flag |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT; return *this; } 
    New_type& off_d3d12_fence(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT); return *this; }
    New_type& on_sync_fd(){ flag |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT; return *this; } 
    New_type& off_sync_fd(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT); return *this; }
    New_type& on_opaque_fd_khr(){ flag |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR; return *this; } 
    New_type& off_opaque_fd_khr(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR); return *this; }
    New_type& on_opaque_win32_khr(){ flag |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR; return *this; } 
    New_type& off_opaque_win32_khr(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR); return *this; }
    New_type& on_opaque_win32_kmt_khr(){ flag |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR; return *this; } 
    New_type& off_opaque_win32_kmt_khr(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR); return *this; }
    New_type& on_d3d12_fence_khr(){ flag |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR; return *this; } 
    New_type& off_d3d12_fence_khr(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR); return *this; }
    New_type& on_sync_fd_khr(){ flag |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR; return *this; } 
    New_type& off_sync_fd_khr(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT| VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT| VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT| VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT| VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT| VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR| VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR| VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR| VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR| VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
};
inL constexpr F_ExternalSemaphoreHandleType operator|(F_ExternalSemaphoreHandleType::Otype const b1, F_ExternalSemaphoreHandleType const b2) { return b1 | b2.flag; }
inL constexpr F_ExternalSemaphoreHandleType operator|(F_ExternalSemaphoreHandleType const b1, F_ExternalSemaphoreHandleType::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ExternalSemaphoreHandleType operator&(F_ExternalSemaphoreHandleType::Otype const b1, F_ExternalSemaphoreHandleType const b2) { return b1 & b2.flag; }
inL constexpr F_ExternalSemaphoreHandleType operator&(F_ExternalSemaphoreHandleType const b1, F_ExternalSemaphoreHandleType::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkExternalSemaphoreHandleTypeFlagBits> { using T = F_ExternalSemaphoreHandleType; };
struct F_ImageViewCreate : public E<VkImageViewCreateFlagBits> {
    using E::E;
    using New_type = F_ImageViewCreate;
    static constexpr OEtype b_fragment_density_map_dynamic_ext = VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT;
    New_type& on_fragment_density_map_dynamic_ext(){ flag |= VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT; return *this; } 
    New_type& off_fragment_density_map_dynamic_ext(){ flag |= ~(VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT;
};
inL constexpr F_ImageViewCreate operator|(F_ImageViewCreate::Otype const b1, F_ImageViewCreate const b2) { return b1 | b2.flag; }
inL constexpr F_ImageViewCreate operator|(F_ImageViewCreate const b1, F_ImageViewCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ImageViewCreate operator&(F_ImageViewCreate::Otype const b1, F_ImageViewCreate const b2) { return b1 & b2.flag; }
inL constexpr F_ImageViewCreate operator&(F_ImageViewCreate const b1, F_ImageViewCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkImageViewCreateFlagBits> { using T = F_ImageViewCreate; };
struct F_DeviceQueueCreate : public E<VkDeviceQueueCreateFlagBits> {
    using E::E;
    using New_type = F_DeviceQueueCreate;
    static constexpr OEtype b_protected = VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT;
    New_type& on_protected(){ flag |= VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT; return *this; } 
    New_type& off_protected(){ flag |= ~(VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT;
};
inL constexpr F_DeviceQueueCreate operator|(F_DeviceQueueCreate::Otype const b1, F_DeviceQueueCreate const b2) { return b1 | b2.flag; }
inL constexpr F_DeviceQueueCreate operator|(F_DeviceQueueCreate const b1, F_DeviceQueueCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_DeviceQueueCreate operator&(F_DeviceQueueCreate::Otype const b1, F_DeviceQueueCreate const b2) { return b1 & b2.flag; }
inL constexpr F_DeviceQueueCreate operator&(F_DeviceQueueCreate const b1, F_DeviceQueueCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkDeviceQueueCreateFlagBits> { using T = F_DeviceQueueCreate; };
struct F_FenceCreate : public E<VkFenceCreateFlagBits> {
    using E::E;
    using New_type = F_FenceCreate;
    static constexpr OEtype b_signaled = VK_FENCE_CREATE_SIGNALED_BIT;
    New_type& on_signaled(){ flag |= VK_FENCE_CREATE_SIGNALED_BIT; return *this; } 
    New_type& off_signaled(){ flag |= ~(VK_FENCE_CREATE_SIGNALED_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_FENCE_CREATE_SIGNALED_BIT;
};
inL constexpr F_FenceCreate operator|(F_FenceCreate::Otype const b1, F_FenceCreate const b2) { return b1 | b2.flag; }
inL constexpr F_FenceCreate operator|(F_FenceCreate const b1, F_FenceCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_FenceCreate operator&(F_FenceCreate::Otype const b1, F_FenceCreate const b2) { return b1 & b2.flag; }
inL constexpr F_FenceCreate operator&(F_FenceCreate const b1, F_FenceCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkFenceCreateFlagBits> { using T = F_FenceCreate; };
struct F_CommandPoolReset : public E<VkCommandPoolResetFlagBits> {
    using E::E;
    using New_type = F_CommandPoolReset;
    static constexpr OEtype b_release_resources = VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT;
    New_type& on_release_resources(){ flag |= VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT; return *this; } 
    New_type& off_release_resources(){ flag |= ~(VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT;
};
inL constexpr F_CommandPoolReset operator|(F_CommandPoolReset::Otype const b1, F_CommandPoolReset const b2) { return b1 | b2.flag; }
inL constexpr F_CommandPoolReset operator|(F_CommandPoolReset const b1, F_CommandPoolReset::Otype const b2) { return b1.flag | b2; }
inL constexpr F_CommandPoolReset operator&(F_CommandPoolReset::Otype const b1, F_CommandPoolReset const b2) { return b1 & b2.flag; }
inL constexpr F_CommandPoolReset operator&(F_CommandPoolReset const b1, F_CommandPoolReset::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkCommandPoolResetFlagBits> { using T = F_CommandPoolReset; };
struct F_ExternalSemaphoreFeature : public E<VkExternalSemaphoreFeatureFlagBits> {
    using E::E;
    using New_type = F_ExternalSemaphoreFeature;
    static constexpr OEtype b_exportable = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT;
    static constexpr OEtype b_importable = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT;
    static constexpr OEtype b_exportable_khr = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR;
    static constexpr OEtype b_importable_khr = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR;
    New_type& on_exportable(){ flag |= VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT; return *this; } 
    New_type& off_exportable(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT); return *this; }
    New_type& on_importable(){ flag |= VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT; return *this; } 
    New_type& off_importable(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT); return *this; }
    New_type& on_exportable_khr(){ flag |= VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR; return *this; } 
    New_type& off_exportable_khr(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR); return *this; }
    New_type& on_importable_khr(){ flag |= VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR; return *this; } 
    New_type& off_importable_khr(){ flag |= ~(VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT| VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT| VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR| VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR;
};
inL constexpr F_ExternalSemaphoreFeature operator|(F_ExternalSemaphoreFeature::Otype const b1, F_ExternalSemaphoreFeature const b2) { return b1 | b2.flag; }
inL constexpr F_ExternalSemaphoreFeature operator|(F_ExternalSemaphoreFeature const b1, F_ExternalSemaphoreFeature::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ExternalSemaphoreFeature operator&(F_ExternalSemaphoreFeature::Otype const b1, F_ExternalSemaphoreFeature const b2) { return b1 & b2.flag; }
inL constexpr F_ExternalSemaphoreFeature operator&(F_ExternalSemaphoreFeature const b1, F_ExternalSemaphoreFeature::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkExternalSemaphoreFeatureFlagBits> { using T = F_ExternalSemaphoreFeature; };
struct F_QueryControl : public E<VkQueryControlFlagBits> {
    using E::E;
    using New_type = F_QueryControl;
    static constexpr OEtype b_precise = VK_QUERY_CONTROL_PRECISE_BIT;
    New_type& on_precise(){ flag |= VK_QUERY_CONTROL_PRECISE_BIT; return *this; } 
    New_type& off_precise(){ flag |= ~(VK_QUERY_CONTROL_PRECISE_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_QUERY_CONTROL_PRECISE_BIT;
};
inL constexpr F_QueryControl operator|(F_QueryControl::Otype const b1, F_QueryControl const b2) { return b1 | b2.flag; }
inL constexpr F_QueryControl operator|(F_QueryControl const b1, F_QueryControl::Otype const b2) { return b1.flag | b2; }
inL constexpr F_QueryControl operator&(F_QueryControl::Otype const b1, F_QueryControl const b2) { return b1 & b2.flag; }
inL constexpr F_QueryControl operator&(F_QueryControl const b1, F_QueryControl::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkQueryControlFlagBits> { using T = F_QueryControl; };
struct F_CommandPoolCreate : public E<VkCommandPoolCreateFlagBits> {
    using E::E;
    using New_type = F_CommandPoolCreate;
    static constexpr OEtype b_transient = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT;
    static constexpr OEtype b_reset_command_buffer = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
    static constexpr OEtype b_protected = VK_COMMAND_POOL_CREATE_PROTECTED_BIT;
    New_type& on_transient(){ flag |= VK_COMMAND_POOL_CREATE_TRANSIENT_BIT; return *this; } 
    New_type& off_transient(){ flag |= ~(VK_COMMAND_POOL_CREATE_TRANSIENT_BIT); return *this; }
    New_type& on_reset_command_buffer(){ flag |= VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT; return *this; } 
    New_type& off_reset_command_buffer(){ flag |= ~(VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT); return *this; }
    New_type& on_protected(){ flag |= VK_COMMAND_POOL_CREATE_PROTECTED_BIT; return *this; } 
    New_type& off_protected(){ flag |= ~(VK_COMMAND_POOL_CREATE_PROTECTED_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_COMMAND_POOL_CREATE_TRANSIENT_BIT| VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT| VK_COMMAND_POOL_CREATE_PROTECTED_BIT;
};
inL constexpr F_CommandPoolCreate operator|(F_CommandPoolCreate::Otype const b1, F_CommandPoolCreate const b2) { return b1 | b2.flag; }
inL constexpr F_CommandPoolCreate operator|(F_CommandPoolCreate const b1, F_CommandPoolCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_CommandPoolCreate operator&(F_CommandPoolCreate::Otype const b1, F_CommandPoolCreate const b2) { return b1 & b2.flag; }
inL constexpr F_CommandPoolCreate operator&(F_CommandPoolCreate const b1, F_CommandPoolCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkCommandPoolCreateFlagBits> { using T = F_CommandPoolCreate; };
struct F_DebugReportEXT : public E<VkDebugReportFlagBitsEXT> {
    using E::E;
    using New_type = F_DebugReportEXT;
    static constexpr OEtype b_information_ext = VK_DEBUG_REPORT_INFORMATION_BIT_EXT;
    static constexpr OEtype b_warning_ext = VK_DEBUG_REPORT_WARNING_BIT_EXT;
    static constexpr OEtype b_performance_warning_ext = VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT;
    static constexpr OEtype b_error_ext = VK_DEBUG_REPORT_ERROR_BIT_EXT;
    static constexpr OEtype b_debug_ext = VK_DEBUG_REPORT_DEBUG_BIT_EXT;
    New_type& on_information_ext(){ flag |= VK_DEBUG_REPORT_INFORMATION_BIT_EXT; return *this; } 
    New_type& off_information_ext(){ flag |= ~(VK_DEBUG_REPORT_INFORMATION_BIT_EXT); return *this; }
    New_type& on_warning_ext(){ flag |= VK_DEBUG_REPORT_WARNING_BIT_EXT; return *this; } 
    New_type& off_warning_ext(){ flag |= ~(VK_DEBUG_REPORT_WARNING_BIT_EXT); return *this; }
    New_type& on_performance_warning_ext(){ flag |= VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT; return *this; } 
    New_type& off_performance_warning_ext(){ flag |= ~(VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT); return *this; }
    New_type& on_error_ext(){ flag |= VK_DEBUG_REPORT_ERROR_BIT_EXT; return *this; } 
    New_type& off_error_ext(){ flag |= ~(VK_DEBUG_REPORT_ERROR_BIT_EXT); return *this; }
    New_type& on_debug_ext(){ flag |= VK_DEBUG_REPORT_DEBUG_BIT_EXT; return *this; } 
    New_type& off_debug_ext(){ flag |= ~(VK_DEBUG_REPORT_DEBUG_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_DEBUG_REPORT_INFORMATION_BIT_EXT| VK_DEBUG_REPORT_WARNING_BIT_EXT| VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT| VK_DEBUG_REPORT_ERROR_BIT_EXT| VK_DEBUG_REPORT_DEBUG_BIT_EXT;
};
inL constexpr F_DebugReportEXT operator|(F_DebugReportEXT::Otype const b1, F_DebugReportEXT const b2) { return b1 | b2.flag; }
inL constexpr F_DebugReportEXT operator|(F_DebugReportEXT const b1, F_DebugReportEXT::Otype const b2) { return b1.flag | b2; }
inL constexpr F_DebugReportEXT operator&(F_DebugReportEXT::Otype const b1, F_DebugReportEXT const b2) { return b1 & b2.flag; }
inL constexpr F_DebugReportEXT operator&(F_DebugReportEXT const b1, F_DebugReportEXT::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkDebugReportFlagBitsEXT> { using T = F_DebugReportEXT; };
struct F_DeviceGroupPresentModeKHR : public E<VkDeviceGroupPresentModeFlagBitsKHR> {
    using E::E;
    using New_type = F_DeviceGroupPresentModeKHR;
    static constexpr OEtype b_local_khr = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR;
    static constexpr OEtype b_remote_khr = VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR;
    static constexpr OEtype b_sum_khr = VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR;
    static constexpr OEtype b_local_multi_device_khr = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR;
    New_type& on_local_khr(){ flag |= VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR; return *this; } 
    New_type& off_local_khr(){ flag |= ~(VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR); return *this; }
    New_type& on_remote_khr(){ flag |= VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR; return *this; } 
    New_type& off_remote_khr(){ flag |= ~(VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR); return *this; }
    New_type& on_sum_khr(){ flag |= VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR; return *this; } 
    New_type& off_sum_khr(){ flag |= ~(VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR); return *this; }
    New_type& on_local_multi_device_khr(){ flag |= VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR; return *this; } 
    New_type& off_local_multi_device_khr(){ flag |= ~(VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR| VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR| VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR| VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR;
};
inL constexpr F_DeviceGroupPresentModeKHR operator|(F_DeviceGroupPresentModeKHR::Otype const b1, F_DeviceGroupPresentModeKHR const b2) { return b1 | b2.flag; }
inL constexpr F_DeviceGroupPresentModeKHR operator|(F_DeviceGroupPresentModeKHR const b1, F_DeviceGroupPresentModeKHR::Otype const b2) { return b1.flag | b2; }
inL constexpr F_DeviceGroupPresentModeKHR operator&(F_DeviceGroupPresentModeKHR::Otype const b1, F_DeviceGroupPresentModeKHR const b2) { return b1 & b2.flag; }
inL constexpr F_DeviceGroupPresentModeKHR operator&(F_DeviceGroupPresentModeKHR const b1, F_DeviceGroupPresentModeKHR::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkDeviceGroupPresentModeFlagBitsKHR> { using T = F_DeviceGroupPresentModeKHR; };
struct F_DisplayPlaneAlphaKHR : public E<VkDisplayPlaneAlphaFlagBitsKHR> {
    using E::E;
    using New_type = F_DisplayPlaneAlphaKHR;
    static constexpr OEtype b_opaque_khr = VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR;
    static constexpr OEtype b_global_khr = VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR;
    static constexpr OEtype b_per_pixel_khr = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR;
    static constexpr OEtype b_per_pixel_premultiplied_khr = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR;
    New_type& on_opaque_khr(){ flag |= VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR; return *this; } 
    New_type& off_opaque_khr(){ flag |= ~(VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR); return *this; }
    New_type& on_global_khr(){ flag |= VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR; return *this; } 
    New_type& off_global_khr(){ flag |= ~(VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR); return *this; }
    New_type& on_per_pixel_khr(){ flag |= VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR; return *this; } 
    New_type& off_per_pixel_khr(){ flag |= ~(VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR); return *this; }
    New_type& on_per_pixel_premultiplied_khr(){ flag |= VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR; return *this; } 
    New_type& off_per_pixel_premultiplied_khr(){ flag |= ~(VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR| VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR| VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR| VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR;
};
inL constexpr F_DisplayPlaneAlphaKHR operator|(F_DisplayPlaneAlphaKHR::Otype const b1, F_DisplayPlaneAlphaKHR const b2) { return b1 | b2.flag; }
inL constexpr F_DisplayPlaneAlphaKHR operator|(F_DisplayPlaneAlphaKHR const b1, F_DisplayPlaneAlphaKHR::Otype const b2) { return b1.flag | b2; }
inL constexpr F_DisplayPlaneAlphaKHR operator&(F_DisplayPlaneAlphaKHR::Otype const b1, F_DisplayPlaneAlphaKHR const b2) { return b1 & b2.flag; }
inL constexpr F_DisplayPlaneAlphaKHR operator&(F_DisplayPlaneAlphaKHR const b1, F_DisplayPlaneAlphaKHR::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkDisplayPlaneAlphaFlagBitsKHR> { using T = F_DisplayPlaneAlphaKHR; };
struct F_ResolveModeKHR : public E<VkResolveModeFlagBitsKHR> {
    using E::E;
    using New_type = F_ResolveModeKHR;
    static constexpr OEtype b_none_khr = VK_RESOLVE_MODE_NONE_KHR;
    static constexpr OEtype b_sample_zero_khr = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR;
    static constexpr OEtype b_average_khr = VK_RESOLVE_MODE_AVERAGE_BIT_KHR;
    static constexpr OEtype b_min_khr = VK_RESOLVE_MODE_MIN_BIT_KHR;
    static constexpr OEtype b_max_khr = VK_RESOLVE_MODE_MAX_BIT_KHR;
    New_type& on_none_khr(){ flag |= VK_RESOLVE_MODE_NONE_KHR; return *this; } 
    New_type& off_none_khr(){ flag |= ~(VK_RESOLVE_MODE_NONE_KHR); return *this; }
    New_type& on_sample_zero_khr(){ flag |= VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR; return *this; } 
    New_type& off_sample_zero_khr(){ flag |= ~(VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR); return *this; }
    New_type& on_average_khr(){ flag |= VK_RESOLVE_MODE_AVERAGE_BIT_KHR; return *this; } 
    New_type& off_average_khr(){ flag |= ~(VK_RESOLVE_MODE_AVERAGE_BIT_KHR); return *this; }
    New_type& on_min_khr(){ flag |= VK_RESOLVE_MODE_MIN_BIT_KHR; return *this; } 
    New_type& off_min_khr(){ flag |= ~(VK_RESOLVE_MODE_MIN_BIT_KHR); return *this; }
    New_type& on_max_khr(){ flag |= VK_RESOLVE_MODE_MAX_BIT_KHR; return *this; } 
    New_type& off_max_khr(){ flag |= ~(VK_RESOLVE_MODE_MAX_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_RESOLVE_MODE_NONE_KHR| VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR| VK_RESOLVE_MODE_AVERAGE_BIT_KHR| VK_RESOLVE_MODE_MIN_BIT_KHR| VK_RESOLVE_MODE_MAX_BIT_KHR;
};
inL constexpr F_ResolveModeKHR operator|(F_ResolveModeKHR::Otype const b1, F_ResolveModeKHR const b2) { return b1 | b2.flag; }
inL constexpr F_ResolveModeKHR operator|(F_ResolveModeKHR const b1, F_ResolveModeKHR::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ResolveModeKHR operator&(F_ResolveModeKHR::Otype const b1, F_ResolveModeKHR const b2) { return b1 & b2.flag; }
inL constexpr F_ResolveModeKHR operator&(F_ResolveModeKHR const b1, F_ResolveModeKHR::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkResolveModeFlagBitsKHR> { using T = F_ResolveModeKHR; };
struct F_CommandBufferReset : public E<VkCommandBufferResetFlagBits> {
    using E::E;
    using New_type = F_CommandBufferReset;
    static constexpr OEtype b_release_resources = VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT;
    New_type& on_release_resources(){ flag |= VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT; return *this; } 
    New_type& off_release_resources(){ flag |= ~(VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT;
};
inL constexpr F_CommandBufferReset operator|(F_CommandBufferReset::Otype const b1, F_CommandBufferReset const b2) { return b1 | b2.flag; }
inL constexpr F_CommandBufferReset operator|(F_CommandBufferReset const b1, F_CommandBufferReset::Otype const b2) { return b1.flag | b2; }
inL constexpr F_CommandBufferReset operator&(F_CommandBufferReset::Otype const b1, F_CommandBufferReset const b2) { return b1 & b2.flag; }
inL constexpr F_CommandBufferReset operator&(F_CommandBufferReset const b1, F_CommandBufferReset::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkCommandBufferResetFlagBits> { using T = F_CommandBufferReset; };
struct F_RenderPassCreate : public E<VkRenderPassCreateFlagBits> {
    using E::E;
    using New_type = F_RenderPassCreate;
    static constexpr unsigned int all_bits = 0 ;
};
inL constexpr F_RenderPassCreate operator|(F_RenderPassCreate::Otype const b1, F_RenderPassCreate const b2) { return b1 | b2.flag; }
inL constexpr F_RenderPassCreate operator|(F_RenderPassCreate const b1, F_RenderPassCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_RenderPassCreate operator&(F_RenderPassCreate::Otype const b1, F_RenderPassCreate const b2) { return b1 & b2.flag; }
inL constexpr F_RenderPassCreate operator&(F_RenderPassCreate const b1, F_RenderPassCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkRenderPassCreateFlagBits> { using T = F_RenderPassCreate; };
struct F_QueryResult : public E<VkQueryResultFlagBits> {
    using E::E;
    using New_type = F_QueryResult;
    static constexpr OEtype b_64 = VK_QUERY_RESULT_64_BIT;
    static constexpr OEtype b_wait = VK_QUERY_RESULT_WAIT_BIT;
    static constexpr OEtype b_with_availability = VK_QUERY_RESULT_WITH_AVAILABILITY_BIT;
    static constexpr OEtype b_partial = VK_QUERY_RESULT_PARTIAL_BIT;
    New_type& on_64(){ flag |= VK_QUERY_RESULT_64_BIT; return *this; } 
    New_type& off_64(){ flag |= ~(VK_QUERY_RESULT_64_BIT); return *this; }
    New_type& on_wait(){ flag |= VK_QUERY_RESULT_WAIT_BIT; return *this; } 
    New_type& off_wait(){ flag |= ~(VK_QUERY_RESULT_WAIT_BIT); return *this; }
    New_type& on_with_availability(){ flag |= VK_QUERY_RESULT_WITH_AVAILABILITY_BIT; return *this; } 
    New_type& off_with_availability(){ flag |= ~(VK_QUERY_RESULT_WITH_AVAILABILITY_BIT); return *this; }
    New_type& on_partial(){ flag |= VK_QUERY_RESULT_PARTIAL_BIT; return *this; } 
    New_type& off_partial(){ flag |= ~(VK_QUERY_RESULT_PARTIAL_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_QUERY_RESULT_64_BIT| VK_QUERY_RESULT_WAIT_BIT| VK_QUERY_RESULT_WITH_AVAILABILITY_BIT| VK_QUERY_RESULT_PARTIAL_BIT;
};
inL constexpr F_QueryResult operator|(F_QueryResult::Otype const b1, F_QueryResult const b2) { return b1 | b2.flag; }
inL constexpr F_QueryResult operator|(F_QueryResult const b1, F_QueryResult::Otype const b2) { return b1.flag | b2; }
inL constexpr F_QueryResult operator&(F_QueryResult::Otype const b1, F_QueryResult const b2) { return b1 & b2.flag; }
inL constexpr F_QueryResult operator&(F_QueryResult const b1, F_QueryResult::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkQueryResultFlagBits> { using T = F_QueryResult; };

# if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct F_SwapchainImageUsageANDROID : public E<VkSwapchainImageUsageFlagBitsANDROID> {
    using E::E;
    using New_type = F_SwapchainImageUsageANDROID;
    static constexpr OEtype b_shared_android = VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID;
    New_type& on_shared_android(){ flag |= VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID; return *this; } 
    New_type& off_shared_android(){ flag |= ~(VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_SWAPCHAIN_IMAGE_USAGE_SHARED_BIT_ANDROID;
};
inL constexpr F_SwapchainImageUsageANDROID operator|(F_SwapchainImageUsageANDROID::Otype const b1, F_SwapchainImageUsageANDROID const b2) { return b1 | b2.flag; }
inL constexpr F_SwapchainImageUsageANDROID operator|(F_SwapchainImageUsageANDROID const b1, F_SwapchainImageUsageANDROID::Otype const b2) { return b1.flag | b2; }
inL constexpr F_SwapchainImageUsageANDROID operator&(F_SwapchainImageUsageANDROID::Otype const b1, F_SwapchainImageUsageANDROID const b2) { return b1 & b2.flag; }
inL constexpr F_SwapchainImageUsageANDROID operator&(F_SwapchainImageUsageANDROID const b1, F_SwapchainImageUsageANDROID::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkSwapchainImageUsageFlagBitsANDROID> { using T = F_SwapchainImageUsageANDROID; };

# endif
struct F_BuildAccelerationStructureNV : public E<VkBuildAccelerationStructureFlagBitsNV> {
    using E::E;
    using New_type = F_BuildAccelerationStructureNV;
    static constexpr OEtype b_allow_update_nv = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV;
    static constexpr OEtype b_allow_compaction_nv = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV;
    static constexpr OEtype b_prefer_fast_trace_nv = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV;
    static constexpr OEtype b_prefer_fast_build_nv = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV;
    static constexpr OEtype b_low_memory_nv = VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV;
    New_type& on_allow_update_nv(){ flag |= VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV; return *this; } 
    New_type& off_allow_update_nv(){ flag |= ~(VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV); return *this; }
    New_type& on_allow_compaction_nv(){ flag |= VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV; return *this; } 
    New_type& off_allow_compaction_nv(){ flag |= ~(VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV); return *this; }
    New_type& on_prefer_fast_trace_nv(){ flag |= VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV; return *this; } 
    New_type& off_prefer_fast_trace_nv(){ flag |= ~(VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV); return *this; }
    New_type& on_prefer_fast_build_nv(){ flag |= VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV; return *this; } 
    New_type& off_prefer_fast_build_nv(){ flag |= ~(VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV); return *this; }
    New_type& on_low_memory_nv(){ flag |= VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV; return *this; } 
    New_type& off_low_memory_nv(){ flag |= ~(VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV| VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV| VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV| VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV| VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV;
};
inL constexpr F_BuildAccelerationStructureNV operator|(F_BuildAccelerationStructureNV::Otype const b1, F_BuildAccelerationStructureNV const b2) { return b1 | b2.flag; }
inL constexpr F_BuildAccelerationStructureNV operator|(F_BuildAccelerationStructureNV const b1, F_BuildAccelerationStructureNV::Otype const b2) { return b1.flag | b2; }
inL constexpr F_BuildAccelerationStructureNV operator&(F_BuildAccelerationStructureNV::Otype const b1, F_BuildAccelerationStructureNV const b2) { return b1 & b2.flag; }
inL constexpr F_BuildAccelerationStructureNV operator&(F_BuildAccelerationStructureNV const b1, F_BuildAccelerationStructureNV::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkBuildAccelerationStructureFlagBitsNV> { using T = F_BuildAccelerationStructureNV; };
struct F_ShaderModuleCreate : public E<VkShaderModuleCreateFlagBits> {
    using E::E;
    using New_type = F_ShaderModuleCreate;
    static constexpr unsigned int all_bits = 0 ;
};
inL constexpr F_ShaderModuleCreate operator|(F_ShaderModuleCreate::Otype const b1, F_ShaderModuleCreate const b2) { return b1 | b2.flag; }
inL constexpr F_ShaderModuleCreate operator|(F_ShaderModuleCreate const b1, F_ShaderModuleCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ShaderModuleCreate operator&(F_ShaderModuleCreate::Otype const b1, F_ShaderModuleCreate const b2) { return b1 & b2.flag; }
inL constexpr F_ShaderModuleCreate operator&(F_ShaderModuleCreate const b1, F_ShaderModuleCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkShaderModuleCreateFlagBits> { using T = F_ShaderModuleCreate; };
struct F_SamplerCreate : public E<VkSamplerCreateFlagBits> {
    using E::E;
    using New_type = F_SamplerCreate;
    static constexpr OEtype b_subsampled_ext = VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT;
    static constexpr OEtype b_subsampled_coarse_reconstruction_ext = VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT;
    New_type& on_subsampled_ext(){ flag |= VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT; return *this; } 
    New_type& off_subsampled_ext(){ flag |= ~(VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT); return *this; }
    New_type& on_subsampled_coarse_reconstruction_ext(){ flag |= VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT; return *this; } 
    New_type& off_subsampled_coarse_reconstruction_ext(){ flag |= ~(VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT| VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT;
};
inL constexpr F_SamplerCreate operator|(F_SamplerCreate::Otype const b1, F_SamplerCreate const b2) { return b1 | b2.flag; }
inL constexpr F_SamplerCreate operator|(F_SamplerCreate const b1, F_SamplerCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_SamplerCreate operator&(F_SamplerCreate::Otype const b1, F_SamplerCreate const b2) { return b1 & b2.flag; }
inL constexpr F_SamplerCreate operator&(F_SamplerCreate const b1, F_SamplerCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkSamplerCreateFlagBits> { using T = F_SamplerCreate; };
struct F_GeometryNV : public E<VkGeometryFlagBitsNV> {
    using E::E;
    using New_type = F_GeometryNV;
    static constexpr OEtype b_opaque_nv = VK_GEOMETRY_OPAQUE_BIT_NV;
    static constexpr OEtype b_no_duplicate_any_hit_invocation_nv = VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV;
    New_type& on_opaque_nv(){ flag |= VK_GEOMETRY_OPAQUE_BIT_NV; return *this; } 
    New_type& off_opaque_nv(){ flag |= ~(VK_GEOMETRY_OPAQUE_BIT_NV); return *this; }
    New_type& on_no_duplicate_any_hit_invocation_nv(){ flag |= VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV; return *this; } 
    New_type& off_no_duplicate_any_hit_invocation_nv(){ flag |= ~(VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_GEOMETRY_OPAQUE_BIT_NV| VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV;
};
inL constexpr F_GeometryNV operator|(F_GeometryNV::Otype const b1, F_GeometryNV const b2) { return b1 | b2.flag; }
inL constexpr F_GeometryNV operator|(F_GeometryNV const b1, F_GeometryNV::Otype const b2) { return b1.flag | b2; }
inL constexpr F_GeometryNV operator&(F_GeometryNV::Otype const b1, F_GeometryNV const b2) { return b1 & b2.flag; }
inL constexpr F_GeometryNV operator&(F_GeometryNV const b1, F_GeometryNV::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkGeometryFlagBitsNV> { using T = F_GeometryNV; };
struct F_CompositeAlphaKHR : public E<VkCompositeAlphaFlagBitsKHR> {
    using E::E;
    using New_type = F_CompositeAlphaKHR;
    static constexpr OEtype b_opaque_khr = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
    static constexpr OEtype b_pre_multiplied_khr = VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR;
    static constexpr OEtype b_post_multiplied_khr = VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR;
    static constexpr OEtype b_inherit_khr = VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR;
    New_type& on_opaque_khr(){ flag |= VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR; return *this; } 
    New_type& off_opaque_khr(){ flag |= ~(VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR); return *this; }
    New_type& on_pre_multiplied_khr(){ flag |= VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR; return *this; } 
    New_type& off_pre_multiplied_khr(){ flag |= ~(VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR); return *this; }
    New_type& on_post_multiplied_khr(){ flag |= VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR; return *this; } 
    New_type& off_post_multiplied_khr(){ flag |= ~(VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR); return *this; }
    New_type& on_inherit_khr(){ flag |= VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR; return *this; } 
    New_type& off_inherit_khr(){ flag |= ~(VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR| VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR| VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR| VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR;
};
inL constexpr F_CompositeAlphaKHR operator|(F_CompositeAlphaKHR::Otype const b1, F_CompositeAlphaKHR const b2) { return b1 | b2.flag; }
inL constexpr F_CompositeAlphaKHR operator|(F_CompositeAlphaKHR const b1, F_CompositeAlphaKHR::Otype const b2) { return b1.flag | b2; }
inL constexpr F_CompositeAlphaKHR operator&(F_CompositeAlphaKHR::Otype const b1, F_CompositeAlphaKHR const b2) { return b1 & b2.flag; }
inL constexpr F_CompositeAlphaKHR operator&(F_CompositeAlphaKHR const b1, F_CompositeAlphaKHR::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkCompositeAlphaFlagBitsKHR> { using T = F_CompositeAlphaKHR; };
struct F_AttachmentDescription : public E<VkAttachmentDescriptionFlagBits> {
    using E::E;
    using New_type = F_AttachmentDescription;
    static constexpr OEtype b_may_alias = VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT;
    New_type& on_may_alias(){ flag |= VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT; return *this; } 
    New_type& off_may_alias(){ flag |= ~(VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT;
};
inL constexpr F_AttachmentDescription operator|(F_AttachmentDescription::Otype const b1, F_AttachmentDescription const b2) { return b1 | b2.flag; }
inL constexpr F_AttachmentDescription operator|(F_AttachmentDescription const b1, F_AttachmentDescription::Otype const b2) { return b1.flag | b2; }
inL constexpr F_AttachmentDescription operator&(F_AttachmentDescription::Otype const b1, F_AttachmentDescription const b2) { return b1 & b2.flag; }
inL constexpr F_AttachmentDescription operator&(F_AttachmentDescription const b1, F_AttachmentDescription::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkAttachmentDescriptionFlagBits> { using T = F_AttachmentDescription; };
struct F_PeerMemoryFeature : public E<VkPeerMemoryFeatureFlagBits> {
    using E::E;
    using New_type = F_PeerMemoryFeature;
    static constexpr OEtype b_copy_src = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT;
    static constexpr OEtype b_copy_dst = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT;
    static constexpr OEtype b_generic_src = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT;
    static constexpr OEtype b_generic_dst = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT;
    static constexpr OEtype b_copy_src_khr = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR;
    static constexpr OEtype b_copy_dst_khr = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR;
    static constexpr OEtype b_generic_src_khr = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR;
    static constexpr OEtype b_generic_dst_khr = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR;
    New_type& on_copy_src(){ flag |= VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT; return *this; } 
    New_type& off_copy_src(){ flag |= ~(VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT); return *this; }
    New_type& on_copy_dst(){ flag |= VK_PEER_MEMORY_FEATURE_COPY_DST_BIT; return *this; } 
    New_type& off_copy_dst(){ flag |= ~(VK_PEER_MEMORY_FEATURE_COPY_DST_BIT); return *this; }
    New_type& on_generic_src(){ flag |= VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT; return *this; } 
    New_type& off_generic_src(){ flag |= ~(VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT); return *this; }
    New_type& on_generic_dst(){ flag |= VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT; return *this; } 
    New_type& off_generic_dst(){ flag |= ~(VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT); return *this; }
    New_type& on_copy_src_khr(){ flag |= VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR; return *this; } 
    New_type& off_copy_src_khr(){ flag |= ~(VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR); return *this; }
    New_type& on_copy_dst_khr(){ flag |= VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR; return *this; } 
    New_type& off_copy_dst_khr(){ flag |= ~(VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR); return *this; }
    New_type& on_generic_src_khr(){ flag |= VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR; return *this; } 
    New_type& off_generic_src_khr(){ flag |= ~(VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR); return *this; }
    New_type& on_generic_dst_khr(){ flag |= VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR; return *this; } 
    New_type& off_generic_dst_khr(){ flag |= ~(VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT| VK_PEER_MEMORY_FEATURE_COPY_DST_BIT| VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT| VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT| VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR| VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR| VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR| VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR;
};
inL constexpr F_PeerMemoryFeature operator|(F_PeerMemoryFeature::Otype const b1, F_PeerMemoryFeature const b2) { return b1 | b2.flag; }
inL constexpr F_PeerMemoryFeature operator|(F_PeerMemoryFeature const b1, F_PeerMemoryFeature::Otype const b2) { return b1.flag | b2; }
inL constexpr F_PeerMemoryFeature operator&(F_PeerMemoryFeature::Otype const b1, F_PeerMemoryFeature const b2) { return b1 & b2.flag; }
inL constexpr F_PeerMemoryFeature operator&(F_PeerMemoryFeature const b1, F_PeerMemoryFeature::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkPeerMemoryFeatureFlagBits> { using T = F_PeerMemoryFeature; };
struct F_ExternalMemoryHandleType : public E<VkExternalMemoryHandleTypeFlagBits> {
    using E::E;
    using New_type = F_ExternalMemoryHandleType;
    static constexpr OEtype b_opaque_fd = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
    static constexpr OEtype b_opaque_win32 = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
    static constexpr OEtype b_opaque_win32_kmt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
    static constexpr OEtype b_d3d11_texture = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT;
    static constexpr OEtype b_d3d11_texture_kmt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT;
    static constexpr OEtype b_d3d12_heap = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT;
    static constexpr OEtype b_d3d12_resource = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT;
    static constexpr OEtype b_opaque_fd_khr = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    static constexpr OEtype b_opaque_win32_khr = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    static constexpr OEtype b_opaque_win32_kmt_khr = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    static constexpr OEtype b_d3d11_texture_khr = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR;
    static constexpr OEtype b_d3d11_texture_kmt_khr = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR;
    static constexpr OEtype b_d3d12_heap_khr = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR;
    static constexpr OEtype b_d3d12_resource_khr = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR;
    static constexpr OEtype b_dma_buf_ext = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
    static constexpr OEtype b_android_hardware_buffer_android = VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID;
    static constexpr OEtype b_host_allocation_ext = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
    static constexpr OEtype b_host_mapped_foreign_memory_ext = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
    New_type& on_opaque_fd(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT; return *this; } 
    New_type& off_opaque_fd(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT); return *this; }
    New_type& on_opaque_win32(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT; return *this; } 
    New_type& off_opaque_win32(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT); return *this; }
    New_type& on_opaque_win32_kmt(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT; return *this; } 
    New_type& off_opaque_win32_kmt(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT); return *this; }
    New_type& on_d3d11_texture(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT; return *this; } 
    New_type& off_d3d11_texture(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT); return *this; }
    New_type& on_d3d11_texture_kmt(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT; return *this; } 
    New_type& off_d3d11_texture_kmt(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT); return *this; }
    New_type& on_d3d12_heap(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT; return *this; } 
    New_type& off_d3d12_heap(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT); return *this; }
    New_type& on_d3d12_resource(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT; return *this; } 
    New_type& off_d3d12_resource(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT); return *this; }
    New_type& on_opaque_fd_khr(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR; return *this; } 
    New_type& off_opaque_fd_khr(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR); return *this; }
    New_type& on_opaque_win32_khr(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR; return *this; } 
    New_type& off_opaque_win32_khr(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR); return *this; }
    New_type& on_opaque_win32_kmt_khr(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR; return *this; } 
    New_type& off_opaque_win32_kmt_khr(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR); return *this; }
    New_type& on_d3d11_texture_khr(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR; return *this; } 
    New_type& off_d3d11_texture_khr(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR); return *this; }
    New_type& on_d3d11_texture_kmt_khr(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR; return *this; } 
    New_type& off_d3d11_texture_kmt_khr(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR); return *this; }
    New_type& on_d3d12_heap_khr(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR; return *this; } 
    New_type& off_d3d12_heap_khr(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR); return *this; }
    New_type& on_d3d12_resource_khr(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR; return *this; } 
    New_type& off_d3d12_resource_khr(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR); return *this; }
    New_type& on_dma_buf_ext(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT; return *this; } 
    New_type& off_dma_buf_ext(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT); return *this; }
    New_type& on_android_hardware_buffer_android(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID; return *this; } 
    New_type& off_android_hardware_buffer_android(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID); return *this; }
    New_type& on_host_allocation_ext(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT; return *this; } 
    New_type& off_host_allocation_ext(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT); return *this; }
    New_type& on_host_mapped_foreign_memory_ext(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT; return *this; } 
    New_type& off_host_mapped_foreign_memory_ext(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT| VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT| VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT| VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT| VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT| VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT| VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT| VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR| VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR| VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR| VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR| VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR| VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR| VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR| VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT| VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID| VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT| VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
};
inL constexpr F_ExternalMemoryHandleType operator|(F_ExternalMemoryHandleType::Otype const b1, F_ExternalMemoryHandleType const b2) { return b1 | b2.flag; }
inL constexpr F_ExternalMemoryHandleType operator|(F_ExternalMemoryHandleType const b1, F_ExternalMemoryHandleType::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ExternalMemoryHandleType operator&(F_ExternalMemoryHandleType::Otype const b1, F_ExternalMemoryHandleType const b2) { return b1 & b2.flag; }
inL constexpr F_ExternalMemoryHandleType operator&(F_ExternalMemoryHandleType const b1, F_ExternalMemoryHandleType::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkExternalMemoryHandleTypeFlagBits> { using T = F_ExternalMemoryHandleType; };
struct F_PipelineCompilerControlAMD : public E<VkPipelineCompilerControlFlagBitsAMD> {
    using E::E;
    using New_type = F_PipelineCompilerControlAMD;
    static constexpr unsigned int all_bits = 0 ;
};
inL constexpr F_PipelineCompilerControlAMD operator|(F_PipelineCompilerControlAMD::Otype const b1, F_PipelineCompilerControlAMD const b2) { return b1 | b2.flag; }
inL constexpr F_PipelineCompilerControlAMD operator|(F_PipelineCompilerControlAMD const b1, F_PipelineCompilerControlAMD::Otype const b2) { return b1.flag | b2; }
inL constexpr F_PipelineCompilerControlAMD operator&(F_PipelineCompilerControlAMD::Otype const b1, F_PipelineCompilerControlAMD const b2) { return b1 & b2.flag; }
inL constexpr F_PipelineCompilerControlAMD operator&(F_PipelineCompilerControlAMD const b1, F_PipelineCompilerControlAMD::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkPipelineCompilerControlFlagBitsAMD> { using T = F_PipelineCompilerControlAMD; };
struct F_SparseImageFormat : public E<VkSparseImageFormatFlagBits> {
    using E::E;
    using New_type = F_SparseImageFormat;
    static constexpr OEtype b_single_miptail = VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT;
    static constexpr OEtype b_aligned_mip_size = VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT;
    static constexpr OEtype b_nonstandard_block_size = VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT;
    New_type& on_single_miptail(){ flag |= VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT; return *this; } 
    New_type& off_single_miptail(){ flag |= ~(VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT); return *this; }
    New_type& on_aligned_mip_size(){ flag |= VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT; return *this; } 
    New_type& off_aligned_mip_size(){ flag |= ~(VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT); return *this; }
    New_type& on_nonstandard_block_size(){ flag |= VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT; return *this; } 
    New_type& off_nonstandard_block_size(){ flag |= ~(VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT| VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT| VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT;
};
inL constexpr F_SparseImageFormat operator|(F_SparseImageFormat::Otype const b1, F_SparseImageFormat const b2) { return b1 | b2.flag; }
inL constexpr F_SparseImageFormat operator|(F_SparseImageFormat const b1, F_SparseImageFormat::Otype const b2) { return b1.flag | b2; }
inL constexpr F_SparseImageFormat operator&(F_SparseImageFormat::Otype const b1, F_SparseImageFormat const b2) { return b1 & b2.flag; }
inL constexpr F_SparseImageFormat operator&(F_SparseImageFormat const b1, F_SparseImageFormat::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkSparseImageFormatFlagBits> { using T = F_SparseImageFormat; };
struct F_BufferUsage : public E<VkBufferUsageFlagBits> {
    using E::E;
    using New_type = F_BufferUsage;
    static constexpr OEtype b_transfer_src = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
    static constexpr OEtype b_transfer_dst = VK_BUFFER_USAGE_TRANSFER_DST_BIT;
    static constexpr OEtype b_uniform_texel_buffer = VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT;
    static constexpr OEtype b_storage_texel_buffer = VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT;
    static constexpr OEtype b_uniform_buffer = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    static constexpr OEtype b_storage_buffer = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT;
    static constexpr OEtype b_index_buffer = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    static constexpr OEtype b_vertex_buffer = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    static constexpr OEtype b_indirect_buffer = VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT;
    static constexpr OEtype b_transform_feedback_buffer_ext = VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT;
    static constexpr OEtype b_transform_feedback_counter_buffer_ext = VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT;
    static constexpr OEtype b_conditional_rendering_ext = VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT;
    static constexpr OEtype b_ray_tracing_nv = VK_BUFFER_USAGE_RAY_TRACING_BIT_NV;
    static constexpr OEtype b_shader_device_address_ext = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT;
    New_type& on_transfer_src(){ flag |= VK_BUFFER_USAGE_TRANSFER_SRC_BIT; return *this; } 
    New_type& off_transfer_src(){ flag |= ~(VK_BUFFER_USAGE_TRANSFER_SRC_BIT); return *this; }
    New_type& on_transfer_dst(){ flag |= VK_BUFFER_USAGE_TRANSFER_DST_BIT; return *this; } 
    New_type& off_transfer_dst(){ flag |= ~(VK_BUFFER_USAGE_TRANSFER_DST_BIT); return *this; }
    New_type& on_uniform_texel_buffer(){ flag |= VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT; return *this; } 
    New_type& off_uniform_texel_buffer(){ flag |= ~(VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT); return *this; }
    New_type& on_storage_texel_buffer(){ flag |= VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT; return *this; } 
    New_type& off_storage_texel_buffer(){ flag |= ~(VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT); return *this; }
    New_type& on_uniform_buffer(){ flag |= VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT; return *this; } 
    New_type& off_uniform_buffer(){ flag |= ~(VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT); return *this; }
    New_type& on_storage_buffer(){ flag |= VK_BUFFER_USAGE_STORAGE_BUFFER_BIT; return *this; } 
    New_type& off_storage_buffer(){ flag |= ~(VK_BUFFER_USAGE_STORAGE_BUFFER_BIT); return *this; }
    New_type& on_index_buffer(){ flag |= VK_BUFFER_USAGE_INDEX_BUFFER_BIT; return *this; } 
    New_type& off_index_buffer(){ flag |= ~(VK_BUFFER_USAGE_INDEX_BUFFER_BIT); return *this; }
    New_type& on_vertex_buffer(){ flag |= VK_BUFFER_USAGE_VERTEX_BUFFER_BIT; return *this; } 
    New_type& off_vertex_buffer(){ flag |= ~(VK_BUFFER_USAGE_VERTEX_BUFFER_BIT); return *this; }
    New_type& on_indirect_buffer(){ flag |= VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT; return *this; } 
    New_type& off_indirect_buffer(){ flag |= ~(VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT); return *this; }
    New_type& on_transform_feedback_buffer_ext(){ flag |= VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT; return *this; } 
    New_type& off_transform_feedback_buffer_ext(){ flag |= ~(VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT); return *this; }
    New_type& on_transform_feedback_counter_buffer_ext(){ flag |= VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT; return *this; } 
    New_type& off_transform_feedback_counter_buffer_ext(){ flag |= ~(VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT); return *this; }
    New_type& on_conditional_rendering_ext(){ flag |= VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT; return *this; } 
    New_type& off_conditional_rendering_ext(){ flag |= ~(VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT); return *this; }
    New_type& on_ray_tracing_nv(){ flag |= VK_BUFFER_USAGE_RAY_TRACING_BIT_NV; return *this; } 
    New_type& off_ray_tracing_nv(){ flag |= ~(VK_BUFFER_USAGE_RAY_TRACING_BIT_NV); return *this; }
    New_type& on_shader_device_address_ext(){ flag |= VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT; return *this; } 
    New_type& off_shader_device_address_ext(){ flag |= ~(VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_BUFFER_USAGE_TRANSFER_SRC_BIT| VK_BUFFER_USAGE_TRANSFER_DST_BIT| VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT| VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT| VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT| VK_BUFFER_USAGE_STORAGE_BUFFER_BIT| VK_BUFFER_USAGE_INDEX_BUFFER_BIT| VK_BUFFER_USAGE_VERTEX_BUFFER_BIT| VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT| VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT| VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT| VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT| VK_BUFFER_USAGE_RAY_TRACING_BIT_NV| VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT;
};
inL constexpr F_BufferUsage operator|(F_BufferUsage::Otype const b1, F_BufferUsage const b2) { return b1 | b2.flag; }
inL constexpr F_BufferUsage operator|(F_BufferUsage const b1, F_BufferUsage::Otype const b2) { return b1.flag | b2; }
inL constexpr F_BufferUsage operator&(F_BufferUsage::Otype const b1, F_BufferUsage const b2) { return b1 & b2.flag; }
inL constexpr F_BufferUsage operator&(F_BufferUsage const b1, F_BufferUsage::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkBufferUsageFlagBits> { using T = F_BufferUsage; };
struct F_SampleCount : public E<VkSampleCountFlagBits> {
    using E::E;
    using New_type = F_SampleCount;
    static constexpr OEtype b_1 = VK_SAMPLE_COUNT_1_BIT;
    static constexpr OEtype b_2 = VK_SAMPLE_COUNT_2_BIT;
    static constexpr OEtype b_4 = VK_SAMPLE_COUNT_4_BIT;
    static constexpr OEtype b_8 = VK_SAMPLE_COUNT_8_BIT;
    static constexpr OEtype b_16 = VK_SAMPLE_COUNT_16_BIT;
    static constexpr OEtype b_32 = VK_SAMPLE_COUNT_32_BIT;
    static constexpr OEtype b_64 = VK_SAMPLE_COUNT_64_BIT;
    New_type& on_1(){ flag |= VK_SAMPLE_COUNT_1_BIT; return *this; } 
    New_type& off_1(){ flag |= ~(VK_SAMPLE_COUNT_1_BIT); return *this; }
    New_type& on_2(){ flag |= VK_SAMPLE_COUNT_2_BIT; return *this; } 
    New_type& off_2(){ flag |= ~(VK_SAMPLE_COUNT_2_BIT); return *this; }
    New_type& on_4(){ flag |= VK_SAMPLE_COUNT_4_BIT; return *this; } 
    New_type& off_4(){ flag |= ~(VK_SAMPLE_COUNT_4_BIT); return *this; }
    New_type& on_8(){ flag |= VK_SAMPLE_COUNT_8_BIT; return *this; } 
    New_type& off_8(){ flag |= ~(VK_SAMPLE_COUNT_8_BIT); return *this; }
    New_type& on_16(){ flag |= VK_SAMPLE_COUNT_16_BIT; return *this; } 
    New_type& off_16(){ flag |= ~(VK_SAMPLE_COUNT_16_BIT); return *this; }
    New_type& on_32(){ flag |= VK_SAMPLE_COUNT_32_BIT; return *this; } 
    New_type& off_32(){ flag |= ~(VK_SAMPLE_COUNT_32_BIT); return *this; }
    New_type& on_64(){ flag |= VK_SAMPLE_COUNT_64_BIT; return *this; } 
    New_type& off_64(){ flag |= ~(VK_SAMPLE_COUNT_64_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_SAMPLE_COUNT_1_BIT| VK_SAMPLE_COUNT_2_BIT| VK_SAMPLE_COUNT_4_BIT| VK_SAMPLE_COUNT_8_BIT| VK_SAMPLE_COUNT_16_BIT| VK_SAMPLE_COUNT_32_BIT| VK_SAMPLE_COUNT_64_BIT;
};
inL constexpr F_SampleCount operator|(F_SampleCount::Otype const b1, F_SampleCount const b2) { return b1 | b2.flag; }
inL constexpr F_SampleCount operator|(F_SampleCount const b1, F_SampleCount::Otype const b2) { return b1.flag | b2; }
inL constexpr F_SampleCount operator&(F_SampleCount::Otype const b1, F_SampleCount const b2) { return b1 & b2.flag; }
inL constexpr F_SampleCount operator&(F_SampleCount const b1, F_SampleCount::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkSampleCountFlagBits> { using T = F_SampleCount; };
struct F_Queue : public E<VkQueueFlagBits> {
    using E::E;
    using New_type = F_Queue;
    static constexpr OEtype b_graphics = VK_QUEUE_GRAPHICS_BIT;
    static constexpr OEtype b_compute = VK_QUEUE_COMPUTE_BIT;
    static constexpr OEtype b_transfer = VK_QUEUE_TRANSFER_BIT;
    static constexpr OEtype b_sparse_binding = VK_QUEUE_SPARSE_BINDING_BIT;
    static constexpr OEtype b_protected = VK_QUEUE_PROTECTED_BIT;
    New_type& on_graphics(){ flag |= VK_QUEUE_GRAPHICS_BIT; return *this; } 
    New_type& off_graphics(){ flag |= ~(VK_QUEUE_GRAPHICS_BIT); return *this; }
    New_type& on_compute(){ flag |= VK_QUEUE_COMPUTE_BIT; return *this; } 
    New_type& off_compute(){ flag |= ~(VK_QUEUE_COMPUTE_BIT); return *this; }
    New_type& on_transfer(){ flag |= VK_QUEUE_TRANSFER_BIT; return *this; } 
    New_type& off_transfer(){ flag |= ~(VK_QUEUE_TRANSFER_BIT); return *this; }
    New_type& on_sparse_binding(){ flag |= VK_QUEUE_SPARSE_BINDING_BIT; return *this; } 
    New_type& off_sparse_binding(){ flag |= ~(VK_QUEUE_SPARSE_BINDING_BIT); return *this; }
    New_type& on_protected(){ flag |= VK_QUEUE_PROTECTED_BIT; return *this; } 
    New_type& off_protected(){ flag |= ~(VK_QUEUE_PROTECTED_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_QUEUE_GRAPHICS_BIT| VK_QUEUE_COMPUTE_BIT| VK_QUEUE_TRANSFER_BIT| VK_QUEUE_SPARSE_BINDING_BIT| VK_QUEUE_PROTECTED_BIT;
};
inL constexpr F_Queue operator|(F_Queue::Otype const b1, F_Queue const b2) { return b1 | b2.flag; }
inL constexpr F_Queue operator|(F_Queue const b1, F_Queue::Otype const b2) { return b1.flag | b2; }
inL constexpr F_Queue operator&(F_Queue::Otype const b1, F_Queue const b2) { return b1 & b2.flag; }
inL constexpr F_Queue operator&(F_Queue const b1, F_Queue::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkQueueFlagBits> { using T = F_Queue; };
struct F_DebugUtilsMessageTypeEXT : public E<VkDebugUtilsMessageTypeFlagBitsEXT> {
    using E::E;
    using New_type = F_DebugUtilsMessageTypeEXT;
    static constexpr OEtype b_general_ext = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT;
    static constexpr OEtype b_validation_ext = VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT;
    static constexpr OEtype b_performance_ext = VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
    New_type& on_general_ext(){ flag |= VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT; return *this; } 
    New_type& off_general_ext(){ flag |= ~(VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT); return *this; }
    New_type& on_validation_ext(){ flag |= VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT; return *this; } 
    New_type& off_validation_ext(){ flag |= ~(VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT); return *this; }
    New_type& on_performance_ext(){ flag |= VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT; return *this; } 
    New_type& off_performance_ext(){ flag |= ~(VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT| VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT| VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
};
inL constexpr F_DebugUtilsMessageTypeEXT operator|(F_DebugUtilsMessageTypeEXT::Otype const b1, F_DebugUtilsMessageTypeEXT const b2) { return b1 | b2.flag; }
inL constexpr F_DebugUtilsMessageTypeEXT operator|(F_DebugUtilsMessageTypeEXT const b1, F_DebugUtilsMessageTypeEXT::Otype const b2) { return b1.flag | b2; }
inL constexpr F_DebugUtilsMessageTypeEXT operator&(F_DebugUtilsMessageTypeEXT::Otype const b1, F_DebugUtilsMessageTypeEXT const b2) { return b1 & b2.flag; }
inL constexpr F_DebugUtilsMessageTypeEXT operator&(F_DebugUtilsMessageTypeEXT const b1, F_DebugUtilsMessageTypeEXT::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkDebugUtilsMessageTypeFlagBitsEXT> { using T = F_DebugUtilsMessageTypeEXT; };
struct F_DescriptorPoolCreate : public E<VkDescriptorPoolCreateFlagBits> {
    using E::E;
    using New_type = F_DescriptorPoolCreate;
    static constexpr OEtype b_free_descriptor_set = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
    static constexpr OEtype b_update_after_bind_ext = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT;
    New_type& on_free_descriptor_set(){ flag |= VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT; return *this; } 
    New_type& off_free_descriptor_set(){ flag |= ~(VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT); return *this; }
    New_type& on_update_after_bind_ext(){ flag |= VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT; return *this; } 
    New_type& off_update_after_bind_ext(){ flag |= ~(VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT| VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT;
};
inL constexpr F_DescriptorPoolCreate operator|(F_DescriptorPoolCreate::Otype const b1, F_DescriptorPoolCreate const b2) { return b1 | b2.flag; }
inL constexpr F_DescriptorPoolCreate operator|(F_DescriptorPoolCreate const b1, F_DescriptorPoolCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_DescriptorPoolCreate operator&(F_DescriptorPoolCreate::Otype const b1, F_DescriptorPoolCreate const b2) { return b1 & b2.flag; }
inL constexpr F_DescriptorPoolCreate operator&(F_DescriptorPoolCreate const b1, F_DescriptorPoolCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkDescriptorPoolCreateFlagBits> { using T = F_DescriptorPoolCreate; };
struct F_ImageCreate : public E<VkImageCreateFlagBits> {
    using E::E;
    using New_type = F_ImageCreate;
    static constexpr OEtype b_sparse_binding = VK_IMAGE_CREATE_SPARSE_BINDING_BIT;
    static constexpr OEtype b_sparse_residency = VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT;
    static constexpr OEtype b_sparse_aliased = VK_IMAGE_CREATE_SPARSE_ALIASED_BIT;
    static constexpr OEtype b_mutable_format = VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT;
    static constexpr OEtype b_cube_compatible = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT;
    static constexpr OEtype b_alias = VK_IMAGE_CREATE_ALIAS_BIT;
    static constexpr OEtype b_split_instance_bind_regions = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT;
    static constexpr OEtype b_2d_array_compatible = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT;
    static constexpr OEtype b_block_texel_view_compatible = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT;
    static constexpr OEtype b_extended_usage = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT;
    static constexpr OEtype b_protected = VK_IMAGE_CREATE_PROTECTED_BIT;
    static constexpr OEtype b_disjoint = VK_IMAGE_CREATE_DISJOINT_BIT;
    static constexpr OEtype b_corner_sampled_nv = VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV;
    static constexpr OEtype b_split_instance_bind_regions_khr = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR;
    static constexpr OEtype b_2d_array_compatible_khr = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR;
    static constexpr OEtype b_block_texel_view_compatible_khr = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR;
    static constexpr OEtype b_extended_usage_khr = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR;
    static constexpr OEtype b_sample_locations_compatible_depth_ext = VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT;
    static constexpr OEtype b_disjoint_khr = VK_IMAGE_CREATE_DISJOINT_BIT_KHR;
    static constexpr OEtype b_alias_khr = VK_IMAGE_CREATE_ALIAS_BIT_KHR;
    static constexpr OEtype b_subsampled_ext = VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT;
    New_type& on_sparse_binding(){ flag |= VK_IMAGE_CREATE_SPARSE_BINDING_BIT; return *this; } 
    New_type& off_sparse_binding(){ flag |= ~(VK_IMAGE_CREATE_SPARSE_BINDING_BIT); return *this; }
    New_type& on_sparse_residency(){ flag |= VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT; return *this; } 
    New_type& off_sparse_residency(){ flag |= ~(VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT); return *this; }
    New_type& on_sparse_aliased(){ flag |= VK_IMAGE_CREATE_SPARSE_ALIASED_BIT; return *this; } 
    New_type& off_sparse_aliased(){ flag |= ~(VK_IMAGE_CREATE_SPARSE_ALIASED_BIT); return *this; }
    New_type& on_mutable_format(){ flag |= VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT; return *this; } 
    New_type& off_mutable_format(){ flag |= ~(VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT); return *this; }
    New_type& on_cube_compatible(){ flag |= VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT; return *this; } 
    New_type& off_cube_compatible(){ flag |= ~(VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT); return *this; }
    New_type& on_alias(){ flag |= VK_IMAGE_CREATE_ALIAS_BIT; return *this; } 
    New_type& off_alias(){ flag |= ~(VK_IMAGE_CREATE_ALIAS_BIT); return *this; }
    New_type& on_split_instance_bind_regions(){ flag |= VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT; return *this; } 
    New_type& off_split_instance_bind_regions(){ flag |= ~(VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT); return *this; }
    New_type& on_2d_array_compatible(){ flag |= VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT; return *this; } 
    New_type& off_2d_array_compatible(){ flag |= ~(VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT); return *this; }
    New_type& on_block_texel_view_compatible(){ flag |= VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT; return *this; } 
    New_type& off_block_texel_view_compatible(){ flag |= ~(VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT); return *this; }
    New_type& on_extended_usage(){ flag |= VK_IMAGE_CREATE_EXTENDED_USAGE_BIT; return *this; } 
    New_type& off_extended_usage(){ flag |= ~(VK_IMAGE_CREATE_EXTENDED_USAGE_BIT); return *this; }
    New_type& on_protected(){ flag |= VK_IMAGE_CREATE_PROTECTED_BIT; return *this; } 
    New_type& off_protected(){ flag |= ~(VK_IMAGE_CREATE_PROTECTED_BIT); return *this; }
    New_type& on_disjoint(){ flag |= VK_IMAGE_CREATE_DISJOINT_BIT; return *this; } 
    New_type& off_disjoint(){ flag |= ~(VK_IMAGE_CREATE_DISJOINT_BIT); return *this; }
    New_type& on_corner_sampled_nv(){ flag |= VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV; return *this; } 
    New_type& off_corner_sampled_nv(){ flag |= ~(VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV); return *this; }
    New_type& on_split_instance_bind_regions_khr(){ flag |= VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR; return *this; } 
    New_type& off_split_instance_bind_regions_khr(){ flag |= ~(VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR); return *this; }
    New_type& on_2d_array_compatible_khr(){ flag |= VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR; return *this; } 
    New_type& off_2d_array_compatible_khr(){ flag |= ~(VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR); return *this; }
    New_type& on_block_texel_view_compatible_khr(){ flag |= VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR; return *this; } 
    New_type& off_block_texel_view_compatible_khr(){ flag |= ~(VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR); return *this; }
    New_type& on_extended_usage_khr(){ flag |= VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR; return *this; } 
    New_type& off_extended_usage_khr(){ flag |= ~(VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR); return *this; }
    New_type& on_sample_locations_compatible_depth_ext(){ flag |= VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT; return *this; } 
    New_type& off_sample_locations_compatible_depth_ext(){ flag |= ~(VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT); return *this; }
    New_type& on_disjoint_khr(){ flag |= VK_IMAGE_CREATE_DISJOINT_BIT_KHR; return *this; } 
    New_type& off_disjoint_khr(){ flag |= ~(VK_IMAGE_CREATE_DISJOINT_BIT_KHR); return *this; }
    New_type& on_alias_khr(){ flag |= VK_IMAGE_CREATE_ALIAS_BIT_KHR; return *this; } 
    New_type& off_alias_khr(){ flag |= ~(VK_IMAGE_CREATE_ALIAS_BIT_KHR); return *this; }
    New_type& on_subsampled_ext(){ flag |= VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT; return *this; } 
    New_type& off_subsampled_ext(){ flag |= ~(VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_IMAGE_CREATE_SPARSE_BINDING_BIT| VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT| VK_IMAGE_CREATE_SPARSE_ALIASED_BIT| VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT| VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT| VK_IMAGE_CREATE_ALIAS_BIT| VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT| VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT| VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT| VK_IMAGE_CREATE_EXTENDED_USAGE_BIT| VK_IMAGE_CREATE_PROTECTED_BIT| VK_IMAGE_CREATE_DISJOINT_BIT| VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV| VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR| VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR| VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR| VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR| VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT| VK_IMAGE_CREATE_DISJOINT_BIT_KHR| VK_IMAGE_CREATE_ALIAS_BIT_KHR| VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT;
};
inL constexpr F_ImageCreate operator|(F_ImageCreate::Otype const b1, F_ImageCreate const b2) { return b1 | b2.flag; }
inL constexpr F_ImageCreate operator|(F_ImageCreate const b1, F_ImageCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ImageCreate operator&(F_ImageCreate::Otype const b1, F_ImageCreate const b2) { return b1 & b2.flag; }
inL constexpr F_ImageCreate operator&(F_ImageCreate const b1, F_ImageCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkImageCreateFlagBits> { using T = F_ImageCreate; };
struct F_IndirectCommandsLayoutUsageNVX : public E<VkIndirectCommandsLayoutUsageFlagBitsNVX> {
    using E::E;
    using New_type = F_IndirectCommandsLayoutUsageNVX;
    static constexpr OEtype b_unordered_sequences_nvx = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX;
    static constexpr OEtype b_sparse_sequences_nvx = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX;
    static constexpr OEtype b_empty_executions_nvx = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX;
    static constexpr OEtype b_indexed_sequences_nvx = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX;
    New_type& on_unordered_sequences_nvx(){ flag |= VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX; return *this; } 
    New_type& off_unordered_sequences_nvx(){ flag |= ~(VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX); return *this; }
    New_type& on_sparse_sequences_nvx(){ flag |= VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX; return *this; } 
    New_type& off_sparse_sequences_nvx(){ flag |= ~(VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX); return *this; }
    New_type& on_empty_executions_nvx(){ flag |= VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX; return *this; } 
    New_type& off_empty_executions_nvx(){ flag |= ~(VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX); return *this; }
    New_type& on_indexed_sequences_nvx(){ flag |= VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX; return *this; } 
    New_type& off_indexed_sequences_nvx(){ flag |= ~(VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX| VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX| VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX| VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX;
};
inL constexpr F_IndirectCommandsLayoutUsageNVX operator|(F_IndirectCommandsLayoutUsageNVX::Otype const b1, F_IndirectCommandsLayoutUsageNVX const b2) { return b1 | b2.flag; }
inL constexpr F_IndirectCommandsLayoutUsageNVX operator|(F_IndirectCommandsLayoutUsageNVX const b1, F_IndirectCommandsLayoutUsageNVX::Otype const b2) { return b1.flag | b2; }
inL constexpr F_IndirectCommandsLayoutUsageNVX operator&(F_IndirectCommandsLayoutUsageNVX::Otype const b1, F_IndirectCommandsLayoutUsageNVX const b2) { return b1 & b2.flag; }
inL constexpr F_IndirectCommandsLayoutUsageNVX operator&(F_IndirectCommandsLayoutUsageNVX const b1, F_IndirectCommandsLayoutUsageNVX::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkIndirectCommandsLayoutUsageFlagBitsNVX> { using T = F_IndirectCommandsLayoutUsageNVX; };
struct F_ExternalMemoryFeature : public E<VkExternalMemoryFeatureFlagBits> {
    using E::E;
    using New_type = F_ExternalMemoryFeature;
    static constexpr OEtype b_dedicated_only = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT;
    static constexpr OEtype b_exportable = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT;
    static constexpr OEtype b_importable = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;
    static constexpr OEtype b_dedicated_only_khr = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR;
    static constexpr OEtype b_exportable_khr = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR;
    static constexpr OEtype b_importable_khr = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR;
    New_type& on_dedicated_only(){ flag |= VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT; return *this; } 
    New_type& off_dedicated_only(){ flag |= ~(VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT); return *this; }
    New_type& on_exportable(){ flag |= VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT; return *this; } 
    New_type& off_exportable(){ flag |= ~(VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT); return *this; }
    New_type& on_importable(){ flag |= VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT; return *this; } 
    New_type& off_importable(){ flag |= ~(VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT); return *this; }
    New_type& on_dedicated_only_khr(){ flag |= VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR; return *this; } 
    New_type& off_dedicated_only_khr(){ flag |= ~(VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR); return *this; }
    New_type& on_exportable_khr(){ flag |= VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR; return *this; } 
    New_type& off_exportable_khr(){ flag |= ~(VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR); return *this; }
    New_type& on_importable_khr(){ flag |= VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR; return *this; } 
    New_type& off_importable_khr(){ flag |= ~(VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT| VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT| VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT| VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR| VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR| VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR;
};
inL constexpr F_ExternalMemoryFeature operator|(F_ExternalMemoryFeature::Otype const b1, F_ExternalMemoryFeature const b2) { return b1 | b2.flag; }
inL constexpr F_ExternalMemoryFeature operator|(F_ExternalMemoryFeature const b1, F_ExternalMemoryFeature::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ExternalMemoryFeature operator&(F_ExternalMemoryFeature::Otype const b1, F_ExternalMemoryFeature const b2) { return b1 & b2.flag; }
inL constexpr F_ExternalMemoryFeature operator&(F_ExternalMemoryFeature const b1, F_ExternalMemoryFeature::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkExternalMemoryFeatureFlagBits> { using T = F_ExternalMemoryFeature; };
struct F_BufferCreate : public E<VkBufferCreateFlagBits> {
    using E::E;
    using New_type = F_BufferCreate;
    static constexpr OEtype b_sparse_binding = VK_BUFFER_CREATE_SPARSE_BINDING_BIT;
    static constexpr OEtype b_sparse_residency = VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT;
    static constexpr OEtype b_sparse_aliased = VK_BUFFER_CREATE_SPARSE_ALIASED_BIT;
    static constexpr OEtype b_protected = VK_BUFFER_CREATE_PROTECTED_BIT;
    static constexpr OEtype b_device_address_capture_replay_ext = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT;
    New_type& on_sparse_binding(){ flag |= VK_BUFFER_CREATE_SPARSE_BINDING_BIT; return *this; } 
    New_type& off_sparse_binding(){ flag |= ~(VK_BUFFER_CREATE_SPARSE_BINDING_BIT); return *this; }
    New_type& on_sparse_residency(){ flag |= VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT; return *this; } 
    New_type& off_sparse_residency(){ flag |= ~(VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT); return *this; }
    New_type& on_sparse_aliased(){ flag |= VK_BUFFER_CREATE_SPARSE_ALIASED_BIT; return *this; } 
    New_type& off_sparse_aliased(){ flag |= ~(VK_BUFFER_CREATE_SPARSE_ALIASED_BIT); return *this; }
    New_type& on_protected(){ flag |= VK_BUFFER_CREATE_PROTECTED_BIT; return *this; } 
    New_type& off_protected(){ flag |= ~(VK_BUFFER_CREATE_PROTECTED_BIT); return *this; }
    New_type& on_device_address_capture_replay_ext(){ flag |= VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT; return *this; } 
    New_type& off_device_address_capture_replay_ext(){ flag |= ~(VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_BUFFER_CREATE_SPARSE_BINDING_BIT| VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT| VK_BUFFER_CREATE_SPARSE_ALIASED_BIT| VK_BUFFER_CREATE_PROTECTED_BIT| VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT;
};
inL constexpr F_BufferCreate operator|(F_BufferCreate::Otype const b1, F_BufferCreate const b2) { return b1 | b2.flag; }
inL constexpr F_BufferCreate operator|(F_BufferCreate const b1, F_BufferCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_BufferCreate operator&(F_BufferCreate::Otype const b1, F_BufferCreate const b2) { return b1 & b2.flag; }
inL constexpr F_BufferCreate operator&(F_BufferCreate const b1, F_BufferCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkBufferCreateFlagBits> { using T = F_BufferCreate; };
struct F_ShaderStage : public E<VkShaderStageFlagBits> {
    using E::E;
    using New_type = F_ShaderStage;
    static constexpr OEtype b_vertex = VK_SHADER_STAGE_VERTEX_BIT;
    static constexpr OEtype b_tessellation_control = VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT;
    static constexpr OEtype b_tessellation_evaluation = VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT;
    static constexpr OEtype b_geometry = VK_SHADER_STAGE_GEOMETRY_BIT;
    static constexpr OEtype b_fragment = VK_SHADER_STAGE_FRAGMENT_BIT;
    static constexpr OEtype b_compute = VK_SHADER_STAGE_COMPUTE_BIT;
    static constexpr OEtype b_all_graphics = VK_SHADER_STAGE_ALL_GRAPHICS;
    static constexpr OEtype b_all = VK_SHADER_STAGE_ALL;
    static constexpr OEtype b_raygen_nv = VK_SHADER_STAGE_RAYGEN_BIT_NV;
    static constexpr OEtype b_any_hit_nv = VK_SHADER_STAGE_ANY_HIT_BIT_NV;
    static constexpr OEtype b_closest_hit_nv = VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV;
    static constexpr OEtype b_miss_nv = VK_SHADER_STAGE_MISS_BIT_NV;
    static constexpr OEtype b_intersection_nv = VK_SHADER_STAGE_INTERSECTION_BIT_NV;
    static constexpr OEtype b_callable_nv = VK_SHADER_STAGE_CALLABLE_BIT_NV;
    static constexpr OEtype b_task_nv = VK_SHADER_STAGE_TASK_BIT_NV;
    static constexpr OEtype b_mesh_nv = VK_SHADER_STAGE_MESH_BIT_NV;
    New_type& on_vertex(){ flag |= VK_SHADER_STAGE_VERTEX_BIT; return *this; } 
    New_type& off_vertex(){ flag |= ~(VK_SHADER_STAGE_VERTEX_BIT); return *this; }
    New_type& on_tessellation_control(){ flag |= VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT; return *this; } 
    New_type& off_tessellation_control(){ flag |= ~(VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT); return *this; }
    New_type& on_tessellation_evaluation(){ flag |= VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT; return *this; } 
    New_type& off_tessellation_evaluation(){ flag |= ~(VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT); return *this; }
    New_type& on_geometry(){ flag |= VK_SHADER_STAGE_GEOMETRY_BIT; return *this; } 
    New_type& off_geometry(){ flag |= ~(VK_SHADER_STAGE_GEOMETRY_BIT); return *this; }
    New_type& on_fragment(){ flag |= VK_SHADER_STAGE_FRAGMENT_BIT; return *this; } 
    New_type& off_fragment(){ flag |= ~(VK_SHADER_STAGE_FRAGMENT_BIT); return *this; }
    New_type& on_compute(){ flag |= VK_SHADER_STAGE_COMPUTE_BIT; return *this; } 
    New_type& off_compute(){ flag |= ~(VK_SHADER_STAGE_COMPUTE_BIT); return *this; }
    New_type& on_all_graphics(){ flag |= VK_SHADER_STAGE_ALL_GRAPHICS; return *this; } 
    New_type& off_all_graphics(){ flag |= ~(VK_SHADER_STAGE_ALL_GRAPHICS); return *this; }
    New_type& on_all(){ flag |= VK_SHADER_STAGE_ALL; return *this; } 
    New_type& off_all(){ flag |= ~(VK_SHADER_STAGE_ALL); return *this; }
    New_type& on_raygen_nv(){ flag |= VK_SHADER_STAGE_RAYGEN_BIT_NV; return *this; } 
    New_type& off_raygen_nv(){ flag |= ~(VK_SHADER_STAGE_RAYGEN_BIT_NV); return *this; }
    New_type& on_any_hit_nv(){ flag |= VK_SHADER_STAGE_ANY_HIT_BIT_NV; return *this; } 
    New_type& off_any_hit_nv(){ flag |= ~(VK_SHADER_STAGE_ANY_HIT_BIT_NV); return *this; }
    New_type& on_closest_hit_nv(){ flag |= VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV; return *this; } 
    New_type& off_closest_hit_nv(){ flag |= ~(VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV); return *this; }
    New_type& on_miss_nv(){ flag |= VK_SHADER_STAGE_MISS_BIT_NV; return *this; } 
    New_type& off_miss_nv(){ flag |= ~(VK_SHADER_STAGE_MISS_BIT_NV); return *this; }
    New_type& on_intersection_nv(){ flag |= VK_SHADER_STAGE_INTERSECTION_BIT_NV; return *this; } 
    New_type& off_intersection_nv(){ flag |= ~(VK_SHADER_STAGE_INTERSECTION_BIT_NV); return *this; }
    New_type& on_callable_nv(){ flag |= VK_SHADER_STAGE_CALLABLE_BIT_NV; return *this; } 
    New_type& off_callable_nv(){ flag |= ~(VK_SHADER_STAGE_CALLABLE_BIT_NV); return *this; }
    New_type& on_task_nv(){ flag |= VK_SHADER_STAGE_TASK_BIT_NV; return *this; } 
    New_type& off_task_nv(){ flag |= ~(VK_SHADER_STAGE_TASK_BIT_NV); return *this; }
    New_type& on_mesh_nv(){ flag |= VK_SHADER_STAGE_MESH_BIT_NV; return *this; } 
    New_type& off_mesh_nv(){ flag |= ~(VK_SHADER_STAGE_MESH_BIT_NV); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_SHADER_STAGE_VERTEX_BIT| VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT| VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT| VK_SHADER_STAGE_GEOMETRY_BIT| VK_SHADER_STAGE_FRAGMENT_BIT| VK_SHADER_STAGE_COMPUTE_BIT| VK_SHADER_STAGE_ALL_GRAPHICS| VK_SHADER_STAGE_ALL| VK_SHADER_STAGE_RAYGEN_BIT_NV| VK_SHADER_STAGE_ANY_HIT_BIT_NV| VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV| VK_SHADER_STAGE_MISS_BIT_NV| VK_SHADER_STAGE_INTERSECTION_BIT_NV| VK_SHADER_STAGE_CALLABLE_BIT_NV| VK_SHADER_STAGE_TASK_BIT_NV| VK_SHADER_STAGE_MESH_BIT_NV;
};
inL constexpr F_ShaderStage operator|(F_ShaderStage::Otype const b1, F_ShaderStage const b2) { return b1 | b2.flag; }
inL constexpr F_ShaderStage operator|(F_ShaderStage const b1, F_ShaderStage::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ShaderStage operator&(F_ShaderStage::Otype const b1, F_ShaderStage const b2) { return b1 & b2.flag; }
inL constexpr F_ShaderStage operator&(F_ShaderStage const b1, F_ShaderStage::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkShaderStageFlagBits> { using T = F_ShaderStage; };
struct F_ColorComponent : public E<VkColorComponentFlagBits> {
    using E::E;
    using New_type = F_ColorComponent;
    static constexpr OEtype b_r = VK_COLOR_COMPONENT_R_BIT;
    static constexpr OEtype b_g = VK_COLOR_COMPONENT_G_BIT;
    static constexpr OEtype b_b = VK_COLOR_COMPONENT_B_BIT;
    static constexpr OEtype b_a = VK_COLOR_COMPONENT_A_BIT;
    New_type& on_r(){ flag |= VK_COLOR_COMPONENT_R_BIT; return *this; } 
    New_type& off_r(){ flag |= ~(VK_COLOR_COMPONENT_R_BIT); return *this; }
    New_type& on_g(){ flag |= VK_COLOR_COMPONENT_G_BIT; return *this; } 
    New_type& off_g(){ flag |= ~(VK_COLOR_COMPONENT_G_BIT); return *this; }
    New_type& on_b(){ flag |= VK_COLOR_COMPONENT_B_BIT; return *this; } 
    New_type& off_b(){ flag |= ~(VK_COLOR_COMPONENT_B_BIT); return *this; }
    New_type& on_a(){ flag |= VK_COLOR_COMPONENT_A_BIT; return *this; } 
    New_type& off_a(){ flag |= ~(VK_COLOR_COMPONENT_A_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_COLOR_COMPONENT_R_BIT| VK_COLOR_COMPONENT_G_BIT| VK_COLOR_COMPONENT_B_BIT| VK_COLOR_COMPONENT_A_BIT;
};
inL constexpr F_ColorComponent operator|(F_ColorComponent::Otype const b1, F_ColorComponent const b2) { return b1 | b2.flag; }
inL constexpr F_ColorComponent operator|(F_ColorComponent const b1, F_ColorComponent::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ColorComponent operator&(F_ColorComponent::Otype const b1, F_ColorComponent const b2) { return b1 & b2.flag; }
inL constexpr F_ColorComponent operator&(F_ColorComponent const b1, F_ColorComponent::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkColorComponentFlagBits> { using T = F_ColorComponent; };
struct F_PipelineCreate : public E<VkPipelineCreateFlagBits> {
    using E::E;
    using New_type = F_PipelineCreate;
    static constexpr OEtype b_disable_optimization = VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT;
    static constexpr OEtype b_allow_derivatives = VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT;
    static constexpr OEtype b_derivative = VK_PIPELINE_CREATE_DERIVATIVE_BIT;
    static constexpr OEtype b_view_index_from_device_index = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT;
    static constexpr OEtype b_dispatch_base = VK_PIPELINE_CREATE_DISPATCH_BASE;
    static constexpr OEtype b_view_index_from_device_index_khr = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR;
    static constexpr OEtype b_dispatch_base_khr = VK_PIPELINE_CREATE_DISPATCH_BASE_KHR;
    static constexpr OEtype b_defer_compile_nv = VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV;
    static constexpr OEtype b_capture_statistics_khr = VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR;
    static constexpr OEtype b_capture_internal_representations_khr = VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR;
    New_type& on_disable_optimization(){ flag |= VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT; return *this; } 
    New_type& off_disable_optimization(){ flag |= ~(VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT); return *this; }
    New_type& on_allow_derivatives(){ flag |= VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT; return *this; } 
    New_type& off_allow_derivatives(){ flag |= ~(VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT); return *this; }
    New_type& on_derivative(){ flag |= VK_PIPELINE_CREATE_DERIVATIVE_BIT; return *this; } 
    New_type& off_derivative(){ flag |= ~(VK_PIPELINE_CREATE_DERIVATIVE_BIT); return *this; }
    New_type& on_view_index_from_device_index(){ flag |= VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT; return *this; } 
    New_type& off_view_index_from_device_index(){ flag |= ~(VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT); return *this; }
    New_type& on_dispatch_base(){ flag |= VK_PIPELINE_CREATE_DISPATCH_BASE; return *this; } 
    New_type& off_dispatch_base(){ flag |= ~(VK_PIPELINE_CREATE_DISPATCH_BASE); return *this; }
    New_type& on_view_index_from_device_index_khr(){ flag |= VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR; return *this; } 
    New_type& off_view_index_from_device_index_khr(){ flag |= ~(VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR); return *this; }
    New_type& on_dispatch_base_khr(){ flag |= VK_PIPELINE_CREATE_DISPATCH_BASE_KHR; return *this; } 
    New_type& off_dispatch_base_khr(){ flag |= ~(VK_PIPELINE_CREATE_DISPATCH_BASE_KHR); return *this; }
    New_type& on_defer_compile_nv(){ flag |= VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV; return *this; } 
    New_type& off_defer_compile_nv(){ flag |= ~(VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV); return *this; }
    New_type& on_capture_statistics_khr(){ flag |= VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR; return *this; } 
    New_type& off_capture_statistics_khr(){ flag |= ~(VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR); return *this; }
    New_type& on_capture_internal_representations_khr(){ flag |= VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR; return *this; } 
    New_type& off_capture_internal_representations_khr(){ flag |= ~(VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT| VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT| VK_PIPELINE_CREATE_DERIVATIVE_BIT| VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT| VK_PIPELINE_CREATE_DISPATCH_BASE| VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR| VK_PIPELINE_CREATE_DISPATCH_BASE_KHR| VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV| VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR| VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR;
};
inL constexpr F_PipelineCreate operator|(F_PipelineCreate::Otype const b1, F_PipelineCreate const b2) { return b1 | b2.flag; }
inL constexpr F_PipelineCreate operator|(F_PipelineCreate const b1, F_PipelineCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_PipelineCreate operator&(F_PipelineCreate::Otype const b1, F_PipelineCreate const b2) { return b1 & b2.flag; }
inL constexpr F_PipelineCreate operator&(F_PipelineCreate const b1, F_PipelineCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkPipelineCreateFlagBits> { using T = F_PipelineCreate; };
struct F_SubpassDescription : public E<VkSubpassDescriptionFlagBits> {
    using E::E;
    using New_type = F_SubpassDescription;
    static constexpr OEtype b_per_view_attributes_nvx = VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX;
    static constexpr OEtype b_per_view_position_x_only_nvx = VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX;
    New_type& on_per_view_attributes_nvx(){ flag |= VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX; return *this; } 
    New_type& off_per_view_attributes_nvx(){ flag |= ~(VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX); return *this; }
    New_type& on_per_view_position_x_only_nvx(){ flag |= VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX; return *this; } 
    New_type& off_per_view_position_x_only_nvx(){ flag |= ~(VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX| VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX;
};
inL constexpr F_SubpassDescription operator|(F_SubpassDescription::Otype const b1, F_SubpassDescription const b2) { return b1 | b2.flag; }
inL constexpr F_SubpassDescription operator|(F_SubpassDescription const b1, F_SubpassDescription::Otype const b2) { return b1.flag | b2; }
inL constexpr F_SubpassDescription operator&(F_SubpassDescription::Otype const b1, F_SubpassDescription const b2) { return b1 & b2.flag; }
inL constexpr F_SubpassDescription operator&(F_SubpassDescription const b1, F_SubpassDescription::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkSubpassDescriptionFlagBits> { using T = F_SubpassDescription; };
struct F_FramebufferCreate : public E<VkFramebufferCreateFlagBits> {
    using E::E;
    using New_type = F_FramebufferCreate;
    static constexpr OEtype b_imageless_khr = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR;
    New_type& on_imageless_khr(){ flag |= VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR; return *this; } 
    New_type& off_imageless_khr(){ flag |= ~(VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR;
};
inL constexpr F_FramebufferCreate operator|(F_FramebufferCreate::Otype const b1, F_FramebufferCreate const b2) { return b1 | b2.flag; }
inL constexpr F_FramebufferCreate operator|(F_FramebufferCreate const b1, F_FramebufferCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_FramebufferCreate operator&(F_FramebufferCreate::Otype const b1, F_FramebufferCreate const b2) { return b1 & b2.flag; }
inL constexpr F_FramebufferCreate operator&(F_FramebufferCreate const b1, F_FramebufferCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkFramebufferCreateFlagBits> { using T = F_FramebufferCreate; };
struct F_SparseMemoryBind : public E<VkSparseMemoryBindFlagBits> {
    using E::E;
    using New_type = F_SparseMemoryBind;
    static constexpr OEtype b_metadata = VK_SPARSE_MEMORY_BIND_METADATA_BIT;
    New_type& on_metadata(){ flag |= VK_SPARSE_MEMORY_BIND_METADATA_BIT; return *this; } 
    New_type& off_metadata(){ flag |= ~(VK_SPARSE_MEMORY_BIND_METADATA_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_SPARSE_MEMORY_BIND_METADATA_BIT;
};
inL constexpr F_SparseMemoryBind operator|(F_SparseMemoryBind::Otype const b1, F_SparseMemoryBind const b2) { return b1 | b2.flag; }
inL constexpr F_SparseMemoryBind operator|(F_SparseMemoryBind const b1, F_SparseMemoryBind::Otype const b2) { return b1.flag | b2; }
inL constexpr F_SparseMemoryBind operator&(F_SparseMemoryBind::Otype const b1, F_SparseMemoryBind const b2) { return b1 & b2.flag; }
inL constexpr F_SparseMemoryBind operator&(F_SparseMemoryBind const b1, F_SparseMemoryBind::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkSparseMemoryBindFlagBits> { using T = F_SparseMemoryBind; };
struct F_FormatFeature : public E<VkFormatFeatureFlagBits> {
    using E::E;
    using New_type = F_FormatFeature;
    static constexpr OEtype b_sampled_image = VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT;
    static constexpr OEtype b_storage_image = VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT;
    static constexpr OEtype b_storage_image_atomic = VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT;
    static constexpr OEtype b_uniform_texel_buffer = VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT;
    static constexpr OEtype b_storage_texel_buffer = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT;
    static constexpr OEtype b_storage_texel_buffer_atomic = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT;
    static constexpr OEtype b_vertex_buffer = VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT;
    static constexpr OEtype b_color_attachment = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT;
    static constexpr OEtype b_color_attachment_blend = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT;
    static constexpr OEtype b_depth_stencil_attachment = VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT;
    static constexpr OEtype b_blit_src = VK_FORMAT_FEATURE_BLIT_SRC_BIT;
    static constexpr OEtype b_blit_dst = VK_FORMAT_FEATURE_BLIT_DST_BIT;
    static constexpr OEtype b_sampled_image_filter_linear = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT;
    static constexpr OEtype b_transfer_src = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT;
    static constexpr OEtype b_transfer_dst = VK_FORMAT_FEATURE_TRANSFER_DST_BIT;
    static constexpr OEtype b_midpoint_chroma_samples = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT;
    static constexpr OEtype b_sampled_image_ycbcr_conversion_linear_filter = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT;
    static constexpr OEtype b_sampled_image_ycbcr_conversion_separate_reconstruction_filter = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT;
    static constexpr OEtype b_sampled_image_ycbcr_conversion_chroma_reconstruction_explicit = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT;
    static constexpr OEtype b_sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_forceable = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT;
    static constexpr OEtype b_disjoint = VK_FORMAT_FEATURE_DISJOINT_BIT;
    static constexpr OEtype b_cosited_chroma_samples = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT;
    static constexpr OEtype b_sampled_image_filter_cubic_img = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG;
    static constexpr OEtype b_transfer_src_khr = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR;
    static constexpr OEtype b_transfer_dst_khr = VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR;
    static constexpr OEtype b_sampled_image_filter_minmax_ext = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT;
    static constexpr OEtype b_midpoint_chroma_samples_khr = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR;
    static constexpr OEtype b_sampled_image_ycbcr_conversion_linear_filter_khr = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR;
    static constexpr OEtype b_sampled_image_ycbcr_conversion_separate_reconstruction_filter_khr = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR;
    static constexpr OEtype b_sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_khr = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR;
    static constexpr OEtype b_sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_forceable_khr = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR;
    static constexpr OEtype b_disjoint_khr = VK_FORMAT_FEATURE_DISJOINT_BIT_KHR;
    static constexpr OEtype b_cosited_chroma_samples_khr = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR;
    static constexpr OEtype b_sampled_image_filter_cubic_ext = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT;
    static constexpr OEtype b_fragment_density_map_ext = VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT;
    New_type& on_sampled_image(){ flag |= VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT; return *this; } 
    New_type& off_sampled_image(){ flag |= ~(VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT); return *this; }
    New_type& on_storage_image(){ flag |= VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT; return *this; } 
    New_type& off_storage_image(){ flag |= ~(VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT); return *this; }
    New_type& on_storage_image_atomic(){ flag |= VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT; return *this; } 
    New_type& off_storage_image_atomic(){ flag |= ~(VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT); return *this; }
    New_type& on_uniform_texel_buffer(){ flag |= VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT; return *this; } 
    New_type& off_uniform_texel_buffer(){ flag |= ~(VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT); return *this; }
    New_type& on_storage_texel_buffer(){ flag |= VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT; return *this; } 
    New_type& off_storage_texel_buffer(){ flag |= ~(VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT); return *this; }
    New_type& on_storage_texel_buffer_atomic(){ flag |= VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT; return *this; } 
    New_type& off_storage_texel_buffer_atomic(){ flag |= ~(VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT); return *this; }
    New_type& on_vertex_buffer(){ flag |= VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT; return *this; } 
    New_type& off_vertex_buffer(){ flag |= ~(VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT); return *this; }
    New_type& on_color_attachment(){ flag |= VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT; return *this; } 
    New_type& off_color_attachment(){ flag |= ~(VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT); return *this; }
    New_type& on_color_attachment_blend(){ flag |= VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT; return *this; } 
    New_type& off_color_attachment_blend(){ flag |= ~(VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT); return *this; }
    New_type& on_depth_stencil_attachment(){ flag |= VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT; return *this; } 
    New_type& off_depth_stencil_attachment(){ flag |= ~(VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT); return *this; }
    New_type& on_blit_src(){ flag |= VK_FORMAT_FEATURE_BLIT_SRC_BIT; return *this; } 
    New_type& off_blit_src(){ flag |= ~(VK_FORMAT_FEATURE_BLIT_SRC_BIT); return *this; }
    New_type& on_blit_dst(){ flag |= VK_FORMAT_FEATURE_BLIT_DST_BIT; return *this; } 
    New_type& off_blit_dst(){ flag |= ~(VK_FORMAT_FEATURE_BLIT_DST_BIT); return *this; }
    New_type& on_sampled_image_filter_linear(){ flag |= VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT; return *this; } 
    New_type& off_sampled_image_filter_linear(){ flag |= ~(VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT); return *this; }
    New_type& on_transfer_src(){ flag |= VK_FORMAT_FEATURE_TRANSFER_SRC_BIT; return *this; } 
    New_type& off_transfer_src(){ flag |= ~(VK_FORMAT_FEATURE_TRANSFER_SRC_BIT); return *this; }
    New_type& on_transfer_dst(){ flag |= VK_FORMAT_FEATURE_TRANSFER_DST_BIT; return *this; } 
    New_type& off_transfer_dst(){ flag |= ~(VK_FORMAT_FEATURE_TRANSFER_DST_BIT); return *this; }
    New_type& on_midpoint_chroma_samples(){ flag |= VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT; return *this; } 
    New_type& off_midpoint_chroma_samples(){ flag |= ~(VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT); return *this; }
    New_type& on_sampled_image_ycbcr_conversion_linear_filter(){ flag |= VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT; return *this; } 
    New_type& off_sampled_image_ycbcr_conversion_linear_filter(){ flag |= ~(VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT); return *this; }
    New_type& on_sampled_image_ycbcr_conversion_separate_reconstruction_filter(){ flag |= VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT; return *this; } 
    New_type& off_sampled_image_ycbcr_conversion_separate_reconstruction_filter(){ flag |= ~(VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT); return *this; }
    New_type& on_sampled_image_ycbcr_conversion_chroma_reconstruction_explicit(){ flag |= VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT; return *this; } 
    New_type& off_sampled_image_ycbcr_conversion_chroma_reconstruction_explicit(){ flag |= ~(VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT); return *this; }
    New_type& on_sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_forceable(){ flag |= VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT; return *this; } 
    New_type& off_sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_forceable(){ flag |= ~(VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT); return *this; }
    New_type& on_disjoint(){ flag |= VK_FORMAT_FEATURE_DISJOINT_BIT; return *this; } 
    New_type& off_disjoint(){ flag |= ~(VK_FORMAT_FEATURE_DISJOINT_BIT); return *this; }
    New_type& on_cosited_chroma_samples(){ flag |= VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT; return *this; } 
    New_type& off_cosited_chroma_samples(){ flag |= ~(VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT); return *this; }
    New_type& on_sampled_image_filter_cubic_img(){ flag |= VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG; return *this; } 
    New_type& off_sampled_image_filter_cubic_img(){ flag |= ~(VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG); return *this; }
    New_type& on_transfer_src_khr(){ flag |= VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR; return *this; } 
    New_type& off_transfer_src_khr(){ flag |= ~(VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR); return *this; }
    New_type& on_transfer_dst_khr(){ flag |= VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR; return *this; } 
    New_type& off_transfer_dst_khr(){ flag |= ~(VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR); return *this; }
    New_type& on_sampled_image_filter_minmax_ext(){ flag |= VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT; return *this; } 
    New_type& off_sampled_image_filter_minmax_ext(){ flag |= ~(VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT); return *this; }
    New_type& on_midpoint_chroma_samples_khr(){ flag |= VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR; return *this; } 
    New_type& off_midpoint_chroma_samples_khr(){ flag |= ~(VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR); return *this; }
    New_type& on_sampled_image_ycbcr_conversion_linear_filter_khr(){ flag |= VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR; return *this; } 
    New_type& off_sampled_image_ycbcr_conversion_linear_filter_khr(){ flag |= ~(VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR); return *this; }
    New_type& on_sampled_image_ycbcr_conversion_separate_reconstruction_filter_khr(){ flag |= VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR; return *this; } 
    New_type& off_sampled_image_ycbcr_conversion_separate_reconstruction_filter_khr(){ flag |= ~(VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR); return *this; }
    New_type& on_sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_khr(){ flag |= VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR; return *this; } 
    New_type& off_sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_khr(){ flag |= ~(VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR); return *this; }
    New_type& on_sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_forceable_khr(){ flag |= VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR; return *this; } 
    New_type& off_sampled_image_ycbcr_conversion_chroma_reconstruction_explicit_forceable_khr(){ flag |= ~(VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR); return *this; }
    New_type& on_disjoint_khr(){ flag |= VK_FORMAT_FEATURE_DISJOINT_BIT_KHR; return *this; } 
    New_type& off_disjoint_khr(){ flag |= ~(VK_FORMAT_FEATURE_DISJOINT_BIT_KHR); return *this; }
    New_type& on_cosited_chroma_samples_khr(){ flag |= VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR; return *this; } 
    New_type& off_cosited_chroma_samples_khr(){ flag |= ~(VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR); return *this; }
    New_type& on_sampled_image_filter_cubic_ext(){ flag |= VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT; return *this; } 
    New_type& off_sampled_image_filter_cubic_ext(){ flag |= ~(VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT); return *this; }
    New_type& on_fragment_density_map_ext(){ flag |= VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT; return *this; } 
    New_type& off_fragment_density_map_ext(){ flag |= ~(VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT| VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT| VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT| VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT| VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT| VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT| VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT| VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT| VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT| VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT| VK_FORMAT_FEATURE_BLIT_SRC_BIT| VK_FORMAT_FEATURE_BLIT_DST_BIT| VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT| VK_FORMAT_FEATURE_TRANSFER_SRC_BIT| VK_FORMAT_FEATURE_TRANSFER_DST_BIT| VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT| VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT| VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT| VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT| VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT| VK_FORMAT_FEATURE_DISJOINT_BIT| VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT| VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG| VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR| VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR| VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT| VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR| VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR| VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR| VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR| VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR| VK_FORMAT_FEATURE_DISJOINT_BIT_KHR| VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR| VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT| VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT;
};
inL constexpr F_FormatFeature operator|(F_FormatFeature::Otype const b1, F_FormatFeature const b2) { return b1 | b2.flag; }
inL constexpr F_FormatFeature operator|(F_FormatFeature const b1, F_FormatFeature::Otype const b2) { return b1.flag | b2; }
inL constexpr F_FormatFeature operator&(F_FormatFeature::Otype const b1, F_FormatFeature const b2) { return b1 & b2.flag; }
inL constexpr F_FormatFeature operator&(F_FormatFeature const b1, F_FormatFeature::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkFormatFeatureFlagBits> { using T = F_FormatFeature; };
struct F_QueryPipelineStatistic : public E<VkQueryPipelineStatisticFlagBits> {
    using E::E;
    using New_type = F_QueryPipelineStatistic;
    static constexpr OEtype b_input_assembly_vertices = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT;
    static constexpr OEtype b_input_assembly_primitives = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT;
    static constexpr OEtype b_vertex_shader_invocations = VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT;
    static constexpr OEtype b_geometry_shader_invocations = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT;
    static constexpr OEtype b_geometry_shader_primitives = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT;
    static constexpr OEtype b_clipping_invocations = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT;
    static constexpr OEtype b_clipping_primitives = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT;
    static constexpr OEtype b_fragment_shader_invocations = VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT;
    static constexpr OEtype b_tessellation_control_shader_patches = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT;
    static constexpr OEtype b_tessellation_evaluation_shader_invocations = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT;
    static constexpr OEtype b_compute_shader_invocations = VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT;
    New_type& on_input_assembly_vertices(){ flag |= VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT; return *this; } 
    New_type& off_input_assembly_vertices(){ flag |= ~(VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT); return *this; }
    New_type& on_input_assembly_primitives(){ flag |= VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT; return *this; } 
    New_type& off_input_assembly_primitives(){ flag |= ~(VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT); return *this; }
    New_type& on_vertex_shader_invocations(){ flag |= VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT; return *this; } 
    New_type& off_vertex_shader_invocations(){ flag |= ~(VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT); return *this; }
    New_type& on_geometry_shader_invocations(){ flag |= VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT; return *this; } 
    New_type& off_geometry_shader_invocations(){ flag |= ~(VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT); return *this; }
    New_type& on_geometry_shader_primitives(){ flag |= VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT; return *this; } 
    New_type& off_geometry_shader_primitives(){ flag |= ~(VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT); return *this; }
    New_type& on_clipping_invocations(){ flag |= VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT; return *this; } 
    New_type& off_clipping_invocations(){ flag |= ~(VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT); return *this; }
    New_type& on_clipping_primitives(){ flag |= VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT; return *this; } 
    New_type& off_clipping_primitives(){ flag |= ~(VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT); return *this; }
    New_type& on_fragment_shader_invocations(){ flag |= VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT; return *this; } 
    New_type& off_fragment_shader_invocations(){ flag |= ~(VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT); return *this; }
    New_type& on_tessellation_control_shader_patches(){ flag |= VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT; return *this; } 
    New_type& off_tessellation_control_shader_patches(){ flag |= ~(VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT); return *this; }
    New_type& on_tessellation_evaluation_shader_invocations(){ flag |= VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT; return *this; } 
    New_type& off_tessellation_evaluation_shader_invocations(){ flag |= ~(VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT); return *this; }
    New_type& on_compute_shader_invocations(){ flag |= VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT; return *this; } 
    New_type& off_compute_shader_invocations(){ flag |= ~(VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT| VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT| VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT| VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT| VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT| VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT| VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT| VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT| VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT| VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT| VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT;
};
inL constexpr F_QueryPipelineStatistic operator|(F_QueryPipelineStatistic::Otype const b1, F_QueryPipelineStatistic const b2) { return b1 | b2.flag; }
inL constexpr F_QueryPipelineStatistic operator|(F_QueryPipelineStatistic const b1, F_QueryPipelineStatistic::Otype const b2) { return b1.flag | b2; }
inL constexpr F_QueryPipelineStatistic operator&(F_QueryPipelineStatistic::Otype const b1, F_QueryPipelineStatistic const b2) { return b1 & b2.flag; }
inL constexpr F_QueryPipelineStatistic operator&(F_QueryPipelineStatistic const b1, F_QueryPipelineStatistic::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkQueryPipelineStatisticFlagBits> { using T = F_QueryPipelineStatistic; };
struct F_SurfaceTransformKHR : public E<VkSurfaceTransformFlagBitsKHR> {
    using E::E;
    using New_type = F_SurfaceTransformKHR;
    static constexpr OEtype b_identity_khr = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;
    static constexpr OEtype b_rotate_90_khr = VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR;
    static constexpr OEtype b_rotate_180_khr = VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR;
    static constexpr OEtype b_rotate_270_khr = VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR;
    static constexpr OEtype b_horizontal_mirror_khr = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR;
    static constexpr OEtype b_horizontal_mirror_rotate_90_khr = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR;
    static constexpr OEtype b_horizontal_mirror_rotate_180_khr = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR;
    static constexpr OEtype b_horizontal_mirror_rotate_270_khr = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR;
    static constexpr OEtype b_inherit_khr = VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR;
    New_type& on_identity_khr(){ flag |= VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR; return *this; } 
    New_type& off_identity_khr(){ flag |= ~(VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR); return *this; }
    New_type& on_rotate_90_khr(){ flag |= VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR; return *this; } 
    New_type& off_rotate_90_khr(){ flag |= ~(VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR); return *this; }
    New_type& on_rotate_180_khr(){ flag |= VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR; return *this; } 
    New_type& off_rotate_180_khr(){ flag |= ~(VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR); return *this; }
    New_type& on_rotate_270_khr(){ flag |= VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR; return *this; } 
    New_type& off_rotate_270_khr(){ flag |= ~(VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR); return *this; }
    New_type& on_horizontal_mirror_khr(){ flag |= VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR; return *this; } 
    New_type& off_horizontal_mirror_khr(){ flag |= ~(VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR); return *this; }
    New_type& on_horizontal_mirror_rotate_90_khr(){ flag |= VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR; return *this; } 
    New_type& off_horizontal_mirror_rotate_90_khr(){ flag |= ~(VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR); return *this; }
    New_type& on_horizontal_mirror_rotate_180_khr(){ flag |= VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR; return *this; } 
    New_type& off_horizontal_mirror_rotate_180_khr(){ flag |= ~(VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR); return *this; }
    New_type& on_horizontal_mirror_rotate_270_khr(){ flag |= VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR; return *this; } 
    New_type& off_horizontal_mirror_rotate_270_khr(){ flag |= ~(VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR); return *this; }
    New_type& on_inherit_khr(){ flag |= VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR; return *this; } 
    New_type& off_inherit_khr(){ flag |= ~(VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR| VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR| VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR| VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR| VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR| VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR| VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR| VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR| VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR;
};
inL constexpr F_SurfaceTransformKHR operator|(F_SurfaceTransformKHR::Otype const b1, F_SurfaceTransformKHR const b2) { return b1 | b2.flag; }
inL constexpr F_SurfaceTransformKHR operator|(F_SurfaceTransformKHR const b1, F_SurfaceTransformKHR::Otype const b2) { return b1.flag | b2; }
inL constexpr F_SurfaceTransformKHR operator&(F_SurfaceTransformKHR::Otype const b1, F_SurfaceTransformKHR const b2) { return b1 & b2.flag; }
inL constexpr F_SurfaceTransformKHR operator&(F_SurfaceTransformKHR const b1, F_SurfaceTransformKHR::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkSurfaceTransformFlagBitsKHR> { using T = F_SurfaceTransformKHR; };
struct F_ImageUsage : public E<VkImageUsageFlagBits> {
    using E::E;
    using New_type = F_ImageUsage;
    static constexpr OEtype b_transfer_src = VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
    static constexpr OEtype b_transfer_dst = VK_IMAGE_USAGE_TRANSFER_DST_BIT;
    static constexpr OEtype b_sampled = VK_IMAGE_USAGE_SAMPLED_BIT;
    static constexpr OEtype b_storage = VK_IMAGE_USAGE_STORAGE_BIT;
    static constexpr OEtype b_color_attachment = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
    static constexpr OEtype b_depth_stencil_attachment = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT;
    static constexpr OEtype b_transient_attachment = VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT;
    static constexpr OEtype b_input_attachment = VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT;
    static constexpr OEtype b_shading_rate_image_nv = VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV;
    static constexpr OEtype b_fragment_density_map_ext = VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT;
    New_type& on_transfer_src(){ flag |= VK_IMAGE_USAGE_TRANSFER_SRC_BIT; return *this; } 
    New_type& off_transfer_src(){ flag |= ~(VK_IMAGE_USAGE_TRANSFER_SRC_BIT); return *this; }
    New_type& on_transfer_dst(){ flag |= VK_IMAGE_USAGE_TRANSFER_DST_BIT; return *this; } 
    New_type& off_transfer_dst(){ flag |= ~(VK_IMAGE_USAGE_TRANSFER_DST_BIT); return *this; }
    New_type& on_sampled(){ flag |= VK_IMAGE_USAGE_SAMPLED_BIT; return *this; } 
    New_type& off_sampled(){ flag |= ~(VK_IMAGE_USAGE_SAMPLED_BIT); return *this; }
    New_type& on_storage(){ flag |= VK_IMAGE_USAGE_STORAGE_BIT; return *this; } 
    New_type& off_storage(){ flag |= ~(VK_IMAGE_USAGE_STORAGE_BIT); return *this; }
    New_type& on_color_attachment(){ flag |= VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; return *this; } 
    New_type& off_color_attachment(){ flag |= ~(VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT); return *this; }
    New_type& on_depth_stencil_attachment(){ flag |= VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT; return *this; } 
    New_type& off_depth_stencil_attachment(){ flag |= ~(VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT); return *this; }
    New_type& on_transient_attachment(){ flag |= VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT; return *this; } 
    New_type& off_transient_attachment(){ flag |= ~(VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT); return *this; }
    New_type& on_input_attachment(){ flag |= VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT; return *this; } 
    New_type& off_input_attachment(){ flag |= ~(VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT); return *this; }
    New_type& on_shading_rate_image_nv(){ flag |= VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV; return *this; } 
    New_type& off_shading_rate_image_nv(){ flag |= ~(VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV); return *this; }
    New_type& on_fragment_density_map_ext(){ flag |= VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT; return *this; } 
    New_type& off_fragment_density_map_ext(){ flag |= ~(VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_IMAGE_USAGE_TRANSFER_SRC_BIT| VK_IMAGE_USAGE_TRANSFER_DST_BIT| VK_IMAGE_USAGE_SAMPLED_BIT| VK_IMAGE_USAGE_STORAGE_BIT| VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT| VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT| VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT| VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT| VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV| VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT;
};
inL constexpr F_ImageUsage operator|(F_ImageUsage::Otype const b1, F_ImageUsage const b2) { return b1 | b2.flag; }
inL constexpr F_ImageUsage operator|(F_ImageUsage const b1, F_ImageUsage::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ImageUsage operator&(F_ImageUsage::Otype const b1, F_ImageUsage const b2) { return b1 & b2.flag; }
inL constexpr F_ImageUsage operator&(F_ImageUsage const b1, F_ImageUsage::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkImageUsageFlagBits> { using T = F_ImageUsage; };
struct F_DebugUtilsMessageSeverityEXT : public E<VkDebugUtilsMessageSeverityFlagBitsEXT> {
    using E::E;
    using New_type = F_DebugUtilsMessageSeverityEXT;
    static constexpr OEtype b_verbose_ext = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT;
    static constexpr OEtype b_info_ext = VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT;
    static constexpr OEtype b_warning_ext = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT;
    static constexpr OEtype b_error_ext = VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
    New_type& on_verbose_ext(){ flag |= VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT; return *this; } 
    New_type& off_verbose_ext(){ flag |= ~(VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT); return *this; }
    New_type& on_info_ext(){ flag |= VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT; return *this; } 
    New_type& off_info_ext(){ flag |= ~(VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT); return *this; }
    New_type& on_warning_ext(){ flag |= VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT; return *this; } 
    New_type& off_warning_ext(){ flag |= ~(VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT); return *this; }
    New_type& on_error_ext(){ flag |= VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT; return *this; } 
    New_type& off_error_ext(){ flag |= ~(VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT| VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT| VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT| VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
};
inL constexpr F_DebugUtilsMessageSeverityEXT operator|(F_DebugUtilsMessageSeverityEXT::Otype const b1, F_DebugUtilsMessageSeverityEXT const b2) { return b1 | b2.flag; }
inL constexpr F_DebugUtilsMessageSeverityEXT operator|(F_DebugUtilsMessageSeverityEXT const b1, F_DebugUtilsMessageSeverityEXT::Otype const b2) { return b1.flag | b2; }
inL constexpr F_DebugUtilsMessageSeverityEXT operator&(F_DebugUtilsMessageSeverityEXT::Otype const b1, F_DebugUtilsMessageSeverityEXT const b2) { return b1 & b2.flag; }
inL constexpr F_DebugUtilsMessageSeverityEXT operator&(F_DebugUtilsMessageSeverityEXT const b1, F_DebugUtilsMessageSeverityEXT::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkDebugUtilsMessageSeverityFlagBitsEXT> { using T = F_DebugUtilsMessageSeverityEXT; };
struct F_SurfaceCounterEXT : public E<VkSurfaceCounterFlagBitsEXT> {
    using E::E;
    using New_type = F_SurfaceCounterEXT;
    static constexpr OEtype b_vblank_ext = VK_SURFACE_COUNTER_VBLANK_EXT;
    New_type& on_vblank_ext(){ flag |= VK_SURFACE_COUNTER_VBLANK_EXT; return *this; } 
    New_type& off_vblank_ext(){ flag |= ~(VK_SURFACE_COUNTER_VBLANK_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_SURFACE_COUNTER_VBLANK_EXT;
};
inL constexpr F_SurfaceCounterEXT operator|(F_SurfaceCounterEXT::Otype const b1, F_SurfaceCounterEXT const b2) { return b1 | b2.flag; }
inL constexpr F_SurfaceCounterEXT operator|(F_SurfaceCounterEXT const b1, F_SurfaceCounterEXT::Otype const b2) { return b1.flag | b2; }
inL constexpr F_SurfaceCounterEXT operator&(F_SurfaceCounterEXT::Otype const b1, F_SurfaceCounterEXT const b2) { return b1 & b2.flag; }
inL constexpr F_SurfaceCounterEXT operator&(F_SurfaceCounterEXT const b1, F_SurfaceCounterEXT::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkSurfaceCounterFlagBitsEXT> { using T = F_SurfaceCounterEXT; };
struct F_SubgroupFeature : public E<VkSubgroupFeatureFlagBits> {
    using E::E;
    using New_type = F_SubgroupFeature;
    static constexpr OEtype b_basic = VK_SUBGROUP_FEATURE_BASIC_BIT;
    static constexpr OEtype b_vote = VK_SUBGROUP_FEATURE_VOTE_BIT;
    static constexpr OEtype b_arithmetic = VK_SUBGROUP_FEATURE_ARITHMETIC_BIT;
    static constexpr OEtype b_ballot = VK_SUBGROUP_FEATURE_BALLOT_BIT;
    static constexpr OEtype b_shuffle = VK_SUBGROUP_FEATURE_SHUFFLE_BIT;
    static constexpr OEtype b_shuffle_relative = VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT;
    static constexpr OEtype b_clustered = VK_SUBGROUP_FEATURE_CLUSTERED_BIT;
    static constexpr OEtype b_quad = VK_SUBGROUP_FEATURE_QUAD_BIT;
    static constexpr OEtype b_partitioned_nv = VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV;
    New_type& on_basic(){ flag |= VK_SUBGROUP_FEATURE_BASIC_BIT; return *this; } 
    New_type& off_basic(){ flag |= ~(VK_SUBGROUP_FEATURE_BASIC_BIT); return *this; }
    New_type& on_vote(){ flag |= VK_SUBGROUP_FEATURE_VOTE_BIT; return *this; } 
    New_type& off_vote(){ flag |= ~(VK_SUBGROUP_FEATURE_VOTE_BIT); return *this; }
    New_type& on_arithmetic(){ flag |= VK_SUBGROUP_FEATURE_ARITHMETIC_BIT; return *this; } 
    New_type& off_arithmetic(){ flag |= ~(VK_SUBGROUP_FEATURE_ARITHMETIC_BIT); return *this; }
    New_type& on_ballot(){ flag |= VK_SUBGROUP_FEATURE_BALLOT_BIT; return *this; } 
    New_type& off_ballot(){ flag |= ~(VK_SUBGROUP_FEATURE_BALLOT_BIT); return *this; }
    New_type& on_shuffle(){ flag |= VK_SUBGROUP_FEATURE_SHUFFLE_BIT; return *this; } 
    New_type& off_shuffle(){ flag |= ~(VK_SUBGROUP_FEATURE_SHUFFLE_BIT); return *this; }
    New_type& on_shuffle_relative(){ flag |= VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT; return *this; } 
    New_type& off_shuffle_relative(){ flag |= ~(VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT); return *this; }
    New_type& on_clustered(){ flag |= VK_SUBGROUP_FEATURE_CLUSTERED_BIT; return *this; } 
    New_type& off_clustered(){ flag |= ~(VK_SUBGROUP_FEATURE_CLUSTERED_BIT); return *this; }
    New_type& on_quad(){ flag |= VK_SUBGROUP_FEATURE_QUAD_BIT; return *this; } 
    New_type& off_quad(){ flag |= ~(VK_SUBGROUP_FEATURE_QUAD_BIT); return *this; }
    New_type& on_partitioned_nv(){ flag |= VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV; return *this; } 
    New_type& off_partitioned_nv(){ flag |= ~(VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_SUBGROUP_FEATURE_BASIC_BIT| VK_SUBGROUP_FEATURE_VOTE_BIT| VK_SUBGROUP_FEATURE_ARITHMETIC_BIT| VK_SUBGROUP_FEATURE_BALLOT_BIT| VK_SUBGROUP_FEATURE_SHUFFLE_BIT| VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT| VK_SUBGROUP_FEATURE_CLUSTERED_BIT| VK_SUBGROUP_FEATURE_QUAD_BIT| VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV;
};
inL constexpr F_SubgroupFeature operator|(F_SubgroupFeature::Otype const b1, F_SubgroupFeature const b2) { return b1 | b2.flag; }
inL constexpr F_SubgroupFeature operator|(F_SubgroupFeature const b1, F_SubgroupFeature::Otype const b2) { return b1.flag | b2; }
inL constexpr F_SubgroupFeature operator&(F_SubgroupFeature::Otype const b1, F_SubgroupFeature const b2) { return b1 & b2.flag; }
inL constexpr F_SubgroupFeature operator&(F_SubgroupFeature const b1, F_SubgroupFeature::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkSubgroupFeatureFlagBits> { using T = F_SubgroupFeature; };
struct F_SemaphoreImport : public E<VkSemaphoreImportFlagBits> {
    using E::E;
    using New_type = F_SemaphoreImport;
    static constexpr OEtype b_temporary = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
    static constexpr OEtype b_temporary_khr = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR;
    New_type& on_temporary(){ flag |= VK_SEMAPHORE_IMPORT_TEMPORARY_BIT; return *this; } 
    New_type& off_temporary(){ flag |= ~(VK_SEMAPHORE_IMPORT_TEMPORARY_BIT); return *this; }
    New_type& on_temporary_khr(){ flag |= VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR; return *this; } 
    New_type& off_temporary_khr(){ flag |= ~(VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_SEMAPHORE_IMPORT_TEMPORARY_BIT| VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR;
};
inL constexpr F_SemaphoreImport operator|(F_SemaphoreImport::Otype const b1, F_SemaphoreImport const b2) { return b1 | b2.flag; }
inL constexpr F_SemaphoreImport operator|(F_SemaphoreImport const b1, F_SemaphoreImport::Otype const b2) { return b1.flag | b2; }
inL constexpr F_SemaphoreImport operator&(F_SemaphoreImport::Otype const b1, F_SemaphoreImport const b2) { return b1 & b2.flag; }
inL constexpr F_SemaphoreImport operator&(F_SemaphoreImport const b1, F_SemaphoreImport::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkSemaphoreImportFlagBits> { using T = F_SemaphoreImport; };
struct F_MemoryAllocate : public E<VkMemoryAllocateFlagBits> {
    using E::E;
    using New_type = F_MemoryAllocate;
    static constexpr OEtype b_device_mask = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT;
    static constexpr OEtype b_device_mask_khr = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR;
    New_type& on_device_mask(){ flag |= VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT; return *this; } 
    New_type& off_device_mask(){ flag |= ~(VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT); return *this; }
    New_type& on_device_mask_khr(){ flag |= VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR; return *this; } 
    New_type& off_device_mask_khr(){ flag |= ~(VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT| VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR;
};
inL constexpr F_MemoryAllocate operator|(F_MemoryAllocate::Otype const b1, F_MemoryAllocate const b2) { return b1 | b2.flag; }
inL constexpr F_MemoryAllocate operator|(F_MemoryAllocate const b1, F_MemoryAllocate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_MemoryAllocate operator&(F_MemoryAllocate::Otype const b1, F_MemoryAllocate const b2) { return b1 & b2.flag; }
inL constexpr F_MemoryAllocate operator&(F_MemoryAllocate const b1, F_MemoryAllocate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkMemoryAllocateFlagBits> { using T = F_MemoryAllocate; };
struct F_CullMode : public E<VkCullModeFlagBits> {
    using E::E;
    using New_type = F_CullMode;
    static constexpr OEtype b_none = VK_CULL_MODE_NONE;
    static constexpr OEtype b_front = VK_CULL_MODE_FRONT_BIT;
    static constexpr OEtype b_back = VK_CULL_MODE_BACK_BIT;
    static constexpr OEtype b_front_and_back = VK_CULL_MODE_FRONT_AND_BACK;
    New_type& on_none(){ flag |= VK_CULL_MODE_NONE; return *this; } 
    New_type& off_none(){ flag |= ~(VK_CULL_MODE_NONE); return *this; }
    New_type& on_front(){ flag |= VK_CULL_MODE_FRONT_BIT; return *this; } 
    New_type& off_front(){ flag |= ~(VK_CULL_MODE_FRONT_BIT); return *this; }
    New_type& on_back(){ flag |= VK_CULL_MODE_BACK_BIT; return *this; } 
    New_type& off_back(){ flag |= ~(VK_CULL_MODE_BACK_BIT); return *this; }
    New_type& on_front_and_back(){ flag |= VK_CULL_MODE_FRONT_AND_BACK; return *this; } 
    New_type& off_front_and_back(){ flag |= ~(VK_CULL_MODE_FRONT_AND_BACK); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_CULL_MODE_NONE| VK_CULL_MODE_FRONT_BIT| VK_CULL_MODE_BACK_BIT| VK_CULL_MODE_FRONT_AND_BACK;
};
inL constexpr F_CullMode operator|(F_CullMode::Otype const b1, F_CullMode const b2) { return b1 | b2.flag; }
inL constexpr F_CullMode operator|(F_CullMode const b1, F_CullMode::Otype const b2) { return b1.flag | b2; }
inL constexpr F_CullMode operator&(F_CullMode::Otype const b1, F_CullMode const b2) { return b1 & b2.flag; }
inL constexpr F_CullMode operator&(F_CullMode const b1, F_CullMode::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkCullModeFlagBits> { using T = F_CullMode; };
struct F_StencilFace : public E<VkStencilFaceFlagBits> {
    using E::E;
    using New_type = F_StencilFace;
    static constexpr OEtype b_front = VK_STENCIL_FACE_FRONT_BIT;
    static constexpr OEtype b_back = VK_STENCIL_FACE_BACK_BIT;
    static constexpr OEtype b_front_and_back = VK_STENCIL_FACE_FRONT_AND_BACK;
    static constexpr OEtype b_k_stencil_front_and_back = VK_STENCIL_FRONT_AND_BACK;
    New_type& on_front(){ flag |= VK_STENCIL_FACE_FRONT_BIT; return *this; } 
    New_type& off_front(){ flag |= ~(VK_STENCIL_FACE_FRONT_BIT); return *this; }
    New_type& on_back(){ flag |= VK_STENCIL_FACE_BACK_BIT; return *this; } 
    New_type& off_back(){ flag |= ~(VK_STENCIL_FACE_BACK_BIT); return *this; }
    New_type& on_front_and_back(){ flag |= VK_STENCIL_FACE_FRONT_AND_BACK; return *this; } 
    New_type& off_front_and_back(){ flag |= ~(VK_STENCIL_FACE_FRONT_AND_BACK); return *this; }
    New_type& on_k_stencil_front_and_back(){ flag |= VK_STENCIL_FRONT_AND_BACK; return *this; } 
    New_type& off_k_stencil_front_and_back(){ flag |= ~(VK_STENCIL_FRONT_AND_BACK); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_STENCIL_FACE_FRONT_BIT| VK_STENCIL_FACE_BACK_BIT| VK_STENCIL_FACE_FRONT_AND_BACK| VK_STENCIL_FRONT_AND_BACK;
};
inL constexpr F_StencilFace operator|(F_StencilFace::Otype const b1, F_StencilFace const b2) { return b1 | b2.flag; }
inL constexpr F_StencilFace operator|(F_StencilFace const b1, F_StencilFace::Otype const b2) { return b1.flag | b2; }
inL constexpr F_StencilFace operator&(F_StencilFace::Otype const b1, F_StencilFace const b2) { return b1 & b2.flag; }
inL constexpr F_StencilFace operator&(F_StencilFace const b1, F_StencilFace::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkStencilFaceFlagBits> { using T = F_StencilFace; };
struct F_Access : public E<VkAccessFlagBits> {
    using E::E;
    using New_type = F_Access;
    static constexpr OEtype b_indirect_command_read = VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
    static constexpr OEtype b_index_read = VK_ACCESS_INDEX_READ_BIT;
    static constexpr OEtype b_vertex_attribute_read = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT;
    static constexpr OEtype b_uniform_read = VK_ACCESS_UNIFORM_READ_BIT;
    static constexpr OEtype b_input_attachment_read = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT;
    static constexpr OEtype b_shader_read = VK_ACCESS_SHADER_READ_BIT;
    static constexpr OEtype b_shader_write = VK_ACCESS_SHADER_WRITE_BIT;
    static constexpr OEtype b_color_attachment_read = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT;
    static constexpr OEtype b_color_attachment_write = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
    static constexpr OEtype b_depth_stencil_attachment_read = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT;
    static constexpr OEtype b_depth_stencil_attachment_write = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
    static constexpr OEtype b_transfer_read = VK_ACCESS_TRANSFER_READ_BIT;
    static constexpr OEtype b_transfer_write = VK_ACCESS_TRANSFER_WRITE_BIT;
    static constexpr OEtype b_host_read = VK_ACCESS_HOST_READ_BIT;
    static constexpr OEtype b_host_write = VK_ACCESS_HOST_WRITE_BIT;
    static constexpr OEtype b_memory_read = VK_ACCESS_MEMORY_READ_BIT;
    static constexpr OEtype b_memory_write = VK_ACCESS_MEMORY_WRITE_BIT;
    static constexpr OEtype b_transform_feedback_write_ext = VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT;
    static constexpr OEtype b_transform_feedback_counter_read_ext = VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT;
    static constexpr OEtype b_transform_feedback_counter_write_ext = VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT;
    static constexpr OEtype b_conditional_rendering_read_ext = VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT;
    static constexpr OEtype b_command_process_read_nvx = VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX;
    static constexpr OEtype b_command_process_write_nvx = VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX;
    static constexpr OEtype b_color_attachment_read_noncoherent_ext = VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT;
    static constexpr OEtype b_shading_rate_image_read_nv = VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV;
    static constexpr OEtype b_acceleration_structure_read_nv = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV;
    static constexpr OEtype b_acceleration_structure_write_nv = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV;
    static constexpr OEtype b_fragment_density_map_read_ext = VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT;
    New_type& on_indirect_command_read(){ flag |= VK_ACCESS_INDIRECT_COMMAND_READ_BIT; return *this; } 
    New_type& off_indirect_command_read(){ flag |= ~(VK_ACCESS_INDIRECT_COMMAND_READ_BIT); return *this; }
    New_type& on_index_read(){ flag |= VK_ACCESS_INDEX_READ_BIT; return *this; } 
    New_type& off_index_read(){ flag |= ~(VK_ACCESS_INDEX_READ_BIT); return *this; }
    New_type& on_vertex_attribute_read(){ flag |= VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT; return *this; } 
    New_type& off_vertex_attribute_read(){ flag |= ~(VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT); return *this; }
    New_type& on_uniform_read(){ flag |= VK_ACCESS_UNIFORM_READ_BIT; return *this; } 
    New_type& off_uniform_read(){ flag |= ~(VK_ACCESS_UNIFORM_READ_BIT); return *this; }
    New_type& on_input_attachment_read(){ flag |= VK_ACCESS_INPUT_ATTACHMENT_READ_BIT; return *this; } 
    New_type& off_input_attachment_read(){ flag |= ~(VK_ACCESS_INPUT_ATTACHMENT_READ_BIT); return *this; }
    New_type& on_shader_read(){ flag |= VK_ACCESS_SHADER_READ_BIT; return *this; } 
    New_type& off_shader_read(){ flag |= ~(VK_ACCESS_SHADER_READ_BIT); return *this; }
    New_type& on_shader_write(){ flag |= VK_ACCESS_SHADER_WRITE_BIT; return *this; } 
    New_type& off_shader_write(){ flag |= ~(VK_ACCESS_SHADER_WRITE_BIT); return *this; }
    New_type& on_color_attachment_read(){ flag |= VK_ACCESS_COLOR_ATTACHMENT_READ_BIT; return *this; } 
    New_type& off_color_attachment_read(){ flag |= ~(VK_ACCESS_COLOR_ATTACHMENT_READ_BIT); return *this; }
    New_type& on_color_attachment_write(){ flag |= VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; return *this; } 
    New_type& off_color_attachment_write(){ flag |= ~(VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT); return *this; }
    New_type& on_depth_stencil_attachment_read(){ flag |= VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT; return *this; } 
    New_type& off_depth_stencil_attachment_read(){ flag |= ~(VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT); return *this; }
    New_type& on_depth_stencil_attachment_write(){ flag |= VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT; return *this; } 
    New_type& off_depth_stencil_attachment_write(){ flag |= ~(VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT); return *this; }
    New_type& on_transfer_read(){ flag |= VK_ACCESS_TRANSFER_READ_BIT; return *this; } 
    New_type& off_transfer_read(){ flag |= ~(VK_ACCESS_TRANSFER_READ_BIT); return *this; }
    New_type& on_transfer_write(){ flag |= VK_ACCESS_TRANSFER_WRITE_BIT; return *this; } 
    New_type& off_transfer_write(){ flag |= ~(VK_ACCESS_TRANSFER_WRITE_BIT); return *this; }
    New_type& on_host_read(){ flag |= VK_ACCESS_HOST_READ_BIT; return *this; } 
    New_type& off_host_read(){ flag |= ~(VK_ACCESS_HOST_READ_BIT); return *this; }
    New_type& on_host_write(){ flag |= VK_ACCESS_HOST_WRITE_BIT; return *this; } 
    New_type& off_host_write(){ flag |= ~(VK_ACCESS_HOST_WRITE_BIT); return *this; }
    New_type& on_memory_read(){ flag |= VK_ACCESS_MEMORY_READ_BIT; return *this; } 
    New_type& off_memory_read(){ flag |= ~(VK_ACCESS_MEMORY_READ_BIT); return *this; }
    New_type& on_memory_write(){ flag |= VK_ACCESS_MEMORY_WRITE_BIT; return *this; } 
    New_type& off_memory_write(){ flag |= ~(VK_ACCESS_MEMORY_WRITE_BIT); return *this; }
    New_type& on_transform_feedback_write_ext(){ flag |= VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT; return *this; } 
    New_type& off_transform_feedback_write_ext(){ flag |= ~(VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT); return *this; }
    New_type& on_transform_feedback_counter_read_ext(){ flag |= VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT; return *this; } 
    New_type& off_transform_feedback_counter_read_ext(){ flag |= ~(VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT); return *this; }
    New_type& on_transform_feedback_counter_write_ext(){ flag |= VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT; return *this; } 
    New_type& off_transform_feedback_counter_write_ext(){ flag |= ~(VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT); return *this; }
    New_type& on_conditional_rendering_read_ext(){ flag |= VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT; return *this; } 
    New_type& off_conditional_rendering_read_ext(){ flag |= ~(VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT); return *this; }
    New_type& on_command_process_read_nvx(){ flag |= VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX; return *this; } 
    New_type& off_command_process_read_nvx(){ flag |= ~(VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX); return *this; }
    New_type& on_command_process_write_nvx(){ flag |= VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX; return *this; } 
    New_type& off_command_process_write_nvx(){ flag |= ~(VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX); return *this; }
    New_type& on_color_attachment_read_noncoherent_ext(){ flag |= VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT; return *this; } 
    New_type& off_color_attachment_read_noncoherent_ext(){ flag |= ~(VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT); return *this; }
    New_type& on_shading_rate_image_read_nv(){ flag |= VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV; return *this; } 
    New_type& off_shading_rate_image_read_nv(){ flag |= ~(VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV); return *this; }
    New_type& on_acceleration_structure_read_nv(){ flag |= VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV; return *this; } 
    New_type& off_acceleration_structure_read_nv(){ flag |= ~(VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV); return *this; }
    New_type& on_acceleration_structure_write_nv(){ flag |= VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV; return *this; } 
    New_type& off_acceleration_structure_write_nv(){ flag |= ~(VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV); return *this; }
    New_type& on_fragment_density_map_read_ext(){ flag |= VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT; return *this; } 
    New_type& off_fragment_density_map_read_ext(){ flag |= ~(VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_ACCESS_INDIRECT_COMMAND_READ_BIT| VK_ACCESS_INDEX_READ_BIT| VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT| VK_ACCESS_UNIFORM_READ_BIT| VK_ACCESS_INPUT_ATTACHMENT_READ_BIT| VK_ACCESS_SHADER_READ_BIT| VK_ACCESS_SHADER_WRITE_BIT| VK_ACCESS_COLOR_ATTACHMENT_READ_BIT| VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT| VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT| VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT| VK_ACCESS_TRANSFER_READ_BIT| VK_ACCESS_TRANSFER_WRITE_BIT| VK_ACCESS_HOST_READ_BIT| VK_ACCESS_HOST_WRITE_BIT| VK_ACCESS_MEMORY_READ_BIT| VK_ACCESS_MEMORY_WRITE_BIT| VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT| VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT| VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT| VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT| VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX| VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX| VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT| VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV| VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV| VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV| VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT;
};
inL constexpr F_Access operator|(F_Access::Otype const b1, F_Access const b2) { return b1 | b2.flag; }
inL constexpr F_Access operator|(F_Access const b1, F_Access::Otype const b2) { return b1.flag | b2; }
inL constexpr F_Access operator&(F_Access::Otype const b1, F_Access const b2) { return b1 & b2.flag; }
inL constexpr F_Access operator&(F_Access const b1, F_Access::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkAccessFlagBits> { using T = F_Access; };
struct F_ExternalFenceFeature : public E<VkExternalFenceFeatureFlagBits> {
    using E::E;
    using New_type = F_ExternalFenceFeature;
    static constexpr OEtype b_exportable = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT;
    static constexpr OEtype b_importable = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT;
    static constexpr OEtype b_exportable_khr = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR;
    static constexpr OEtype b_importable_khr = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR;
    New_type& on_exportable(){ flag |= VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT; return *this; } 
    New_type& off_exportable(){ flag |= ~(VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT); return *this; }
    New_type& on_importable(){ flag |= VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT; return *this; } 
    New_type& off_importable(){ flag |= ~(VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT); return *this; }
    New_type& on_exportable_khr(){ flag |= VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR; return *this; } 
    New_type& off_exportable_khr(){ flag |= ~(VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR); return *this; }
    New_type& on_importable_khr(){ flag |= VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR; return *this; } 
    New_type& off_importable_khr(){ flag |= ~(VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT| VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT| VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR| VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR;
};
inL constexpr F_ExternalFenceFeature operator|(F_ExternalFenceFeature::Otype const b1, F_ExternalFenceFeature const b2) { return b1 | b2.flag; }
inL constexpr F_ExternalFenceFeature operator|(F_ExternalFenceFeature const b1, F_ExternalFenceFeature::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ExternalFenceFeature operator&(F_ExternalFenceFeature::Otype const b1, F_ExternalFenceFeature const b2) { return b1 & b2.flag; }
inL constexpr F_ExternalFenceFeature operator&(F_ExternalFenceFeature const b1, F_ExternalFenceFeature::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkExternalFenceFeatureFlagBits> { using T = F_ExternalFenceFeature; };
struct F_DescriptorBindingEXT : public E<VkDescriptorBindingFlagBitsEXT> {
    using E::E;
    using New_type = F_DescriptorBindingEXT;
    static constexpr OEtype b_update_after_bind_ext = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT;
    static constexpr OEtype b_update_unused_while_pending_ext = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT;
    static constexpr OEtype b_partially_bound_ext = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT;
    static constexpr OEtype b_variable_descriptor_count_ext = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT;
    New_type& on_update_after_bind_ext(){ flag |= VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT; return *this; } 
    New_type& off_update_after_bind_ext(){ flag |= ~(VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT); return *this; }
    New_type& on_update_unused_while_pending_ext(){ flag |= VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT; return *this; } 
    New_type& off_update_unused_while_pending_ext(){ flag |= ~(VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT); return *this; }
    New_type& on_partially_bound_ext(){ flag |= VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT; return *this; } 
    New_type& off_partially_bound_ext(){ flag |= ~(VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT); return *this; }
    New_type& on_variable_descriptor_count_ext(){ flag |= VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT; return *this; } 
    New_type& off_variable_descriptor_count_ext(){ flag |= ~(VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT| VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT| VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT| VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT;
};
inL constexpr F_DescriptorBindingEXT operator|(F_DescriptorBindingEXT::Otype const b1, F_DescriptorBindingEXT const b2) { return b1 | b2.flag; }
inL constexpr F_DescriptorBindingEXT operator|(F_DescriptorBindingEXT const b1, F_DescriptorBindingEXT::Otype const b2) { return b1.flag | b2; }
inL constexpr F_DescriptorBindingEXT operator&(F_DescriptorBindingEXT::Otype const b1, F_DescriptorBindingEXT const b2) { return b1 & b2.flag; }
inL constexpr F_DescriptorBindingEXT operator&(F_DescriptorBindingEXT const b1, F_DescriptorBindingEXT::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkDescriptorBindingFlagBitsEXT> { using T = F_DescriptorBindingEXT; };
struct F_ExternalMemoryHandleTypeNV : public E<VkExternalMemoryHandleTypeFlagBitsNV> {
    using E::E;
    using New_type = F_ExternalMemoryHandleTypeNV;
    static constexpr OEtype b_opaque_win32_nv = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV;
    static constexpr OEtype b_opaque_win32_kmt_nv = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV;
    static constexpr OEtype b_d3d11_image_nv = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV;
    static constexpr OEtype b_d3d11_image_kmt_nv = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV;
    New_type& on_opaque_win32_nv(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV; return *this; } 
    New_type& off_opaque_win32_nv(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV); return *this; }
    New_type& on_opaque_win32_kmt_nv(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV; return *this; } 
    New_type& off_opaque_win32_kmt_nv(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV); return *this; }
    New_type& on_d3d11_image_nv(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV; return *this; } 
    New_type& off_d3d11_image_nv(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV); return *this; }
    New_type& on_d3d11_image_kmt_nv(){ flag |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV; return *this; } 
    New_type& off_d3d11_image_kmt_nv(){ flag |= ~(VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV| VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV| VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV| VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV;
};
inL constexpr F_ExternalMemoryHandleTypeNV operator|(F_ExternalMemoryHandleTypeNV::Otype const b1, F_ExternalMemoryHandleTypeNV const b2) { return b1 | b2.flag; }
inL constexpr F_ExternalMemoryHandleTypeNV operator|(F_ExternalMemoryHandleTypeNV const b1, F_ExternalMemoryHandleTypeNV::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ExternalMemoryHandleTypeNV operator&(F_ExternalMemoryHandleTypeNV::Otype const b1, F_ExternalMemoryHandleTypeNV const b2) { return b1 & b2.flag; }
inL constexpr F_ExternalMemoryHandleTypeNV operator&(F_ExternalMemoryHandleTypeNV const b1, F_ExternalMemoryHandleTypeNV::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkExternalMemoryHandleTypeFlagBitsNV> { using T = F_ExternalMemoryHandleTypeNV; };
struct F_ExternalMemoryFeatureNV : public E<VkExternalMemoryFeatureFlagBitsNV> {
    using E::E;
    using New_type = F_ExternalMemoryFeatureNV;
    static constexpr OEtype b_dedicated_only_nv = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV;
    static constexpr OEtype b_exportable_nv = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV;
    static constexpr OEtype b_importable_nv = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV;
    New_type& on_dedicated_only_nv(){ flag |= VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV; return *this; } 
    New_type& off_dedicated_only_nv(){ flag |= ~(VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV); return *this; }
    New_type& on_exportable_nv(){ flag |= VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV; return *this; } 
    New_type& off_exportable_nv(){ flag |= ~(VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV); return *this; }
    New_type& on_importable_nv(){ flag |= VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV; return *this; } 
    New_type& off_importable_nv(){ flag |= ~(VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV| VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV| VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV;
};
inL constexpr F_ExternalMemoryFeatureNV operator|(F_ExternalMemoryFeatureNV::Otype const b1, F_ExternalMemoryFeatureNV const b2) { return b1 | b2.flag; }
inL constexpr F_ExternalMemoryFeatureNV operator|(F_ExternalMemoryFeatureNV const b1, F_ExternalMemoryFeatureNV::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ExternalMemoryFeatureNV operator&(F_ExternalMemoryFeatureNV::Otype const b1, F_ExternalMemoryFeatureNV const b2) { return b1 & b2.flag; }
inL constexpr F_ExternalMemoryFeatureNV operator&(F_ExternalMemoryFeatureNV const b1, F_ExternalMemoryFeatureNV::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkExternalMemoryFeatureFlagBitsNV> { using T = F_ExternalMemoryFeatureNV; };
struct F_FenceImport : public E<VkFenceImportFlagBits> {
    using E::E;
    using New_type = F_FenceImport;
    static constexpr OEtype b_temporary = VK_FENCE_IMPORT_TEMPORARY_BIT;
    static constexpr OEtype b_temporary_khr = VK_FENCE_IMPORT_TEMPORARY_BIT_KHR;
    New_type& on_temporary(){ flag |= VK_FENCE_IMPORT_TEMPORARY_BIT; return *this; } 
    New_type& off_temporary(){ flag |= ~(VK_FENCE_IMPORT_TEMPORARY_BIT); return *this; }
    New_type& on_temporary_khr(){ flag |= VK_FENCE_IMPORT_TEMPORARY_BIT_KHR; return *this; } 
    New_type& off_temporary_khr(){ flag |= ~(VK_FENCE_IMPORT_TEMPORARY_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_FENCE_IMPORT_TEMPORARY_BIT| VK_FENCE_IMPORT_TEMPORARY_BIT_KHR;
};
inL constexpr F_FenceImport operator|(F_FenceImport::Otype const b1, F_FenceImport const b2) { return b1 | b2.flag; }
inL constexpr F_FenceImport operator|(F_FenceImport const b1, F_FenceImport::Otype const b2) { return b1.flag | b2; }
inL constexpr F_FenceImport operator&(F_FenceImport::Otype const b1, F_FenceImport const b2) { return b1 & b2.flag; }
inL constexpr F_FenceImport operator&(F_FenceImport const b1, F_FenceImport::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkFenceImportFlagBits> { using T = F_FenceImport; };
struct F_ImageAspect : public E<VkImageAspectFlagBits> {
    using E::E;
    using New_type = F_ImageAspect;
    static constexpr OEtype b_color = VK_IMAGE_ASPECT_COLOR_BIT;
    static constexpr OEtype b_depth = VK_IMAGE_ASPECT_DEPTH_BIT;
    static constexpr OEtype b_stencil = VK_IMAGE_ASPECT_STENCIL_BIT;
    static constexpr OEtype b_metadata = VK_IMAGE_ASPECT_METADATA_BIT;
    static constexpr OEtype b_plane_0 = VK_IMAGE_ASPECT_PLANE_0_BIT;
    static constexpr OEtype b_plane_1 = VK_IMAGE_ASPECT_PLANE_1_BIT;
    static constexpr OEtype b_plane_2 = VK_IMAGE_ASPECT_PLANE_2_BIT;
    static constexpr OEtype b_plane_0_khr = VK_IMAGE_ASPECT_PLANE_0_BIT_KHR;
    static constexpr OEtype b_plane_1_khr = VK_IMAGE_ASPECT_PLANE_1_BIT_KHR;
    static constexpr OEtype b_plane_2_khr = VK_IMAGE_ASPECT_PLANE_2_BIT_KHR;
    static constexpr OEtype b_memory_plane_0_ext = VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT;
    static constexpr OEtype b_memory_plane_1_ext = VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT;
    static constexpr OEtype b_memory_plane_2_ext = VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT;
    static constexpr OEtype b_memory_plane_3_ext = VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT;
    New_type& on_color(){ flag |= VK_IMAGE_ASPECT_COLOR_BIT; return *this; } 
    New_type& off_color(){ flag |= ~(VK_IMAGE_ASPECT_COLOR_BIT); return *this; }
    New_type& on_depth(){ flag |= VK_IMAGE_ASPECT_DEPTH_BIT; return *this; } 
    New_type& off_depth(){ flag |= ~(VK_IMAGE_ASPECT_DEPTH_BIT); return *this; }
    New_type& on_stencil(){ flag |= VK_IMAGE_ASPECT_STENCIL_BIT; return *this; } 
    New_type& off_stencil(){ flag |= ~(VK_IMAGE_ASPECT_STENCIL_BIT); return *this; }
    New_type& on_metadata(){ flag |= VK_IMAGE_ASPECT_METADATA_BIT; return *this; } 
    New_type& off_metadata(){ flag |= ~(VK_IMAGE_ASPECT_METADATA_BIT); return *this; }
    New_type& on_plane_0(){ flag |= VK_IMAGE_ASPECT_PLANE_0_BIT; return *this; } 
    New_type& off_plane_0(){ flag |= ~(VK_IMAGE_ASPECT_PLANE_0_BIT); return *this; }
    New_type& on_plane_1(){ flag |= VK_IMAGE_ASPECT_PLANE_1_BIT; return *this; } 
    New_type& off_plane_1(){ flag |= ~(VK_IMAGE_ASPECT_PLANE_1_BIT); return *this; }
    New_type& on_plane_2(){ flag |= VK_IMAGE_ASPECT_PLANE_2_BIT; return *this; } 
    New_type& off_plane_2(){ flag |= ~(VK_IMAGE_ASPECT_PLANE_2_BIT); return *this; }
    New_type& on_plane_0_khr(){ flag |= VK_IMAGE_ASPECT_PLANE_0_BIT_KHR; return *this; } 
    New_type& off_plane_0_khr(){ flag |= ~(VK_IMAGE_ASPECT_PLANE_0_BIT_KHR); return *this; }
    New_type& on_plane_1_khr(){ flag |= VK_IMAGE_ASPECT_PLANE_1_BIT_KHR; return *this; } 
    New_type& off_plane_1_khr(){ flag |= ~(VK_IMAGE_ASPECT_PLANE_1_BIT_KHR); return *this; }
    New_type& on_plane_2_khr(){ flag |= VK_IMAGE_ASPECT_PLANE_2_BIT_KHR; return *this; } 
    New_type& off_plane_2_khr(){ flag |= ~(VK_IMAGE_ASPECT_PLANE_2_BIT_KHR); return *this; }
    New_type& on_memory_plane_0_ext(){ flag |= VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT; return *this; } 
    New_type& off_memory_plane_0_ext(){ flag |= ~(VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT); return *this; }
    New_type& on_memory_plane_1_ext(){ flag |= VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT; return *this; } 
    New_type& off_memory_plane_1_ext(){ flag |= ~(VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT); return *this; }
    New_type& on_memory_plane_2_ext(){ flag |= VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT; return *this; } 
    New_type& off_memory_plane_2_ext(){ flag |= ~(VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT); return *this; }
    New_type& on_memory_plane_3_ext(){ flag |= VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT; return *this; } 
    New_type& off_memory_plane_3_ext(){ flag |= ~(VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_IMAGE_ASPECT_COLOR_BIT| VK_IMAGE_ASPECT_DEPTH_BIT| VK_IMAGE_ASPECT_STENCIL_BIT| VK_IMAGE_ASPECT_METADATA_BIT| VK_IMAGE_ASPECT_PLANE_0_BIT| VK_IMAGE_ASPECT_PLANE_1_BIT| VK_IMAGE_ASPECT_PLANE_2_BIT| VK_IMAGE_ASPECT_PLANE_0_BIT_KHR| VK_IMAGE_ASPECT_PLANE_1_BIT_KHR| VK_IMAGE_ASPECT_PLANE_2_BIT_KHR| VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT| VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT| VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT| VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT;
};
inL constexpr F_ImageAspect operator|(F_ImageAspect::Otype const b1, F_ImageAspect const b2) { return b1 | b2.flag; }
inL constexpr F_ImageAspect operator|(F_ImageAspect const b1, F_ImageAspect::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ImageAspect operator&(F_ImageAspect::Otype const b1, F_ImageAspect const b2) { return b1 & b2.flag; }
inL constexpr F_ImageAspect operator&(F_ImageAspect const b1, F_ImageAspect::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkImageAspectFlagBits> { using T = F_ImageAspect; };
struct F_DescriptorSetLayoutCreate : public E<VkDescriptorSetLayoutCreateFlagBits> {
    using E::E;
    using New_type = F_DescriptorSetLayoutCreate;
    static constexpr OEtype b_push_descriptor_khr = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR;
    static constexpr OEtype b_update_after_bind_pool_ext = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT;
    New_type& on_push_descriptor_khr(){ flag |= VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR; return *this; } 
    New_type& off_push_descriptor_khr(){ flag |= ~(VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR); return *this; }
    New_type& on_update_after_bind_pool_ext(){ flag |= VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT; return *this; } 
    New_type& off_update_after_bind_pool_ext(){ flag |= ~(VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR| VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT;
};
inL constexpr F_DescriptorSetLayoutCreate operator|(F_DescriptorSetLayoutCreate::Otype const b1, F_DescriptorSetLayoutCreate const b2) { return b1 | b2.flag; }
inL constexpr F_DescriptorSetLayoutCreate operator|(F_DescriptorSetLayoutCreate const b1, F_DescriptorSetLayoutCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_DescriptorSetLayoutCreate operator&(F_DescriptorSetLayoutCreate::Otype const b1, F_DescriptorSetLayoutCreate const b2) { return b1 & b2.flag; }
inL constexpr F_DescriptorSetLayoutCreate operator&(F_DescriptorSetLayoutCreate const b1, F_DescriptorSetLayoutCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkDescriptorSetLayoutCreateFlagBits> { using T = F_DescriptorSetLayoutCreate; };
struct F_ExternalFenceHandleType : public E<VkExternalFenceHandleTypeFlagBits> {
    using E::E;
    using New_type = F_ExternalFenceHandleType;
    static constexpr OEtype b_opaque_fd = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;
    static constexpr OEtype b_opaque_win32 = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
    static constexpr OEtype b_opaque_win32_kmt = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
    static constexpr OEtype b_sync_fd = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
    static constexpr OEtype b_opaque_fd_khr = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    static constexpr OEtype b_opaque_win32_khr = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    static constexpr OEtype b_opaque_win32_kmt_khr = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    static constexpr OEtype b_sync_fd_khr = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
    New_type& on_opaque_fd(){ flag |= VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT; return *this; } 
    New_type& off_opaque_fd(){ flag |= ~(VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT); return *this; }
    New_type& on_opaque_win32(){ flag |= VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT; return *this; } 
    New_type& off_opaque_win32(){ flag |= ~(VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT); return *this; }
    New_type& on_opaque_win32_kmt(){ flag |= VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT; return *this; } 
    New_type& off_opaque_win32_kmt(){ flag |= ~(VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT); return *this; }
    New_type& on_sync_fd(){ flag |= VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT; return *this; } 
    New_type& off_sync_fd(){ flag |= ~(VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT); return *this; }
    New_type& on_opaque_fd_khr(){ flag |= VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR; return *this; } 
    New_type& off_opaque_fd_khr(){ flag |= ~(VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR); return *this; }
    New_type& on_opaque_win32_khr(){ flag |= VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR; return *this; } 
    New_type& off_opaque_win32_khr(){ flag |= ~(VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR); return *this; }
    New_type& on_opaque_win32_kmt_khr(){ flag |= VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR; return *this; } 
    New_type& off_opaque_win32_kmt_khr(){ flag |= ~(VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR); return *this; }
    New_type& on_sync_fd_khr(){ flag |= VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR; return *this; } 
    New_type& off_sync_fd_khr(){ flag |= ~(VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT| VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT| VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT| VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT| VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR| VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR| VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR| VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
};
inL constexpr F_ExternalFenceHandleType operator|(F_ExternalFenceHandleType::Otype const b1, F_ExternalFenceHandleType const b2) { return b1 | b2.flag; }
inL constexpr F_ExternalFenceHandleType operator|(F_ExternalFenceHandleType const b1, F_ExternalFenceHandleType::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ExternalFenceHandleType operator&(F_ExternalFenceHandleType::Otype const b1, F_ExternalFenceHandleType const b2) { return b1 & b2.flag; }
inL constexpr F_ExternalFenceHandleType operator&(F_ExternalFenceHandleType const b1, F_ExternalFenceHandleType::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkExternalFenceHandleTypeFlagBits> { using T = F_ExternalFenceHandleType; };
struct F_PipelineStage : public E<VkPipelineStageFlagBits> {
    using E::E;
    using New_type = F_PipelineStage;
    static constexpr OEtype b_top_of_pipe = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
    static constexpr OEtype b_draw_indirect = VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT;
    static constexpr OEtype b_vertex_input = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT;
    static constexpr OEtype b_vertex_shader = VK_PIPELINE_STAGE_VERTEX_SHADER_BIT;
    static constexpr OEtype b_tessellation_control_shader = VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT;
    static constexpr OEtype b_tessellation_evaluation_shader = VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT;
    static constexpr OEtype b_geometry_shader = VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT;
    static constexpr OEtype b_fragment_shader = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
    static constexpr OEtype b_early_fragment_tests = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
    static constexpr OEtype b_late_fragment_tests = VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;
    static constexpr OEtype b_color_attachment_output = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    static constexpr OEtype b_compute_shader = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT;
    static constexpr OEtype b_transfer = VK_PIPELINE_STAGE_TRANSFER_BIT;
    static constexpr OEtype b_bottom_of_pipe = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT;
    static constexpr OEtype b_host = VK_PIPELINE_STAGE_HOST_BIT;
    static constexpr OEtype b_all_graphics = VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT;
    static constexpr OEtype b_all_commands = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
    static constexpr OEtype b_transform_feedback_ext = VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT;
    static constexpr OEtype b_conditional_rendering_ext = VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT;
    static constexpr OEtype b_command_process_nvx = VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX;
    static constexpr OEtype b_shading_rate_image_nv = VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV;
    static constexpr OEtype b_ray_tracing_shader_nv = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV;
    static constexpr OEtype b_acceleration_structure_build_nv = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV;
    static constexpr OEtype b_task_shader_nv = VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV;
    static constexpr OEtype b_mesh_shader_nv = VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV;
    static constexpr OEtype b_fragment_density_process_ext = VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
    New_type& on_top_of_pipe(){ flag |= VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT; return *this; } 
    New_type& off_top_of_pipe(){ flag |= ~(VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT); return *this; }
    New_type& on_draw_indirect(){ flag |= VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT; return *this; } 
    New_type& off_draw_indirect(){ flag |= ~(VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT); return *this; }
    New_type& on_vertex_input(){ flag |= VK_PIPELINE_STAGE_VERTEX_INPUT_BIT; return *this; } 
    New_type& off_vertex_input(){ flag |= ~(VK_PIPELINE_STAGE_VERTEX_INPUT_BIT); return *this; }
    New_type& on_vertex_shader(){ flag |= VK_PIPELINE_STAGE_VERTEX_SHADER_BIT; return *this; } 
    New_type& off_vertex_shader(){ flag |= ~(VK_PIPELINE_STAGE_VERTEX_SHADER_BIT); return *this; }
    New_type& on_tessellation_control_shader(){ flag |= VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT; return *this; } 
    New_type& off_tessellation_control_shader(){ flag |= ~(VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT); return *this; }
    New_type& on_tessellation_evaluation_shader(){ flag |= VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT; return *this; } 
    New_type& off_tessellation_evaluation_shader(){ flag |= ~(VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT); return *this; }
    New_type& on_geometry_shader(){ flag |= VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT; return *this; } 
    New_type& off_geometry_shader(){ flag |= ~(VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT); return *this; }
    New_type& on_fragment_shader(){ flag |= VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT; return *this; } 
    New_type& off_fragment_shader(){ flag |= ~(VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT); return *this; }
    New_type& on_early_fragment_tests(){ flag |= VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT; return *this; } 
    New_type& off_early_fragment_tests(){ flag |= ~(VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT); return *this; }
    New_type& on_late_fragment_tests(){ flag |= VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT; return *this; } 
    New_type& off_late_fragment_tests(){ flag |= ~(VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT); return *this; }
    New_type& on_color_attachment_output(){ flag |= VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; return *this; } 
    New_type& off_color_attachment_output(){ flag |= ~(VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT); return *this; }
    New_type& on_compute_shader(){ flag |= VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT; return *this; } 
    New_type& off_compute_shader(){ flag |= ~(VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT); return *this; }
    New_type& on_transfer(){ flag |= VK_PIPELINE_STAGE_TRANSFER_BIT; return *this; } 
    New_type& off_transfer(){ flag |= ~(VK_PIPELINE_STAGE_TRANSFER_BIT); return *this; }
    New_type& on_bottom_of_pipe(){ flag |= VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT; return *this; } 
    New_type& off_bottom_of_pipe(){ flag |= ~(VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT); return *this; }
    New_type& on_host(){ flag |= VK_PIPELINE_STAGE_HOST_BIT; return *this; } 
    New_type& off_host(){ flag |= ~(VK_PIPELINE_STAGE_HOST_BIT); return *this; }
    New_type& on_all_graphics(){ flag |= VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT; return *this; } 
    New_type& off_all_graphics(){ flag |= ~(VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT); return *this; }
    New_type& on_all_commands(){ flag |= VK_PIPELINE_STAGE_ALL_COMMANDS_BIT; return *this; } 
    New_type& off_all_commands(){ flag |= ~(VK_PIPELINE_STAGE_ALL_COMMANDS_BIT); return *this; }
    New_type& on_transform_feedback_ext(){ flag |= VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT; return *this; } 
    New_type& off_transform_feedback_ext(){ flag |= ~(VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT); return *this; }
    New_type& on_conditional_rendering_ext(){ flag |= VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT; return *this; } 
    New_type& off_conditional_rendering_ext(){ flag |= ~(VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT); return *this; }
    New_type& on_command_process_nvx(){ flag |= VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX; return *this; } 
    New_type& off_command_process_nvx(){ flag |= ~(VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX); return *this; }
    New_type& on_shading_rate_image_nv(){ flag |= VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV; return *this; } 
    New_type& off_shading_rate_image_nv(){ flag |= ~(VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV); return *this; }
    New_type& on_ray_tracing_shader_nv(){ flag |= VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV; return *this; } 
    New_type& off_ray_tracing_shader_nv(){ flag |= ~(VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV); return *this; }
    New_type& on_acceleration_structure_build_nv(){ flag |= VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV; return *this; } 
    New_type& off_acceleration_structure_build_nv(){ flag |= ~(VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV); return *this; }
    New_type& on_task_shader_nv(){ flag |= VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV; return *this; } 
    New_type& off_task_shader_nv(){ flag |= ~(VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV); return *this; }
    New_type& on_mesh_shader_nv(){ flag |= VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV; return *this; } 
    New_type& off_mesh_shader_nv(){ flag |= ~(VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV); return *this; }
    New_type& on_fragment_density_process_ext(){ flag |= VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT; return *this; } 
    New_type& off_fragment_density_process_ext(){ flag |= ~(VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT| VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT| VK_PIPELINE_STAGE_VERTEX_INPUT_BIT| VK_PIPELINE_STAGE_VERTEX_SHADER_BIT| VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT| VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT| VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT| VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT| VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT| VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT| VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT| VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT| VK_PIPELINE_STAGE_TRANSFER_BIT| VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT| VK_PIPELINE_STAGE_HOST_BIT| VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT| VK_PIPELINE_STAGE_ALL_COMMANDS_BIT| VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT| VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT| VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX| VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV| VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV| VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV| VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV| VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV| VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT;
};
inL constexpr F_PipelineStage operator|(F_PipelineStage::Otype const b1, F_PipelineStage const b2) { return b1 | b2.flag; }
inL constexpr F_PipelineStage operator|(F_PipelineStage const b1, F_PipelineStage::Otype const b2) { return b1.flag | b2; }
inL constexpr F_PipelineStage operator&(F_PipelineStage::Otype const b1, F_PipelineStage const b2) { return b1 & b2.flag; }
inL constexpr F_PipelineStage operator&(F_PipelineStage const b1, F_PipelineStage::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkPipelineStageFlagBits> { using T = F_PipelineStage; };
struct F_PipelineShaderStageCreate : public E<VkPipelineShaderStageCreateFlagBits> {
    using E::E;
    using New_type = F_PipelineShaderStageCreate;
    static constexpr OEtype b_allow_varying_subgroup_size_ext = VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT;
    static constexpr OEtype b_require_full_subgroups_ext = VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT;
    New_type& on_allow_varying_subgroup_size_ext(){ flag |= VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT; return *this; } 
    New_type& off_allow_varying_subgroup_size_ext(){ flag |= ~(VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT); return *this; }
    New_type& on_require_full_subgroups_ext(){ flag |= VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT; return *this; } 
    New_type& off_require_full_subgroups_ext(){ flag |= ~(VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT| VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT;
};
inL constexpr F_PipelineShaderStageCreate operator|(F_PipelineShaderStageCreate::Otype const b1, F_PipelineShaderStageCreate const b2) { return b1 | b2.flag; }
inL constexpr F_PipelineShaderStageCreate operator|(F_PipelineShaderStageCreate const b1, F_PipelineShaderStageCreate::Otype const b2) { return b1.flag | b2; }
inL constexpr F_PipelineShaderStageCreate operator&(F_PipelineShaderStageCreate::Otype const b1, F_PipelineShaderStageCreate const b2) { return b1 & b2.flag; }
inL constexpr F_PipelineShaderStageCreate operator&(F_PipelineShaderStageCreate const b1, F_PipelineShaderStageCreate::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkPipelineShaderStageCreateFlagBits> { using T = F_PipelineShaderStageCreate; };
struct F_ShaderCorePropertiesAMD : public E<VkShaderCorePropertiesFlagBitsAMD> {
    using E::E;
    using New_type = F_ShaderCorePropertiesAMD;
    static constexpr unsigned int all_bits = 0 ;
};
inL constexpr F_ShaderCorePropertiesAMD operator|(F_ShaderCorePropertiesAMD::Otype const b1, F_ShaderCorePropertiesAMD const b2) { return b1 | b2.flag; }
inL constexpr F_ShaderCorePropertiesAMD operator|(F_ShaderCorePropertiesAMD const b1, F_ShaderCorePropertiesAMD::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ShaderCorePropertiesAMD operator&(F_ShaderCorePropertiesAMD::Otype const b1, F_ShaderCorePropertiesAMD const b2) { return b1 & b2.flag; }
inL constexpr F_ShaderCorePropertiesAMD operator&(F_ShaderCorePropertiesAMD const b1, F_ShaderCorePropertiesAMD::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkShaderCorePropertiesFlagBitsAMD> { using T = F_ShaderCorePropertiesAMD; };
struct F_Dependency : public E<VkDependencyFlagBits> {
    using E::E;
    using New_type = F_Dependency;
    static constexpr OEtype b_by_region = VK_DEPENDENCY_BY_REGION_BIT;
    static constexpr OEtype b_device_group = VK_DEPENDENCY_DEVICE_GROUP_BIT;
    static constexpr OEtype b_view_local = VK_DEPENDENCY_VIEW_LOCAL_BIT;
    static constexpr OEtype b_view_local_khr = VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR;
    static constexpr OEtype b_device_group_khr = VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR;
    New_type& on_by_region(){ flag |= VK_DEPENDENCY_BY_REGION_BIT; return *this; } 
    New_type& off_by_region(){ flag |= ~(VK_DEPENDENCY_BY_REGION_BIT); return *this; }
    New_type& on_device_group(){ flag |= VK_DEPENDENCY_DEVICE_GROUP_BIT; return *this; } 
    New_type& off_device_group(){ flag |= ~(VK_DEPENDENCY_DEVICE_GROUP_BIT); return *this; }
    New_type& on_view_local(){ flag |= VK_DEPENDENCY_VIEW_LOCAL_BIT; return *this; } 
    New_type& off_view_local(){ flag |= ~(VK_DEPENDENCY_VIEW_LOCAL_BIT); return *this; }
    New_type& on_view_local_khr(){ flag |= VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR; return *this; } 
    New_type& off_view_local_khr(){ flag |= ~(VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR); return *this; }
    New_type& on_device_group_khr(){ flag |= VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR; return *this; } 
    New_type& off_device_group_khr(){ flag |= ~(VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_DEPENDENCY_BY_REGION_BIT| VK_DEPENDENCY_DEVICE_GROUP_BIT| VK_DEPENDENCY_VIEW_LOCAL_BIT| VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR| VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR;
};
inL constexpr F_Dependency operator|(F_Dependency::Otype const b1, F_Dependency const b2) { return b1 | b2.flag; }
inL constexpr F_Dependency operator|(F_Dependency const b1, F_Dependency::Otype const b2) { return b1.flag | b2; }
inL constexpr F_Dependency operator&(F_Dependency::Otype const b1, F_Dependency const b2) { return b1 & b2.flag; }
inL constexpr F_Dependency operator&(F_Dependency const b1, F_Dependency::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkDependencyFlagBits> { using T = F_Dependency; };
struct F_GeometryInstanceNV : public E<VkGeometryInstanceFlagBitsNV> {
    using E::E;
    using New_type = F_GeometryInstanceNV;
    static constexpr OEtype b_triangle_cull_disable_nv = VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV;
    static constexpr OEtype b_triangle_front_counterclockwise_nv = VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV;
    static constexpr OEtype b_force_opaque_nv = VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV;
    static constexpr OEtype b_force_no_opaque_nv = VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV;
    New_type& on_triangle_cull_disable_nv(){ flag |= VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV; return *this; } 
    New_type& off_triangle_cull_disable_nv(){ flag |= ~(VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV); return *this; }
    New_type& on_triangle_front_counterclockwise_nv(){ flag |= VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV; return *this; } 
    New_type& off_triangle_front_counterclockwise_nv(){ flag |= ~(VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV); return *this; }
    New_type& on_force_opaque_nv(){ flag |= VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV; return *this; } 
    New_type& off_force_opaque_nv(){ flag |= ~(VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV); return *this; }
    New_type& on_force_no_opaque_nv(){ flag |= VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV; return *this; } 
    New_type& off_force_no_opaque_nv(){ flag |= ~(VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV| VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV| VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV| VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV;
};
inL constexpr F_GeometryInstanceNV operator|(F_GeometryInstanceNV::Otype const b1, F_GeometryInstanceNV const b2) { return b1 | b2.flag; }
inL constexpr F_GeometryInstanceNV operator|(F_GeometryInstanceNV const b1, F_GeometryInstanceNV::Otype const b2) { return b1.flag | b2; }
inL constexpr F_GeometryInstanceNV operator&(F_GeometryInstanceNV::Otype const b1, F_GeometryInstanceNV const b2) { return b1 & b2.flag; }
inL constexpr F_GeometryInstanceNV operator&(F_GeometryInstanceNV const b1, F_GeometryInstanceNV::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkGeometryInstanceFlagBitsNV> { using T = F_GeometryInstanceNV; };
struct F_ConditionalRenderingEXT : public E<VkConditionalRenderingFlagBitsEXT> {
    using E::E;
    using New_type = F_ConditionalRenderingEXT;
    static constexpr OEtype b_inverted_ext = VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT;
    New_type& on_inverted_ext(){ flag |= VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT; return *this; } 
    New_type& off_inverted_ext(){ flag |= ~(VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT;
};
inL constexpr F_ConditionalRenderingEXT operator|(F_ConditionalRenderingEXT::Otype const b1, F_ConditionalRenderingEXT const b2) { return b1 | b2.flag; }
inL constexpr F_ConditionalRenderingEXT operator|(F_ConditionalRenderingEXT const b1, F_ConditionalRenderingEXT::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ConditionalRenderingEXT operator&(F_ConditionalRenderingEXT::Otype const b1, F_ConditionalRenderingEXT const b2) { return b1 & b2.flag; }
inL constexpr F_ConditionalRenderingEXT operator&(F_ConditionalRenderingEXT const b1, F_ConditionalRenderingEXT::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkConditionalRenderingFlagBitsEXT> { using T = F_ConditionalRenderingEXT; };
struct F_MemoryProperty : public E<VkMemoryPropertyFlagBits> {
    using E::E;
    using New_type = F_MemoryProperty;
    static constexpr OEtype b_device_local = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
    static constexpr OEtype b_host_visible = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
    static constexpr OEtype b_host_coherent = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
    static constexpr OEtype b_host_cached = VK_MEMORY_PROPERTY_HOST_CACHED_BIT;
    static constexpr OEtype b_lazily_allocated = VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT;
    static constexpr OEtype b_protected = VK_MEMORY_PROPERTY_PROTECTED_BIT;
    static constexpr OEtype b_device_coherent_amd = VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD;
    static constexpr OEtype b_device_uncached_amd = VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD;
    New_type& on_device_local(){ flag |= VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT; return *this; } 
    New_type& off_device_local(){ flag |= ~(VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT); return *this; }
    New_type& on_host_visible(){ flag |= VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT; return *this; } 
    New_type& off_host_visible(){ flag |= ~(VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT); return *this; }
    New_type& on_host_coherent(){ flag |= VK_MEMORY_PROPERTY_HOST_COHERENT_BIT; return *this; } 
    New_type& off_host_coherent(){ flag |= ~(VK_MEMORY_PROPERTY_HOST_COHERENT_BIT); return *this; }
    New_type& on_host_cached(){ flag |= VK_MEMORY_PROPERTY_HOST_CACHED_BIT; return *this; } 
    New_type& off_host_cached(){ flag |= ~(VK_MEMORY_PROPERTY_HOST_CACHED_BIT); return *this; }
    New_type& on_lazily_allocated(){ flag |= VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT; return *this; } 
    New_type& off_lazily_allocated(){ flag |= ~(VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT); return *this; }
    New_type& on_protected(){ flag |= VK_MEMORY_PROPERTY_PROTECTED_BIT; return *this; } 
    New_type& off_protected(){ flag |= ~(VK_MEMORY_PROPERTY_PROTECTED_BIT); return *this; }
    New_type& on_device_coherent_amd(){ flag |= VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD; return *this; } 
    New_type& off_device_coherent_amd(){ flag |= ~(VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD); return *this; }
    New_type& on_device_uncached_amd(){ flag |= VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD; return *this; } 
    New_type& off_device_uncached_amd(){ flag |= ~(VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT| VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT| VK_MEMORY_PROPERTY_HOST_COHERENT_BIT| VK_MEMORY_PROPERTY_HOST_CACHED_BIT| VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT| VK_MEMORY_PROPERTY_PROTECTED_BIT| VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD| VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD;
};
inL constexpr F_MemoryProperty operator|(F_MemoryProperty::Otype const b1, F_MemoryProperty const b2) { return b1 | b2.flag; }
inL constexpr F_MemoryProperty operator|(F_MemoryProperty const b1, F_MemoryProperty::Otype const b2) { return b1.flag | b2; }
inL constexpr F_MemoryProperty operator&(F_MemoryProperty::Otype const b1, F_MemoryProperty const b2) { return b1 & b2.flag; }
inL constexpr F_MemoryProperty operator&(F_MemoryProperty const b1, F_MemoryProperty::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkMemoryPropertyFlagBits> { using T = F_MemoryProperty; };
struct F_PipelineCreationFeedbackEXT : public E<VkPipelineCreationFeedbackFlagBitsEXT> {
    using E::E;
    using New_type = F_PipelineCreationFeedbackEXT;
    static constexpr OEtype b_valid_ext = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT;
    static constexpr OEtype b_application_pipeline_cache_hit_ext = VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT;
    static constexpr OEtype b_base_pipeline_acceleration_ext = VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT;
    New_type& on_valid_ext(){ flag |= VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT; return *this; } 
    New_type& off_valid_ext(){ flag |= ~(VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT); return *this; }
    New_type& on_application_pipeline_cache_hit_ext(){ flag |= VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT; return *this; } 
    New_type& off_application_pipeline_cache_hit_ext(){ flag |= ~(VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT); return *this; }
    New_type& on_base_pipeline_acceleration_ext(){ flag |= VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT; return *this; } 
    New_type& off_base_pipeline_acceleration_ext(){ flag |= ~(VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT| VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT| VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT;
};
inL constexpr F_PipelineCreationFeedbackEXT operator|(F_PipelineCreationFeedbackEXT::Otype const b1, F_PipelineCreationFeedbackEXT const b2) { return b1 | b2.flag; }
inL constexpr F_PipelineCreationFeedbackEXT operator|(F_PipelineCreationFeedbackEXT const b1, F_PipelineCreationFeedbackEXT::Otype const b2) { return b1.flag | b2; }
inL constexpr F_PipelineCreationFeedbackEXT operator&(F_PipelineCreationFeedbackEXT::Otype const b1, F_PipelineCreationFeedbackEXT const b2) { return b1 & b2.flag; }
inL constexpr F_PipelineCreationFeedbackEXT operator&(F_PipelineCreationFeedbackEXT const b1, F_PipelineCreationFeedbackEXT::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkPipelineCreationFeedbackFlagBitsEXT> { using T = F_PipelineCreationFeedbackEXT; };
struct F_CommandBufferUsage : public E<VkCommandBufferUsageFlagBits> {
    using E::E;
    using New_type = F_CommandBufferUsage;
    static constexpr OEtype b_one_time_submit = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
    static constexpr OEtype b_render_pass_continue = VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT;
    static constexpr OEtype b_simultaneous_use = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
    New_type& on_one_time_submit(){ flag |= VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT; return *this; } 
    New_type& off_one_time_submit(){ flag |= ~(VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT); return *this; }
    New_type& on_render_pass_continue(){ flag |= VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT; return *this; } 
    New_type& off_render_pass_continue(){ flag |= ~(VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT); return *this; }
    New_type& on_simultaneous_use(){ flag |= VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT; return *this; } 
    New_type& off_simultaneous_use(){ flag |= ~(VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT| VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT| VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
};
inL constexpr F_CommandBufferUsage operator|(F_CommandBufferUsage::Otype const b1, F_CommandBufferUsage const b2) { return b1 | b2.flag; }
inL constexpr F_CommandBufferUsage operator|(F_CommandBufferUsage const b1, F_CommandBufferUsage::Otype const b2) { return b1.flag | b2; }
inL constexpr F_CommandBufferUsage operator&(F_CommandBufferUsage::Otype const b1, F_CommandBufferUsage const b2) { return b1 & b2.flag; }
inL constexpr F_CommandBufferUsage operator&(F_CommandBufferUsage const b1, F_CommandBufferUsage::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkCommandBufferUsageFlagBits> { using T = F_CommandBufferUsage; };
struct F_ObjectEntryUsageNVX : public E<VkObjectEntryUsageFlagBitsNVX> {
    using E::E;
    using New_type = F_ObjectEntryUsageNVX;
    static constexpr OEtype b_graphics_nvx = VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX;
    static constexpr OEtype b_compute_nvx = VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX;
    New_type& on_graphics_nvx(){ flag |= VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX; return *this; } 
    New_type& off_graphics_nvx(){ flag |= ~(VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX); return *this; }
    New_type& on_compute_nvx(){ flag |= VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX; return *this; } 
    New_type& off_compute_nvx(){ flag |= ~(VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX); return *this; }
    static constexpr unsigned int all_bits = 0 | VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX| VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX;
};
inL constexpr F_ObjectEntryUsageNVX operator|(F_ObjectEntryUsageNVX::Otype const b1, F_ObjectEntryUsageNVX const b2) { return b1 | b2.flag; }
inL constexpr F_ObjectEntryUsageNVX operator|(F_ObjectEntryUsageNVX const b1, F_ObjectEntryUsageNVX::Otype const b2) { return b1.flag | b2; }
inL constexpr F_ObjectEntryUsageNVX operator&(F_ObjectEntryUsageNVX::Otype const b1, F_ObjectEntryUsageNVX const b2) { return b1 & b2.flag; }
inL constexpr F_ObjectEntryUsageNVX operator&(F_ObjectEntryUsageNVX const b1, F_ObjectEntryUsageNVX::Otype const b2) { return b1.flag & b2; }
template<> struct detail::names_map<VkObjectEntryUsageFlagBitsNVX> { using T = F_ObjectEntryUsageNVX; };
struct S_PipelineDynamicStateCreateInfo : public VkPipelineDynamicStateCreateInfo {
public:
    using Otype = VkPipelineDynamicStateCreateInfo;
public:
    S_PipelineDynamicStateCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineDynamicStateCreateInfo(
        VkPipelineDynamicStateCreateFlags flags_= { },
        Array_general<E_DynamicState> pDynamicStates_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
        nullptr,
        flags_,
        pDynamicStates_.size(),
        reinterpret_cast<VkDynamicState*>(pDynamicStates_.data())
    } { }
    inL S_PipelineDynamicStateCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineDynamicStateCreateInfo*() { return this; }
    inL operator S_PipelineDynamicStateCreateInfo const* () const { return const_cast<S_PipelineDynamicStateCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkPipelineDynamicStateCreateInfo> { using T = S_PipelineDynamicStateCreateInfo; };
struct S_DeviceGroupSubmitInfo : public VkDeviceGroupSubmitInfo {
public:
    using Otype = VkDeviceGroupSubmitInfo;
public:
    S_DeviceGroupSubmitInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceGroupSubmitInfo(
        Array_general<uint32_t> pWaitSemaphoreDeviceIndices_= { },
        Array_general<uint32_t> pCommandBufferDeviceMasks_= { },
        Array_general<uint32_t> pSignalSemaphoreDeviceIndices_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
        nullptr,
        pWaitSemaphoreDeviceIndices_.size(),
        reinterpret_cast<uint32_t*>(pWaitSemaphoreDeviceIndices_.data()),
        pCommandBufferDeviceMasks_.size(),
        reinterpret_cast<uint32_t*>(pCommandBufferDeviceMasks_.data()),
        pSignalSemaphoreDeviceIndices_.size(),
        reinterpret_cast<uint32_t*>(pSignalSemaphoreDeviceIndices_.data())
    } { }
    inL S_DeviceGroupSubmitInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceGroupSubmitInfo*() { return this; }
    inL operator S_DeviceGroupSubmitInfo const* () const { return const_cast<S_DeviceGroupSubmitInfo const*>(this); }
};
template<> struct detail::names_map<VkDeviceGroupSubmitInfo> { using T = S_DeviceGroupSubmitInfo; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_Win32KeyedMutexAcquireReleaseInfoKHR : public VkWin32KeyedMutexAcquireReleaseInfoKHR {
public:
    using Otype = VkWin32KeyedMutexAcquireReleaseInfoKHR;
public:
    S_Win32KeyedMutexAcquireReleaseInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_Win32KeyedMutexAcquireReleaseInfoKHR(
        Array_general<VkDeviceMemory> pAcquireSyncs_= { },
        Array_general<uint64_t> pAcquireKeys_= { },
        Array_general<uint32_t> pAcquireTimeouts_= { },
        Array_general<VkDeviceMemory> pReleaseSyncs_= { },
        Array_general<uint64_t> pReleaseKeys_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR,
        nullptr,
        pAcquireSyncs_.size(),
        reinterpret_cast<VkDeviceMemory*>(pAcquireSyncs_.data()),
        reinterpret_cast<uint64_t*>(pAcquireKeys_.data()),
        reinterpret_cast<uint32_t*>(pAcquireTimeouts_.data()),
        pReleaseSyncs_.size(),
        reinterpret_cast<VkDeviceMemory*>(pReleaseSyncs_.data()),
        reinterpret_cast<uint64_t*>(pReleaseKeys_.data())
    } { }
    inL S_Win32KeyedMutexAcquireReleaseInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_Win32KeyedMutexAcquireReleaseInfoKHR*() { return this; }
    inL operator S_Win32KeyedMutexAcquireReleaseInfoKHR const* () const { return const_cast<S_Win32KeyedMutexAcquireReleaseInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkWin32KeyedMutexAcquireReleaseInfoKHR> { using T = S_Win32KeyedMutexAcquireReleaseInfoKHR; };

#endif

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_Win32KeyedMutexAcquireReleaseInfoNV : public VkWin32KeyedMutexAcquireReleaseInfoNV {
public:
    using Otype = VkWin32KeyedMutexAcquireReleaseInfoNV;
public:
    S_Win32KeyedMutexAcquireReleaseInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_Win32KeyedMutexAcquireReleaseInfoNV(
        Array_general<VkDeviceMemory> pAcquireSyncs_= { },
        Array_general<uint64_t> pAcquireKeys_= { },
        Array_general<uint32_t> pAcquireTimeoutMilliseconds_= { },
        Array_general<VkDeviceMemory> pReleaseSyncs_= { },
        Array_general<uint64_t> pReleaseKeys_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV,
        nullptr,
        pAcquireSyncs_.size(),
        reinterpret_cast<VkDeviceMemory*>(pAcquireSyncs_.data()),
        reinterpret_cast<uint64_t*>(pAcquireKeys_.data()),
        reinterpret_cast<uint32_t*>(pAcquireTimeoutMilliseconds_.data()),
        pReleaseSyncs_.size(),
        reinterpret_cast<VkDeviceMemory*>(pReleaseSyncs_.data()),
        reinterpret_cast<uint64_t*>(pReleaseKeys_.data())
    } { }
    inL S_Win32KeyedMutexAcquireReleaseInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_Win32KeyedMutexAcquireReleaseInfoNV*() { return this; }
    inL operator S_Win32KeyedMutexAcquireReleaseInfoNV const* () const { return const_cast<S_Win32KeyedMutexAcquireReleaseInfoNV const*>(this); }
};
template<> struct detail::names_map<VkWin32KeyedMutexAcquireReleaseInfoNV> { using T = S_Win32KeyedMutexAcquireReleaseInfoNV; };

#endif

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_D3D12FenceSubmitInfoKHR : public VkD3D12FenceSubmitInfoKHR {
public:
    using Otype = VkD3D12FenceSubmitInfoKHR;
public:
    S_D3D12FenceSubmitInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_D3D12FenceSubmitInfoKHR(
        Array_general<uint64_t> pWaitSemaphoreValues_= { },
        Array_general<uint64_t> pSignalSemaphoreValues_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR,
        nullptr,
        pWaitSemaphoreValues_.size(),
        reinterpret_cast<uint64_t*>(pWaitSemaphoreValues_.data()),
        pSignalSemaphoreValues_.size(),
        reinterpret_cast<uint64_t*>(pSignalSemaphoreValues_.data())
    } { }
    inL S_D3D12FenceSubmitInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_D3D12FenceSubmitInfoKHR*() { return this; }
    inL operator S_D3D12FenceSubmitInfoKHR const* () const { return const_cast<S_D3D12FenceSubmitInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkD3D12FenceSubmitInfoKHR> { using T = S_D3D12FenceSubmitInfoKHR; };

#endif
struct S_ProtectedSubmitInfo : public VkProtectedSubmitInfo {
public:
    using Otype = VkProtectedSubmitInfo;
public:
    S_ProtectedSubmitInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_ProtectedSubmitInfo(
        VkBool32 protectedSubmit_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO,
        nullptr,
        protectedSubmit_
    } { }
    inL S_ProtectedSubmitInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ProtectedSubmitInfo*() { return this; }
    inL operator S_ProtectedSubmitInfo const* () const { return const_cast<S_ProtectedSubmitInfo const*>(this); }
};
template<> struct detail::names_map<VkProtectedSubmitInfo> { using T = S_ProtectedSubmitInfo; };
struct N_SubmitInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_SubmitInfo& n_VkDeviceGroupSubmitInfo(Aref<S_DeviceGroupSubmitInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_SubmitInfo& n_VkWin32KeyedMutexAcquireReleaseInfoKHR(Aref<S_Win32KeyedMutexAcquireReleaseInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_SubmitInfo& n_VkWin32KeyedMutexAcquireReleaseInfoNV(Aref<S_Win32KeyedMutexAcquireReleaseInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_SubmitInfo& n_VkD3D12FenceSubmitInfoKHR(Aref<S_D3D12FenceSubmitInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    inL N_SubmitInfo& n_VkProtectedSubmitInfo(Aref<S_ProtectedSubmitInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_SubmitInfo : public VkSubmitInfo {
public:
    using Otype = VkSubmitInfo;
public:
    S_SubmitInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_SubmitInfo(
        Array_general<VkSemaphore> pWaitSemaphores_= { },
        Array_general<VkPipelineStageFlags> pWaitDstStageMask_= { },
        Array_general<VkCommandBuffer> pCommandBuffers_= { },
        Array_general<VkSemaphore> pSignalSemaphores_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SUBMIT_INFO,
        nullptr,
        pWaitSemaphores_.size(),
        reinterpret_cast<VkSemaphore*>(pWaitSemaphores_.data()),
        reinterpret_cast<VkPipelineStageFlags*>(pWaitDstStageMask_.data()),
        pCommandBuffers_.size(),
        reinterpret_cast<VkCommandBuffer*>(pCommandBuffers_.data()),
        pSignalSemaphores_.size(),
        reinterpret_cast<VkSemaphore*>(pSignalSemaphores_.data())
    } { }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_SubmitInfo& n_VkWin32KeyedMutexAcquireReleaseInfoKHR(Aref<S_Win32KeyedMutexAcquireReleaseInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_SubmitInfo& n_VkWin32KeyedMutexAcquireReleaseInfoNV(Aref<S_Win32KeyedMutexAcquireReleaseInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_SubmitInfo& n_VkD3D12FenceSubmitInfoKHR(Aref<S_D3D12FenceSubmitInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    S_SubmitInfo& set_next(N_SubmitInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_SubmitInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SubmitInfo*() { return this; }
    inL operator S_SubmitInfo const* () const { return const_cast<S_SubmitInfo const*>(this); }
};
template<> struct detail::names_map<VkSubmitInfo> { using T = S_SubmitInfo; };
struct S_ImportSemaphoreFdInfoKHR : public VkImportSemaphoreFdInfoKHR {
public:
    using Otype = VkImportSemaphoreFdInfoKHR;
public:
    S_ImportSemaphoreFdInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImportSemaphoreFdInfoKHR(
        VkSemaphore semaphore_= { },
        VkSemaphoreImportFlags flags_= { },
        F_ExternalSemaphoreHandleType handleType_= { },
        int fd_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR,
        nullptr,
        semaphore_,
        flags_,
        handleType_,
        fd_
    } { }
    inL S_ImportSemaphoreFdInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImportSemaphoreFdInfoKHR*() { return this; }
    inL operator S_ImportSemaphoreFdInfoKHR const* () const { return const_cast<S_ImportSemaphoreFdInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkImportSemaphoreFdInfoKHR> { using T = S_ImportSemaphoreFdInfoKHR; };
struct S_PipelineRasterizationStateRasterizationOrderAMD : public VkPipelineRasterizationStateRasterizationOrderAMD {
public:
    using Otype = VkPipelineRasterizationStateRasterizationOrderAMD;
public:
    S_PipelineRasterizationStateRasterizationOrderAMD(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineRasterizationStateRasterizationOrderAMD(
        E_RasterizationOrderAMD rasterizationOrder_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
        nullptr,
        rasterizationOrder_
    } { }
    inL S_PipelineRasterizationStateRasterizationOrderAMD& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineRasterizationStateRasterizationOrderAMD*() { return this; }
    inL operator S_PipelineRasterizationStateRasterizationOrderAMD const* () const { return const_cast<S_PipelineRasterizationStateRasterizationOrderAMD const*>(this); }
};
template<> struct detail::names_map<VkPipelineRasterizationStateRasterizationOrderAMD> { using T = S_PipelineRasterizationStateRasterizationOrderAMD; };
struct S_PhysicalDeviceShaderCorePropertiesAMD : public VkPhysicalDeviceShaderCorePropertiesAMD {
public:
    using Otype = VkPhysicalDeviceShaderCorePropertiesAMD;
public:
    S_PhysicalDeviceShaderCorePropertiesAMD(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceShaderCorePropertiesAMD(
        uint32_t shaderEngineCount_= { },
        uint32_t shaderArraysPerEngineCount_= { },
        uint32_t computeUnitsPerShaderArray_= { },
        uint32_t simdPerComputeUnit_= { },
        uint32_t wavefrontsPerSimd_= { },
        uint32_t wavefrontSize_= { },
        uint32_t sgprsPerSimd_= { },
        uint32_t minSgprAllocation_= { },
        uint32_t maxSgprAllocation_= { },
        uint32_t sgprAllocationGranularity_= { },
        uint32_t vgprsPerSimd_= { },
        uint32_t minVgprAllocation_= { },
        uint32_t maxVgprAllocation_= { },
        uint32_t vgprAllocationGranularity_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
        nullptr,
        shaderEngineCount_,
        shaderArraysPerEngineCount_,
        computeUnitsPerShaderArray_,
        simdPerComputeUnit_,
        wavefrontsPerSimd_,
        wavefrontSize_,
        sgprsPerSimd_,
        minSgprAllocation_,
        maxSgprAllocation_,
        sgprAllocationGranularity_,
        vgprsPerSimd_,
        minVgprAllocation_,
        maxVgprAllocation_,
        vgprAllocationGranularity_
    } { }
    inL S_PhysicalDeviceShaderCorePropertiesAMD& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceShaderCorePropertiesAMD*() { return this; }
    inL operator S_PhysicalDeviceShaderCorePropertiesAMD const* () const { return const_cast<S_PhysicalDeviceShaderCorePropertiesAMD const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceShaderCorePropertiesAMD> { using T = S_PhysicalDeviceShaderCorePropertiesAMD; };
struct S_ImageSubresourceRange : public VkImageSubresourceRange {
public:
    using Otype = VkImageSubresourceRange;
public:
    S_ImageSubresourceRange(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageSubresourceRange(
        VkImageAspectFlags aspectMask_= { },
        uint32_t baseMipLevel_= { },
        uint32_t levelCount_= { },
        uint32_t baseArrayLayer_= { },
        uint32_t layerCount_= { }
    ) : Otype{
        aspectMask_,
        baseMipLevel_,
        levelCount_,
        baseArrayLayer_,
        layerCount_
    } { }
    inL S_ImageSubresourceRange& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageSubresourceRange*() { return this; }
    inL operator S_ImageSubresourceRange const* () const { return const_cast<S_ImageSubresourceRange const*>(this); }
};
template<> struct detail::names_map<VkImageSubresourceRange> { using T = S_ImageSubresourceRange; };
struct S_PipelineCreationFeedbackEXT : public VkPipelineCreationFeedbackEXT {
public:
    using Otype = VkPipelineCreationFeedbackEXT;
public:
    S_PipelineCreationFeedbackEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineCreationFeedbackEXT(
        VkPipelineCreationFeedbackFlagsEXT flags_= { },
        uint64_t duration_= { }
    ) : Otype{
        flags_,
        duration_
    } { }
    inL S_PipelineCreationFeedbackEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineCreationFeedbackEXT*() { return this; }
    inL operator S_PipelineCreationFeedbackEXT const* () const { return const_cast<S_PipelineCreationFeedbackEXT const*>(this); }
};
template<> struct detail::names_map<VkPipelineCreationFeedbackEXT> { using T = S_PipelineCreationFeedbackEXT; };
struct S_DeviceGroupCommandBufferBeginInfo : public VkDeviceGroupCommandBufferBeginInfo {
public:
    using Otype = VkDeviceGroupCommandBufferBeginInfo;
public:
    S_DeviceGroupCommandBufferBeginInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceGroupCommandBufferBeginInfo(
        uint32_t deviceMask_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
        nullptr,
        deviceMask_
    } { }
    inL S_DeviceGroupCommandBufferBeginInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceGroupCommandBufferBeginInfo*() { return this; }
    inL operator S_DeviceGroupCommandBufferBeginInfo const* () const { return const_cast<S_DeviceGroupCommandBufferBeginInfo const*>(this); }
};
template<> struct detail::names_map<VkDeviceGroupCommandBufferBeginInfo> { using T = S_DeviceGroupCommandBufferBeginInfo; };
struct S_DeviceGroupBindSparseInfo : public VkDeviceGroupBindSparseInfo {
public:
    using Otype = VkDeviceGroupBindSparseInfo;
public:
    S_DeviceGroupBindSparseInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceGroupBindSparseInfo(
        uint32_t resourceDeviceIndex_= { },
        uint32_t memoryDeviceIndex_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
        nullptr,
        resourceDeviceIndex_,
        memoryDeviceIndex_
    } { }
    inL S_DeviceGroupBindSparseInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceGroupBindSparseInfo*() { return this; }
    inL operator S_DeviceGroupBindSparseInfo const* () const { return const_cast<S_DeviceGroupBindSparseInfo const*>(this); }
};
template<> struct detail::names_map<VkDeviceGroupBindSparseInfo> { using T = S_DeviceGroupBindSparseInfo; };
struct S_PerformanceConfigurationAcquireInfoINTEL : public VkPerformanceConfigurationAcquireInfoINTEL {
public:
    using Otype = VkPerformanceConfigurationAcquireInfoINTEL;
public:
    S_PerformanceConfigurationAcquireInfoINTEL(Otype& origin_obj_):Otype(origin_obj_){}
    S_PerformanceConfigurationAcquireInfoINTEL(
        E_PerformanceConfigurationTypeINTEL type_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL,
        nullptr,
        type_
    } { }
    inL S_PerformanceConfigurationAcquireInfoINTEL& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PerformanceConfigurationAcquireInfoINTEL*() { return this; }
    inL operator S_PerformanceConfigurationAcquireInfoINTEL const* () const { return const_cast<S_PerformanceConfigurationAcquireInfoINTEL const*>(this); }
};
template<> struct detail::names_map<VkPerformanceConfigurationAcquireInfoINTEL> { using T = S_PerformanceConfigurationAcquireInfoINTEL; };
struct S_SubresourceLayout : public VkSubresourceLayout {
public:
    using Otype = VkSubresourceLayout;
public:
    S_SubresourceLayout(Otype& origin_obj_):Otype(origin_obj_){}
    S_SubresourceLayout(
        VkDeviceSize offset_= { },
        VkDeviceSize size_= { },
        VkDeviceSize rowPitch_= { },
        VkDeviceSize arrayPitch_= { },
        VkDeviceSize depthPitch_= { }
    ) : Otype{
        offset_,
        size_,
        rowPitch_,
        arrayPitch_,
        depthPitch_
    } { }
    inL S_SubresourceLayout& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SubresourceLayout*() { return this; }
    inL operator S_SubresourceLayout const* () const { return const_cast<S_SubresourceLayout const*>(this); }
};
template<> struct detail::names_map<VkSubresourceLayout> { using T = S_SubresourceLayout; };
struct S_ImageDrmFormatModifierExplicitCreateInfoEXT : public VkImageDrmFormatModifierExplicitCreateInfoEXT {
public:
    using Otype = VkImageDrmFormatModifierExplicitCreateInfoEXT;
public:
    S_ImageDrmFormatModifierExplicitCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageDrmFormatModifierExplicitCreateInfoEXT(
        uint64_t drmFormatModifier_= { },
        Array_general<S_SubresourceLayout> pPlaneLayouts_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
        nullptr,
        drmFormatModifier_,
        pPlaneLayouts_.size(),
        reinterpret_cast<VkSubresourceLayout*>(pPlaneLayouts_.data())
    } { }
    inL S_ImageDrmFormatModifierExplicitCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageDrmFormatModifierExplicitCreateInfoEXT*() { return this; }
    inL operator S_ImageDrmFormatModifierExplicitCreateInfoEXT const* () const { return const_cast<S_ImageDrmFormatModifierExplicitCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkImageDrmFormatModifierExplicitCreateInfoEXT> { using T = S_ImageDrmFormatModifierExplicitCreateInfoEXT; };
struct S_MemoryPriorityAllocateInfoEXT : public VkMemoryPriorityAllocateInfoEXT {
public:
    using Otype = VkMemoryPriorityAllocateInfoEXT;
public:
    S_MemoryPriorityAllocateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryPriorityAllocateInfoEXT(
        float priority_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
        nullptr,
        priority_
    } { }
    inL S_MemoryPriorityAllocateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryPriorityAllocateInfoEXT*() { return this; }
    inL operator S_MemoryPriorityAllocateInfoEXT const* () const { return const_cast<S_MemoryPriorityAllocateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkMemoryPriorityAllocateInfoEXT> { using T = S_MemoryPriorityAllocateInfoEXT; };
struct S_DrmFormatModifierPropertiesEXT : public VkDrmFormatModifierPropertiesEXT {
public:
    using Otype = VkDrmFormatModifierPropertiesEXT;
public:
    S_DrmFormatModifierPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DrmFormatModifierPropertiesEXT(
        uint64_t drmFormatModifier_= { },
        uint32_t drmFormatModifierPlaneCount_= { },
        VkFormatFeatureFlags drmFormatModifierTilingFeatures_= { }
    ) : Otype{
        drmFormatModifier_,
        drmFormatModifierPlaneCount_,
        drmFormatModifierTilingFeatures_
    } { }
    inL S_DrmFormatModifierPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DrmFormatModifierPropertiesEXT*() { return this; }
    inL operator S_DrmFormatModifierPropertiesEXT const* () const { return const_cast<S_DrmFormatModifierPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkDrmFormatModifierPropertiesEXT> { using T = S_DrmFormatModifierPropertiesEXT; };
struct S_Extent3D : public VkExtent3D {
public:
    using Otype = VkExtent3D;
public:
    S_Extent3D(Otype& origin_obj_):Otype(origin_obj_){}
    S_Extent3D(
        uint32_t width_= { },
        uint32_t height_= { },
        uint32_t depth_= { }
    ) : Otype{
        width_,
        height_,
        depth_
    } { }
    inL S_Extent3D& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_Extent3D*() { return this; }
    inL operator S_Extent3D const* () const { return const_cast<S_Extent3D const*>(this); }
};
template<> struct detail::names_map<VkExtent3D> { using T = S_Extent3D; };
struct S_ImageFormatListCreateInfoKHR : public VkImageFormatListCreateInfoKHR {
public:
    using Otype = VkImageFormatListCreateInfoKHR;
public:
    S_ImageFormatListCreateInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageFormatListCreateInfoKHR(
        Array_general<E_Format> pViewFormats_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR,
        nullptr,
        pViewFormats_.size(),
        reinterpret_cast<VkFormat*>(pViewFormats_.data())
    } { }
    inL S_ImageFormatListCreateInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageFormatListCreateInfoKHR*() { return this; }
    inL operator S_ImageFormatListCreateInfoKHR const* () const { return const_cast<S_ImageFormatListCreateInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkImageFormatListCreateInfoKHR> { using T = S_ImageFormatListCreateInfoKHR; };
struct S_DedicatedAllocationImageCreateInfoNV : public VkDedicatedAllocationImageCreateInfoNV {
public:
    using Otype = VkDedicatedAllocationImageCreateInfoNV;
public:
    S_DedicatedAllocationImageCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_DedicatedAllocationImageCreateInfoNV(
        VkBool32 dedicatedAllocation_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
        nullptr,
        dedicatedAllocation_
    } { }
    inL S_DedicatedAllocationImageCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DedicatedAllocationImageCreateInfoNV*() { return this; }
    inL operator S_DedicatedAllocationImageCreateInfoNV const* () const { return const_cast<S_DedicatedAllocationImageCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkDedicatedAllocationImageCreateInfoNV> { using T = S_DedicatedAllocationImageCreateInfoNV; };
struct S_ImageSwapchainCreateInfoKHR : public VkImageSwapchainCreateInfoKHR {
public:
    using Otype = VkImageSwapchainCreateInfoKHR;
public:
    S_ImageSwapchainCreateInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageSwapchainCreateInfoKHR(
        VkSwapchainKHR swapchain_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
        nullptr,
        swapchain_
    } { }
    inL S_ImageSwapchainCreateInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageSwapchainCreateInfoKHR*() { return this; }
    inL operator S_ImageSwapchainCreateInfoKHR const* () const { return const_cast<S_ImageSwapchainCreateInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkImageSwapchainCreateInfoKHR> { using T = S_ImageSwapchainCreateInfoKHR; };
struct S_ExternalMemoryImageCreateInfo : public VkExternalMemoryImageCreateInfo {
public:
    using Otype = VkExternalMemoryImageCreateInfo;
public:
    S_ExternalMemoryImageCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExternalMemoryImageCreateInfo(
        VkExternalMemoryHandleTypeFlags handleTypes_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
        nullptr,
        handleTypes_
    } { }
    inL S_ExternalMemoryImageCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExternalMemoryImageCreateInfo*() { return this; }
    inL operator S_ExternalMemoryImageCreateInfo const* () const { return const_cast<S_ExternalMemoryImageCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkExternalMemoryImageCreateInfo> { using T = S_ExternalMemoryImageCreateInfo; };

# if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct S_ExternalFormatANDROID : public VkExternalFormatANDROID {
public:
    using Otype = VkExternalFormatANDROID;
public:
    S_ExternalFormatANDROID(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExternalFormatANDROID(
        uint64_t externalFormat_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID,
        nullptr,
        externalFormat_
    } { }
    inL S_ExternalFormatANDROID& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExternalFormatANDROID*() { return this; }
    inL operator S_ExternalFormatANDROID const* () const { return const_cast<S_ExternalFormatANDROID const*>(this); }
};
template<> struct detail::names_map<VkExternalFormatANDROID> { using T = S_ExternalFormatANDROID; };

#endif
struct S_ExternalMemoryImageCreateInfoNV : public VkExternalMemoryImageCreateInfoNV {
public:
    using Otype = VkExternalMemoryImageCreateInfoNV;
public:
    S_ExternalMemoryImageCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExternalMemoryImageCreateInfoNV(
        VkExternalMemoryHandleTypeFlagsNV handleTypes_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
        nullptr,
        handleTypes_
    } { }
    inL S_ExternalMemoryImageCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExternalMemoryImageCreateInfoNV*() { return this; }
    inL operator S_ExternalMemoryImageCreateInfoNV const* () const { return const_cast<S_ExternalMemoryImageCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkExternalMemoryImageCreateInfoNV> { using T = S_ExternalMemoryImageCreateInfoNV; };
struct S_ImageDrmFormatModifierListCreateInfoEXT : public VkImageDrmFormatModifierListCreateInfoEXT {
public:
    using Otype = VkImageDrmFormatModifierListCreateInfoEXT;
public:
    S_ImageDrmFormatModifierListCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageDrmFormatModifierListCreateInfoEXT(
        Array_general<uint64_t> pDrmFormatModifiers_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
        nullptr,
        pDrmFormatModifiers_.size(),
        reinterpret_cast<uint64_t*>(pDrmFormatModifiers_.data())
    } { }
    inL S_ImageDrmFormatModifierListCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageDrmFormatModifierListCreateInfoEXT*() { return this; }
    inL operator S_ImageDrmFormatModifierListCreateInfoEXT const* () const { return const_cast<S_ImageDrmFormatModifierListCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkImageDrmFormatModifierListCreateInfoEXT> { using T = S_ImageDrmFormatModifierListCreateInfoEXT; };
struct S_ImageStencilUsageCreateInfoEXT : public VkImageStencilUsageCreateInfoEXT {
public:
    using Otype = VkImageStencilUsageCreateInfoEXT;
public:
    S_ImageStencilUsageCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageStencilUsageCreateInfoEXT(
        VkImageUsageFlags stencilUsage_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT,
        nullptr,
        stencilUsage_
    } { }
    inL S_ImageStencilUsageCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageStencilUsageCreateInfoEXT*() { return this; }
    inL operator S_ImageStencilUsageCreateInfoEXT const* () const { return const_cast<S_ImageStencilUsageCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkImageStencilUsageCreateInfoEXT> { using T = S_ImageStencilUsageCreateInfoEXT; };
struct N_ImageCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_ImageCreateInfo& n_VkImageFormatListCreateInfoKHR(Aref<S_ImageFormatListCreateInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_ImageCreateInfo& n_VkDedicatedAllocationImageCreateInfoNV(Aref<S_DedicatedAllocationImageCreateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_ImageCreateInfo& n_VkImageSwapchainCreateInfoKHR(Aref<S_ImageSwapchainCreateInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_ImageCreateInfo& n_VkExternalMemoryImageCreateInfo(Aref<S_ExternalMemoryImageCreateInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# if defined(VK_USE_PLATFORM_ANDROID_KHR)
    inL N_ImageCreateInfo& n_VkExternalFormatANDROID(Aref<S_ExternalFormatANDROID> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    inL N_ImageCreateInfo& n_VkExternalMemoryImageCreateInfoNV(Aref<S_ExternalMemoryImageCreateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_ImageCreateInfo& n_VkImageDrmFormatModifierListCreateInfoEXT(Aref<S_ImageDrmFormatModifierListCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_ImageCreateInfo& n_VkImageStencilUsageCreateInfoEXT(Aref<S_ImageStencilUsageCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_ImageCreateInfo& n_VkImageDrmFormatModifierExplicitCreateInfoEXT(Aref<S_ImageDrmFormatModifierExplicitCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_ImageCreateInfo : public VkImageCreateInfo {
public:
    using Otype = VkImageCreateInfo;
public:
    S_ImageCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageCreateInfo(
        VkImageCreateFlags flags_= { },
        E_ImageType imageType_= { },
        E_Format format_= { },
        S_Extent3D extent_= { },
        uint32_t mipLevels_= { },
        uint32_t arrayLayers_= { },
        F_SampleCount samples_= { },
        E_ImageTiling tiling_= { },
        VkImageUsageFlags usage_= { },
        E_SharingMode sharingMode_= { },
        Array_general<uint32_t> pQueueFamilyIndices_= { },
        E_ImageLayout initialLayout_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
        nullptr,
        flags_,
        imageType_,
        format_,
        extent_,
        mipLevels_,
        arrayLayers_,
        samples_,
        tiling_,
        usage_,
        sharingMode_,
        pQueueFamilyIndices_.size(),
        reinterpret_cast<uint32_t*>(pQueueFamilyIndices_.data()),
        initialLayout_
    } { }
# if defined(VK_USE_PLATFORM_ANDROID_KHR)
    inL S_ImageCreateInfo& n_VkExternalFormatANDROID(Aref<S_ExternalFormatANDROID> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    S_ImageCreateInfo& set_next(N_ImageCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_ImageCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageCreateInfo*() { return this; }
    inL operator S_ImageCreateInfo const* () const { return const_cast<S_ImageCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkImageCreateInfo> { using T = S_ImageCreateInfo; };
struct S_CommandBufferAllocateInfo : public VkCommandBufferAllocateInfo {
public:
    using Otype = VkCommandBufferAllocateInfo;
public:
    S_CommandBufferAllocateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_CommandBufferAllocateInfo(
        VkCommandPool commandPool_= { },
        E_CommandBufferLevel level_= { },
        uint32_t commandBufferCount_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
        nullptr,
        commandPool_,
        level_,
        commandBufferCount_
    } { }
    inL S_CommandBufferAllocateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_CommandBufferAllocateInfo*() { return this; }
    inL operator S_CommandBufferAllocateInfo const* () const { return const_cast<S_CommandBufferAllocateInfo const*>(this); }
};
template<> struct detail::names_map<VkCommandBufferAllocateInfo> { using T = S_CommandBufferAllocateInfo; };
struct S_ViewportWScalingNV : public VkViewportWScalingNV {
public:
    using Otype = VkViewportWScalingNV;
public:
    S_ViewportWScalingNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_ViewportWScalingNV(
        float xcoeff_= { },
        float ycoeff_= { }
    ) : Otype{
        xcoeff_,
        ycoeff_
    } { }
    inL S_ViewportWScalingNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ViewportWScalingNV*() { return this; }
    inL operator S_ViewportWScalingNV const* () const { return const_cast<S_ViewportWScalingNV const*>(this); }
};
template<> struct detail::names_map<VkViewportWScalingNV> { using T = S_ViewportWScalingNV; };
struct S_PipelineViewportWScalingStateCreateInfoNV : public VkPipelineViewportWScalingStateCreateInfoNV {
public:
    using Otype = VkPipelineViewportWScalingStateCreateInfoNV;
public:
    S_PipelineViewportWScalingStateCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineViewportWScalingStateCreateInfoNV(
        VkBool32 viewportWScalingEnable_= { },
        Array_general<S_ViewportWScalingNV> pViewportWScalings_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV,
        nullptr,
        viewportWScalingEnable_,
        pViewportWScalings_.size(),
        reinterpret_cast<VkViewportWScalingNV*>(pViewportWScalings_.data())
    } { }
    inL S_PipelineViewportWScalingStateCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineViewportWScalingStateCreateInfoNV*() { return this; }
    inL operator S_PipelineViewportWScalingStateCreateInfoNV const* () const { return const_cast<S_PipelineViewportWScalingStateCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkPipelineViewportWScalingStateCreateInfoNV> { using T = S_PipelineViewportWScalingStateCreateInfoNV; };
struct S_PipelineColorBlendAttachmentState : public VkPipelineColorBlendAttachmentState {
public:
    using Otype = VkPipelineColorBlendAttachmentState;
public:
    S_PipelineColorBlendAttachmentState(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineColorBlendAttachmentState(
        VkBool32 blendEnable_= { },
        E_BlendFactor srcColorBlendFactor_= { },
        E_BlendFactor dstColorBlendFactor_= { },
        E_BlendOp colorBlendOp_= { },
        E_BlendFactor srcAlphaBlendFactor_= { },
        E_BlendFactor dstAlphaBlendFactor_= { },
        E_BlendOp alphaBlendOp_= { },
        VkColorComponentFlags colorWriteMask_= { }
    ) : Otype{
        blendEnable_,
        srcColorBlendFactor_,
        dstColorBlendFactor_,
        colorBlendOp_,
        srcAlphaBlendFactor_,
        dstAlphaBlendFactor_,
        alphaBlendOp_,
        colorWriteMask_
    } { }
    inL S_PipelineColorBlendAttachmentState& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineColorBlendAttachmentState*() { return this; }
    inL operator S_PipelineColorBlendAttachmentState const* () const { return const_cast<S_PipelineColorBlendAttachmentState const*>(this); }
};
template<> struct detail::names_map<VkPipelineColorBlendAttachmentState> { using T = S_PipelineColorBlendAttachmentState; };
struct S_PipelineColorBlendAdvancedStateCreateInfoEXT : public VkPipelineColorBlendAdvancedStateCreateInfoEXT {
public:
    using Otype = VkPipelineColorBlendAdvancedStateCreateInfoEXT;
public:
    S_PipelineColorBlendAdvancedStateCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineColorBlendAdvancedStateCreateInfoEXT(
        VkBool32 srcPremultiplied_= { },
        VkBool32 dstPremultiplied_= { },
        E_BlendOverlapEXT blendOverlap_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
        nullptr,
        srcPremultiplied_,
        dstPremultiplied_,
        blendOverlap_
    } { }
    inL S_PipelineColorBlendAdvancedStateCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineColorBlendAdvancedStateCreateInfoEXT*() { return this; }
    inL operator S_PipelineColorBlendAdvancedStateCreateInfoEXT const* () const { return const_cast<S_PipelineColorBlendAdvancedStateCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkPipelineColorBlendAdvancedStateCreateInfoEXT> { using T = S_PipelineColorBlendAdvancedStateCreateInfoEXT; };
struct N_PipelineColorBlendStateCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_PipelineColorBlendStateCreateInfo& n_VkPipelineColorBlendAdvancedStateCreateInfoEXT(Aref<S_PipelineColorBlendAdvancedStateCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_PipelineColorBlendStateCreateInfo : public VkPipelineColorBlendStateCreateInfo {
public:
    using Otype = VkPipelineColorBlendStateCreateInfo;
public:
    S_PipelineColorBlendStateCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineColorBlendStateCreateInfo(
        VkPipelineColorBlendStateCreateFlags flags_= { },
        VkBool32 logicOpEnable_= { },
        E_LogicOp logicOp_= { },
        Array_general<S_PipelineColorBlendAttachmentState> pAttachments_= { },
        std::array<float,4> blendConstants_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
        nullptr,
        flags_,
        logicOpEnable_,
        logicOp_,
        pAttachments_.size(),
        reinterpret_cast<VkPipelineColorBlendAttachmentState*>(pAttachments_.data()),
        { }
    } { 
        ::memcpy(&blendConstants[0], blendConstants_.data(), blendConstants_.size() );
    }
    inL S_PipelineColorBlendStateCreateInfo& 
        set_blendConstants(std::array<float,4> blendConstants_)
        {  return *this; }
    S_PipelineColorBlendStateCreateInfo& set_next(N_PipelineColorBlendStateCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_PipelineColorBlendStateCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineColorBlendStateCreateInfo*() { return this; }
    inL operator S_PipelineColorBlendStateCreateInfo const* () const { return const_cast<S_PipelineColorBlendStateCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkPipelineColorBlendStateCreateInfo> { using T = S_PipelineColorBlendStateCreateInfo; };
struct S_ViewportSwizzleNV : public VkViewportSwizzleNV {
public:
    using Otype = VkViewportSwizzleNV;
public:
    S_ViewportSwizzleNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_ViewportSwizzleNV(
        E_ViewportCoordinateSwizzleNV x_= { },
        E_ViewportCoordinateSwizzleNV y_= { },
        E_ViewportCoordinateSwizzleNV z_= { },
        E_ViewportCoordinateSwizzleNV w_= { }
    ) : Otype{
        x_,
        y_,
        z_,
        w_
    } { }
    inL S_ViewportSwizzleNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ViewportSwizzleNV*() { return this; }
    inL operator S_ViewportSwizzleNV const* () const { return const_cast<S_ViewportSwizzleNV const*>(this); }
};
template<> struct detail::names_map<VkViewportSwizzleNV> { using T = S_ViewportSwizzleNV; };
struct S_ImageSparseMemoryRequirementsInfo2 : public VkImageSparseMemoryRequirementsInfo2 {
public:
    using Otype = VkImageSparseMemoryRequirementsInfo2;
public:
    S_ImageSparseMemoryRequirementsInfo2(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageSparseMemoryRequirementsInfo2(
        VkImage image_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
        nullptr,
        image_
    } { }
    inL S_ImageSparseMemoryRequirementsInfo2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageSparseMemoryRequirementsInfo2*() { return this; }
    inL operator S_ImageSparseMemoryRequirementsInfo2 const* () const { return const_cast<S_ImageSparseMemoryRequirementsInfo2 const*>(this); }
};
template<> struct detail::names_map<VkImageSparseMemoryRequirementsInfo2> { using T = S_ImageSparseMemoryRequirementsInfo2; };
struct S_DeviceGroupDeviceCreateInfo : public VkDeviceGroupDeviceCreateInfo {
public:
    using Otype = VkDeviceGroupDeviceCreateInfo;
public:
    S_DeviceGroupDeviceCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceGroupDeviceCreateInfo(
        Array_general<VkPhysicalDevice> pPhysicalDevices_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
        nullptr,
        pPhysicalDevices_.size(),
        reinterpret_cast<VkPhysicalDevice*>(pPhysicalDevices_.data())
    } { }
    inL S_DeviceGroupDeviceCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceGroupDeviceCreateInfo*() { return this; }
    inL operator S_DeviceGroupDeviceCreateInfo const* () const { return const_cast<S_DeviceGroupDeviceCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkDeviceGroupDeviceCreateInfo> { using T = S_DeviceGroupDeviceCreateInfo; };
struct S_ValidationFlagsEXT : public VkValidationFlagsEXT {
public:
    using Otype = VkValidationFlagsEXT;
public:
    S_ValidationFlagsEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_ValidationFlagsEXT(
        Array_general<E_ValidationCheckEXT> pDisabledValidationChecks_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT,
        nullptr,
        pDisabledValidationChecks_.size(),
        reinterpret_cast<VkValidationCheckEXT*>(pDisabledValidationChecks_.data())
    } { }
    inL S_ValidationFlagsEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ValidationFlagsEXT*() { return this; }
    inL operator S_ValidationFlagsEXT const* () const { return const_cast<S_ValidationFlagsEXT const*>(this); }
};
template<> struct detail::names_map<VkValidationFlagsEXT> { using T = S_ValidationFlagsEXT; };
struct S_Viewport : public VkViewport {
public:
    using Otype = VkViewport;
public:
    S_Viewport(Otype& origin_obj_):Otype(origin_obj_){}
    S_Viewport(
        float x_= { },
        float y_= { },
        float width_= { },
        float height_= { },
        float minDepth_= { },
        float maxDepth_= { }
    ) : Otype{
        x_,
        y_,
        width_,
        height_,
        minDepth_,
        maxDepth_
    } { }
    inL S_Viewport& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_Viewport*() { return this; }
    inL operator S_Viewport const* () const { return const_cast<S_Viewport const*>(this); }
};
template<> struct detail::names_map<VkViewport> { using T = S_Viewport; };
struct S_Offset2D : public VkOffset2D {
public:
    using Otype = VkOffset2D;
public:
    S_Offset2D(Otype& origin_obj_):Otype(origin_obj_){}
    S_Offset2D(
        int32_t x_= { },
        int32_t y_= { }
    ) : Otype{
        x_,
        y_
    } { }
    inL S_Offset2D& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_Offset2D*() { return this; }
    inL operator S_Offset2D const* () const { return const_cast<S_Offset2D const*>(this); }
};
template<> struct detail::names_map<VkOffset2D> { using T = S_Offset2D; };
struct S_Extent2D : public VkExtent2D {
public:
    using Otype = VkExtent2D;
public:
    S_Extent2D(Otype& origin_obj_):Otype(origin_obj_){}
    S_Extent2D(
        uint32_t width_= { },
        uint32_t height_= { }
    ) : Otype{
        width_,
        height_
    } { }
    inL S_Extent2D& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_Extent2D*() { return this; }
    inL operator S_Extent2D const* () const { return const_cast<S_Extent2D const*>(this); }
};
template<> struct detail::names_map<VkExtent2D> { using T = S_Extent2D; };
struct S_Rect2D : public VkRect2D {
public:
    using Otype = VkRect2D;
public:
    S_Rect2D(Otype& origin_obj_):Otype(origin_obj_){}
    S_Rect2D(
        S_Offset2D offset_= { },
        S_Extent2D extent_= { }
    ) : Otype{
        offset_,
        extent_
    } { }
    inL S_Rect2D& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_Rect2D*() { return this; }
    inL operator S_Rect2D const* () const { return const_cast<S_Rect2D const*>(this); }
};
template<> struct detail::names_map<VkRect2D> { using T = S_Rect2D; };
struct S_PipelineViewportSwizzleStateCreateInfoNV : public VkPipelineViewportSwizzleStateCreateInfoNV {
public:
    using Otype = VkPipelineViewportSwizzleStateCreateInfoNV;
public:
    S_PipelineViewportSwizzleStateCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineViewportSwizzleStateCreateInfoNV(
        VkPipelineViewportSwizzleStateCreateFlagsNV flags_= { },
        Array_general<S_ViewportSwizzleNV> pViewportSwizzles_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
        nullptr,
        flags_,
        pViewportSwizzles_.size(),
        reinterpret_cast<VkViewportSwizzleNV*>(pViewportSwizzles_.data())
    } { }
    inL S_PipelineViewportSwizzleStateCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineViewportSwizzleStateCreateInfoNV*() { return this; }
    inL operator S_PipelineViewportSwizzleStateCreateInfoNV const* () const { return const_cast<S_PipelineViewportSwizzleStateCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkPipelineViewportSwizzleStateCreateInfoNV> { using T = S_PipelineViewportSwizzleStateCreateInfoNV; };
struct S_PipelineViewportExclusiveScissorStateCreateInfoNV : public VkPipelineViewportExclusiveScissorStateCreateInfoNV {
public:
    using Otype = VkPipelineViewportExclusiveScissorStateCreateInfoNV;
public:
    S_PipelineViewportExclusiveScissorStateCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineViewportExclusiveScissorStateCreateInfoNV(
        Array_general<S_Rect2D> pExclusiveScissors_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
        nullptr,
        pExclusiveScissors_.size(),
        reinterpret_cast<VkRect2D*>(pExclusiveScissors_.data())
    } { }
    inL S_PipelineViewportExclusiveScissorStateCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineViewportExclusiveScissorStateCreateInfoNV*() { return this; }
    inL operator S_PipelineViewportExclusiveScissorStateCreateInfoNV const* () const { return const_cast<S_PipelineViewportExclusiveScissorStateCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkPipelineViewportExclusiveScissorStateCreateInfoNV> { using T = S_PipelineViewportExclusiveScissorStateCreateInfoNV; };
struct S_ShadingRatePaletteNV : public VkShadingRatePaletteNV {
public:
    using Otype = VkShadingRatePaletteNV;
public:
    S_ShadingRatePaletteNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_ShadingRatePaletteNV(
        Array_general<E_ShadingRatePaletteEntryNV> pShadingRatePaletteEntries_= { }
    ) : Otype{
        pShadingRatePaletteEntries_.size(),
        reinterpret_cast<VkShadingRatePaletteEntryNV*>(pShadingRatePaletteEntries_.data())
    } { }
    inL S_ShadingRatePaletteNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ShadingRatePaletteNV*() { return this; }
    inL operator S_ShadingRatePaletteNV const* () const { return const_cast<S_ShadingRatePaletteNV const*>(this); }
};
template<> struct detail::names_map<VkShadingRatePaletteNV> { using T = S_ShadingRatePaletteNV; };
struct S_PipelineViewportShadingRateImageStateCreateInfoNV : public VkPipelineViewportShadingRateImageStateCreateInfoNV {
public:
    using Otype = VkPipelineViewportShadingRateImageStateCreateInfoNV;
public:
    S_PipelineViewportShadingRateImageStateCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineViewportShadingRateImageStateCreateInfoNV(
        VkBool32 shadingRateImageEnable_= { },
        Array_general<S_ShadingRatePaletteNV> pShadingRatePalettes_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
        nullptr,
        shadingRateImageEnable_,
        pShadingRatePalettes_.size(),
        reinterpret_cast<VkShadingRatePaletteNV*>(pShadingRatePalettes_.data())
    } { }
    inL S_PipelineViewportShadingRateImageStateCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineViewportShadingRateImageStateCreateInfoNV*() { return this; }
    inL operator S_PipelineViewportShadingRateImageStateCreateInfoNV const* () const { return const_cast<S_PipelineViewportShadingRateImageStateCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkPipelineViewportShadingRateImageStateCreateInfoNV> { using T = S_PipelineViewportShadingRateImageStateCreateInfoNV; };
struct S_CoarseSampleLocationNV : public VkCoarseSampleLocationNV {
public:
    using Otype = VkCoarseSampleLocationNV;
public:
    S_CoarseSampleLocationNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_CoarseSampleLocationNV(
        uint32_t pixelX_= { },
        uint32_t pixelY_= { },
        uint32_t sample_= { }
    ) : Otype{
        pixelX_,
        pixelY_,
        sample_
    } { }
    inL S_CoarseSampleLocationNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_CoarseSampleLocationNV*() { return this; }
    inL operator S_CoarseSampleLocationNV const* () const { return const_cast<S_CoarseSampleLocationNV const*>(this); }
};
template<> struct detail::names_map<VkCoarseSampleLocationNV> { using T = S_CoarseSampleLocationNV; };
struct S_CoarseSampleOrderCustomNV : public VkCoarseSampleOrderCustomNV {
public:
    using Otype = VkCoarseSampleOrderCustomNV;
public:
    S_CoarseSampleOrderCustomNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_CoarseSampleOrderCustomNV(
        E_ShadingRatePaletteEntryNV shadingRate_= { },
        uint32_t sampleCount_= { },
        Array_general<S_CoarseSampleLocationNV> pSampleLocations_= { }
    ) : Otype{
        shadingRate_,
        sampleCount_,
        pSampleLocations_.size(),
        reinterpret_cast<VkCoarseSampleLocationNV*>(pSampleLocations_.data())
    } { }
    inL S_CoarseSampleOrderCustomNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_CoarseSampleOrderCustomNV*() { return this; }
    inL operator S_CoarseSampleOrderCustomNV const* () const { return const_cast<S_CoarseSampleOrderCustomNV const*>(this); }
};
template<> struct detail::names_map<VkCoarseSampleOrderCustomNV> { using T = S_CoarseSampleOrderCustomNV; };
struct S_PipelineViewportCoarseSampleOrderStateCreateInfoNV : public VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
public:
    using Otype = VkPipelineViewportCoarseSampleOrderStateCreateInfoNV;
public:
    S_PipelineViewportCoarseSampleOrderStateCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineViewportCoarseSampleOrderStateCreateInfoNV(
        E_CoarseSampleOrderTypeNV sampleOrderType_= { },
        Array_general<S_CoarseSampleOrderCustomNV> pCustomSampleOrders_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
        nullptr,
        sampleOrderType_,
        pCustomSampleOrders_.size(),
        reinterpret_cast<VkCoarseSampleOrderCustomNV*>(pCustomSampleOrders_.data())
    } { }
    inL S_PipelineViewportCoarseSampleOrderStateCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineViewportCoarseSampleOrderStateCreateInfoNV*() { return this; }
    inL operator S_PipelineViewportCoarseSampleOrderStateCreateInfoNV const* () const { return const_cast<S_PipelineViewportCoarseSampleOrderStateCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV> { using T = S_PipelineViewportCoarseSampleOrderStateCreateInfoNV; };
struct N_PipelineViewportStateCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_PipelineViewportStateCreateInfo& n_VkPipelineViewportWScalingStateCreateInfoNV(Aref<S_PipelineViewportWScalingStateCreateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PipelineViewportStateCreateInfo& n_VkPipelineViewportSwizzleStateCreateInfoNV(Aref<S_PipelineViewportSwizzleStateCreateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PipelineViewportStateCreateInfo& n_VkPipelineViewportExclusiveScissorStateCreateInfoNV(Aref<S_PipelineViewportExclusiveScissorStateCreateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PipelineViewportStateCreateInfo& n_VkPipelineViewportShadingRateImageStateCreateInfoNV(Aref<S_PipelineViewportShadingRateImageStateCreateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PipelineViewportStateCreateInfo& n_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(Aref<S_PipelineViewportCoarseSampleOrderStateCreateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_PipelineViewportStateCreateInfo : public VkPipelineViewportStateCreateInfo {
public:
    using Otype = VkPipelineViewportStateCreateInfo;
public:
    S_PipelineViewportStateCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineViewportStateCreateInfo(
        VkPipelineViewportStateCreateFlags flags_= { },
        Array_general<S_Viewport> pViewports_= { },
        Array_general<S_Rect2D> pScissors_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
        nullptr,
        flags_,
        pViewports_.size(),
        reinterpret_cast<VkViewport*>(pViewports_.data()),
        pScissors_.size(),
        reinterpret_cast<VkRect2D*>(pScissors_.data())
    } { }
    S_PipelineViewportStateCreateInfo& set_next(N_PipelineViewportStateCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_PipelineViewportStateCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineViewportStateCreateInfo*() { return this; }
    inL operator S_PipelineViewportStateCreateInfo const* () const { return const_cast<S_PipelineViewportStateCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkPipelineViewportStateCreateInfo> { using T = S_PipelineViewportStateCreateInfo; };
struct S_PipelineDiscardRectangleStateCreateInfoEXT : public VkPipelineDiscardRectangleStateCreateInfoEXT {
public:
    using Otype = VkPipelineDiscardRectangleStateCreateInfoEXT;
public:
    S_PipelineDiscardRectangleStateCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineDiscardRectangleStateCreateInfoEXT(
        VkPipelineDiscardRectangleStateCreateFlagsEXT flags_= { },
        E_DiscardRectangleModeEXT discardRectangleMode_= { },
        Array_general<S_Rect2D> pDiscardRectangles_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
        nullptr,
        flags_,
        discardRectangleMode_,
        pDiscardRectangles_.size(),
        reinterpret_cast<VkRect2D*>(pDiscardRectangles_.data())
    } { }
    inL S_PipelineDiscardRectangleStateCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineDiscardRectangleStateCreateInfoEXT*() { return this; }
    inL operator S_PipelineDiscardRectangleStateCreateInfoEXT const* () const { return const_cast<S_PipelineDiscardRectangleStateCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkPipelineDiscardRectangleStateCreateInfoEXT> { using T = S_PipelineDiscardRectangleStateCreateInfoEXT; };
struct S_GeometryTrianglesNV : public VkGeometryTrianglesNV {
public:
    using Otype = VkGeometryTrianglesNV;
public:
    S_GeometryTrianglesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_GeometryTrianglesNV(
        VkBuffer vertexData_= { },
        VkDeviceSize vertexOffset_= { },
        uint32_t vertexCount_= { },
        VkDeviceSize vertexStride_= { },
        E_Format vertexFormat_= { },
        VkBuffer indexData_= { },
        VkDeviceSize indexOffset_= { },
        uint32_t indexCount_= { },
        E_IndexType indexType_= { },
        VkBuffer transformData_= { },
        VkDeviceSize transformOffset_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV,
        nullptr,
        vertexData_,
        vertexOffset_,
        vertexCount_,
        vertexStride_,
        vertexFormat_,
        indexData_,
        indexOffset_,
        indexCount_,
        indexType_,
        transformData_,
        transformOffset_
    } { }
    inL S_GeometryTrianglesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_GeometryTrianglesNV*() { return this; }
    inL operator S_GeometryTrianglesNV const* () const { return const_cast<S_GeometryTrianglesNV const*>(this); }
};
template<> struct detail::names_map<VkGeometryTrianglesNV> { using T = S_GeometryTrianglesNV; };
struct S_GeometryAABBNV : public VkGeometryAABBNV {
public:
    using Otype = VkGeometryAABBNV;
public:
    S_GeometryAABBNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_GeometryAABBNV(
        VkBuffer aabbData_= { },
        uint32_t numAABBs_= { },
        uint32_t stride_= { },
        VkDeviceSize offset_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV,
        nullptr,
        aabbData_,
        numAABBs_,
        stride_,
        offset_
    } { }
    inL S_GeometryAABBNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_GeometryAABBNV*() { return this; }
    inL operator S_GeometryAABBNV const* () const { return const_cast<S_GeometryAABBNV const*>(this); }
};
template<> struct detail::names_map<VkGeometryAABBNV> { using T = S_GeometryAABBNV; };
struct S_GeometryDataNV : public VkGeometryDataNV {
public:
    using Otype = VkGeometryDataNV;
public:
    S_GeometryDataNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_GeometryDataNV(
        S_GeometryTrianglesNV triangles_= { },
        S_GeometryAABBNV aabbs_= { }
    ) : Otype{
        triangles_,
        aabbs_
    } { }
    inL S_GeometryDataNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_GeometryDataNV*() { return this; }
    inL operator S_GeometryDataNV const* () const { return const_cast<S_GeometryDataNV const*>(this); }
};
template<> struct detail::names_map<VkGeometryDataNV> { using T = S_GeometryDataNV; };
struct S_GeometryNV : public VkGeometryNV {
public:
    using Otype = VkGeometryNV;
public:
    S_GeometryNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_GeometryNV(
        E_GeometryTypeNV geometryType_= { },
        S_GeometryDataNV geometry_= { },
        VkGeometryFlagsNV flags_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_GEOMETRY_NV,
        nullptr,
        geometryType_,
        geometry_,
        flags_
    } { }
    inL S_GeometryNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_GeometryNV*() { return this; }
    inL operator S_GeometryNV const* () const { return const_cast<S_GeometryNV const*>(this); }
};
template<> struct detail::names_map<VkGeometryNV> { using T = S_GeometryNV; };
struct S_AccelerationStructureInfoNV : public VkAccelerationStructureInfoNV {
public:
    using Otype = VkAccelerationStructureInfoNV;
public:
    S_AccelerationStructureInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_AccelerationStructureInfoNV(
        E_AccelerationStructureTypeNV type_= { },
        VkBuildAccelerationStructureFlagsNV flags_= { },
        uint32_t instanceCount_= { },
        Array_general<S_GeometryNV> pGeometries_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV,
        nullptr,
        type_,
        flags_,
        instanceCount_,
        pGeometries_.size(),
        reinterpret_cast<VkGeometryNV*>(pGeometries_.data())
    } { }
    inL S_AccelerationStructureInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AccelerationStructureInfoNV*() { return this; }
    inL operator S_AccelerationStructureInfoNV const* () const { return const_cast<S_AccelerationStructureInfoNV const*>(this); }
};
template<> struct detail::names_map<VkAccelerationStructureInfoNV> { using T = S_AccelerationStructureInfoNV; };
struct S_PhysicalDeviceCooperativeMatrixFeaturesNV : public VkPhysicalDeviceCooperativeMatrixFeaturesNV {
public:
    using Otype = VkPhysicalDeviceCooperativeMatrixFeaturesNV;
public:
    S_PhysicalDeviceCooperativeMatrixFeaturesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceCooperativeMatrixFeaturesNV(
        VkBool32 cooperativeMatrix_= { },
        VkBool32 cooperativeMatrixRobustBufferAccess_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
        nullptr,
        cooperativeMatrix_,
        cooperativeMatrixRobustBufferAccess_
    } { }
    inL S_PhysicalDeviceCooperativeMatrixFeaturesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceCooperativeMatrixFeaturesNV*() { return this; }
    inL operator S_PhysicalDeviceCooperativeMatrixFeaturesNV const* () const { return const_cast<S_PhysicalDeviceCooperativeMatrixFeaturesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceCooperativeMatrixFeaturesNV> { using T = S_PhysicalDeviceCooperativeMatrixFeaturesNV; };
struct S_DedicatedAllocationMemoryAllocateInfoNV : public VkDedicatedAllocationMemoryAllocateInfoNV {
public:
    using Otype = VkDedicatedAllocationMemoryAllocateInfoNV;
public:
    S_DedicatedAllocationMemoryAllocateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_DedicatedAllocationMemoryAllocateInfoNV(
        VkImage image_= { },
        VkBuffer buffer_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
        nullptr,
        image_,
        buffer_
    } { }
    inL S_DedicatedAllocationMemoryAllocateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DedicatedAllocationMemoryAllocateInfoNV*() { return this; }
    inL operator S_DedicatedAllocationMemoryAllocateInfoNV const* () const { return const_cast<S_DedicatedAllocationMemoryAllocateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkDedicatedAllocationMemoryAllocateInfoNV> { using T = S_DedicatedAllocationMemoryAllocateInfoNV; };
struct S_PhysicalDevicePCIBusInfoPropertiesEXT : public VkPhysicalDevicePCIBusInfoPropertiesEXT {
public:
    using Otype = VkPhysicalDevicePCIBusInfoPropertiesEXT;
public:
    S_PhysicalDevicePCIBusInfoPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDevicePCIBusInfoPropertiesEXT(
        uint32_t pciDomain_= { },
        uint32_t pciBus_= { },
        uint32_t pciDevice_= { },
        uint32_t pciFunction_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT,
        nullptr,
        pciDomain_,
        pciBus_,
        pciDevice_,
        pciFunction_
    } { }
    inL S_PhysicalDevicePCIBusInfoPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDevicePCIBusInfoPropertiesEXT*() { return this; }
    inL operator S_PhysicalDevicePCIBusInfoPropertiesEXT const* () const { return const_cast<S_PhysicalDevicePCIBusInfoPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDevicePCIBusInfoPropertiesEXT> { using T = S_PhysicalDevicePCIBusInfoPropertiesEXT; };

# if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct S_ImportAndroidHardwareBufferInfoANDROID : public VkImportAndroidHardwareBufferInfoANDROID {
public:
    using Otype = VkImportAndroidHardwareBufferInfoANDROID;
public:
    S_ImportAndroidHardwareBufferInfoANDROID(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImportAndroidHardwareBufferInfoANDROID(
        Aptr<AHardwareBuffer> buffer_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
        nullptr,
        buffer_
    } { }
    inL S_ImportAndroidHardwareBufferInfoANDROID& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImportAndroidHardwareBufferInfoANDROID*() { return this; }
    inL operator S_ImportAndroidHardwareBufferInfoANDROID const* () const { return const_cast<S_ImportAndroidHardwareBufferInfoANDROID const*>(this); }
};
template<> struct detail::names_map<VkImportAndroidHardwareBufferInfoANDROID> { using T = S_ImportAndroidHardwareBufferInfoANDROID; };

#endif
struct S_PipelineTessellationDomainOriginStateCreateInfo : public VkPipelineTessellationDomainOriginStateCreateInfo {
public:
    using Otype = VkPipelineTessellationDomainOriginStateCreateInfo;
public:
    S_PipelineTessellationDomainOriginStateCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineTessellationDomainOriginStateCreateInfo(
        E_TessellationDomainOrigin domainOrigin_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
        nullptr,
        domainOrigin_
    } { }
    inL S_PipelineTessellationDomainOriginStateCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineTessellationDomainOriginStateCreateInfo*() { return this; }
    inL operator S_PipelineTessellationDomainOriginStateCreateInfo const* () const { return const_cast<S_PipelineTessellationDomainOriginStateCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkPipelineTessellationDomainOriginStateCreateInfo> { using T = S_PipelineTessellationDomainOriginStateCreateInfo; };
struct N_PipelineTessellationStateCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_PipelineTessellationStateCreateInfo& n_VkPipelineTessellationDomainOriginStateCreateInfo(Aref<S_PipelineTessellationDomainOriginStateCreateInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_PipelineTessellationStateCreateInfo : public VkPipelineTessellationStateCreateInfo {
public:
    using Otype = VkPipelineTessellationStateCreateInfo;
public:
    S_PipelineTessellationStateCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineTessellationStateCreateInfo(
        VkPipelineTessellationStateCreateFlags flags_= { },
        uint32_t patchControlPoints_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
        nullptr,
        flags_,
        patchControlPoints_
    } { }
    S_PipelineTessellationStateCreateInfo& set_next(N_PipelineTessellationStateCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_PipelineTessellationStateCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineTessellationStateCreateInfo*() { return this; }
    inL operator S_PipelineTessellationStateCreateInfo const* () const { return const_cast<S_PipelineTessellationStateCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkPipelineTessellationStateCreateInfo> { using T = S_PipelineTessellationStateCreateInfo; };
struct S_DisplayPlaneCapabilitiesKHR : public VkDisplayPlaneCapabilitiesKHR {
public:
    using Otype = VkDisplayPlaneCapabilitiesKHR;
public:
    S_DisplayPlaneCapabilitiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayPlaneCapabilitiesKHR(
        VkDisplayPlaneAlphaFlagsKHR supportedAlpha_= { },
        S_Offset2D minSrcPosition_= { },
        S_Offset2D maxSrcPosition_= { },
        S_Extent2D minSrcExtent_= { },
        S_Extent2D maxSrcExtent_= { },
        S_Offset2D minDstPosition_= { },
        S_Offset2D maxDstPosition_= { },
        S_Extent2D minDstExtent_= { },
        S_Extent2D maxDstExtent_= { }
    ) : Otype{
        supportedAlpha_,
        minSrcPosition_,
        maxSrcPosition_,
        minSrcExtent_,
        maxSrcExtent_,
        minDstPosition_,
        maxDstPosition_,
        minDstExtent_,
        maxDstExtent_
    } { }
    inL S_DisplayPlaneCapabilitiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayPlaneCapabilitiesKHR*() { return this; }
    inL operator S_DisplayPlaneCapabilitiesKHR const* () const { return const_cast<S_DisplayPlaneCapabilitiesKHR const*>(this); }
};
template<> struct detail::names_map<VkDisplayPlaneCapabilitiesKHR> { using T = S_DisplayPlaneCapabilitiesKHR; };
struct S_SurfaceCapabilitiesKHR : public VkSurfaceCapabilitiesKHR {
public:
    using Otype = VkSurfaceCapabilitiesKHR;
public:
    S_SurfaceCapabilitiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SurfaceCapabilitiesKHR(
        uint32_t minImageCount_= { },
        uint32_t maxImageCount_= { },
        S_Extent2D currentExtent_= { },
        S_Extent2D minImageExtent_= { },
        S_Extent2D maxImageExtent_= { },
        uint32_t maxImageArrayLayers_= { },
        VkSurfaceTransformFlagsKHR supportedTransforms_= { },
        F_SurfaceTransformKHR currentTransform_= { },
        VkCompositeAlphaFlagsKHR supportedCompositeAlpha_= { },
        VkImageUsageFlags supportedUsageFlags_= { }
    ) : Otype{
        minImageCount_,
        maxImageCount_,
        currentExtent_,
        minImageExtent_,
        maxImageExtent_,
        maxImageArrayLayers_,
        supportedTransforms_,
        currentTransform_,
        supportedCompositeAlpha_,
        supportedUsageFlags_
    } { }
    inL S_SurfaceCapabilitiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SurfaceCapabilitiesKHR*() { return this; }
    inL operator S_SurfaceCapabilitiesKHR const* () const { return const_cast<S_SurfaceCapabilitiesKHR const*>(this); }
};
template<> struct detail::names_map<VkSurfaceCapabilitiesKHR> { using T = S_SurfaceCapabilitiesKHR; };
struct S_PhysicalDeviceRayTracingPropertiesNV : public VkPhysicalDeviceRayTracingPropertiesNV {
public:
    using Otype = VkPhysicalDeviceRayTracingPropertiesNV;
public:
    S_PhysicalDeviceRayTracingPropertiesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceRayTracingPropertiesNV(
        uint32_t shaderGroupHandleSize_= { },
        uint32_t maxRecursionDepth_= { },
        uint32_t maxShaderGroupStride_= { },
        uint32_t shaderGroupBaseAlignment_= { },
        uint64_t maxGeometryCount_= { },
        uint64_t maxInstanceCount_= { },
        uint64_t maxTriangleCount_= { },
        uint32_t maxDescriptorSetAccelerationStructures_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
        nullptr,
        shaderGroupHandleSize_,
        maxRecursionDepth_,
        maxShaderGroupStride_,
        shaderGroupBaseAlignment_,
        maxGeometryCount_,
        maxInstanceCount_,
        maxTriangleCount_,
        maxDescriptorSetAccelerationStructures_
    } { }
    inL S_PhysicalDeviceRayTracingPropertiesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceRayTracingPropertiesNV*() { return this; }
    inL operator S_PhysicalDeviceRayTracingPropertiesNV const* () const { return const_cast<S_PhysicalDeviceRayTracingPropertiesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceRayTracingPropertiesNV> { using T = S_PhysicalDeviceRayTracingPropertiesNV; };
struct S_AttachmentReference2KHR : public VkAttachmentReference2KHR {
public:
    using Otype = VkAttachmentReference2KHR;
public:
    S_AttachmentReference2KHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_AttachmentReference2KHR(
        uint32_t attachment_= { },
        E_ImageLayout layout_= { },
        VkImageAspectFlags aspectMask_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR,
        nullptr,
        attachment_,
        layout_,
        aspectMask_
    } { }
    inL S_AttachmentReference2KHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AttachmentReference2KHR*() { return this; }
    inL operator S_AttachmentReference2KHR const* () const { return const_cast<S_AttachmentReference2KHR const*>(this); }
};
template<> struct detail::names_map<VkAttachmentReference2KHR> { using T = S_AttachmentReference2KHR; };
struct S_SubpassDescriptionDepthStencilResolveKHR : public VkSubpassDescriptionDepthStencilResolveKHR {
public:
    using Otype = VkSubpassDescriptionDepthStencilResolveKHR;
public:
    S_SubpassDescriptionDepthStencilResolveKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SubpassDescriptionDepthStencilResolveKHR(
        F_ResolveModeKHR depthResolveMode_= { },
        F_ResolveModeKHR stencilResolveMode_= { },
        Aptr<S_AttachmentReference2KHR> pDepthStencilResolveAttachment_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR,
        nullptr,
        depthResolveMode_,
        stencilResolveMode_,
        pDepthStencilResolveAttachment_
    } { }
    inL S_SubpassDescriptionDepthStencilResolveKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SubpassDescriptionDepthStencilResolveKHR*() { return this; }
    inL operator S_SubpassDescriptionDepthStencilResolveKHR const* () const { return const_cast<S_SubpassDescriptionDepthStencilResolveKHR const*>(this); }
};
template<> struct detail::names_map<VkSubpassDescriptionDepthStencilResolveKHR> { using T = S_SubpassDescriptionDepthStencilResolveKHR; };
struct S_PhysicalDeviceBlendOperationAdvancedFeaturesEXT : public VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT;
public:
    S_PhysicalDeviceBlendOperationAdvancedFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceBlendOperationAdvancedFeaturesEXT(
        VkBool32 advancedBlendCoherentOperations_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
        nullptr,
        advancedBlendCoherentOperations_
    } { }
    inL S_PhysicalDeviceBlendOperationAdvancedFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceBlendOperationAdvancedFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceBlendOperationAdvancedFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceBlendOperationAdvancedFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT> { using T = S_PhysicalDeviceBlendOperationAdvancedFeaturesEXT; };
struct N_SubpassDescription2KHR{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_SubpassDescription2KHR& n_VkSubpassDescriptionDepthStencilResolveKHR(Aref<S_SubpassDescriptionDepthStencilResolveKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_SubpassDescription2KHR : public VkSubpassDescription2KHR {
public:
    using Otype = VkSubpassDescription2KHR;
public:
    S_SubpassDescription2KHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SubpassDescription2KHR(
        VkSubpassDescriptionFlags flags_= { },
        E_PipelineBindPoint pipelineBindPoint_= { },
        uint32_t viewMask_= { },
        Array_general<S_AttachmentReference2KHR> pInputAttachments_= { },
        Array_general<S_AttachmentReference2KHR> pColorAttachments_= { },
        Array_general<S_AttachmentReference2KHR> pResolveAttachments_= { },
        Aptr<S_AttachmentReference2KHR> pDepthStencilAttachment_= { },
        Array_general<uint32_t> pPreserveAttachments_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR,
        nullptr,
        flags_,
        pipelineBindPoint_,
        viewMask_,
        pInputAttachments_.size(),
        reinterpret_cast<VkAttachmentReference2KHR*>(pInputAttachments_.data()),
        pColorAttachments_.size(),
        reinterpret_cast<VkAttachmentReference2KHR*>(pColorAttachments_.data()),
        reinterpret_cast<VkAttachmentReference2KHR*>(pResolveAttachments_.data()),
        pDepthStencilAttachment_,
        pPreserveAttachments_.size(),
        reinterpret_cast<uint32_t*>(pPreserveAttachments_.data())
    } { }
    S_SubpassDescription2KHR& set_next(N_SubpassDescription2KHR& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_SubpassDescription2KHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SubpassDescription2KHR*() { return this; }
    inL operator S_SubpassDescription2KHR const* () const { return const_cast<S_SubpassDescription2KHR const*>(this); }
};
template<> struct detail::names_map<VkSubpassDescription2KHR> { using T = S_SubpassDescription2KHR; };
struct S_BindBufferMemoryDeviceGroupInfo : public VkBindBufferMemoryDeviceGroupInfo {
public:
    using Otype = VkBindBufferMemoryDeviceGroupInfo;
public:
    S_BindBufferMemoryDeviceGroupInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_BindBufferMemoryDeviceGroupInfo(
        Array_general<uint32_t> pDeviceIndices_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
        nullptr,
        pDeviceIndices_.size(),
        reinterpret_cast<uint32_t*>(pDeviceIndices_.data())
    } { }
    inL S_BindBufferMemoryDeviceGroupInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BindBufferMemoryDeviceGroupInfo*() { return this; }
    inL operator S_BindBufferMemoryDeviceGroupInfo const* () const { return const_cast<S_BindBufferMemoryDeviceGroupInfo const*>(this); }
};
template<> struct detail::names_map<VkBindBufferMemoryDeviceGroupInfo> { using T = S_BindBufferMemoryDeviceGroupInfo; };
struct S_MemoryHeap : public VkMemoryHeap {
public:
    using Otype = VkMemoryHeap;
public:
    S_MemoryHeap(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryHeap(
        VkDeviceSize size_= { },
        VkMemoryHeapFlags flags_= { }
    ) : Otype{
        size_,
        flags_
    } { }
    inL S_MemoryHeap& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryHeap*() { return this; }
    inL operator S_MemoryHeap const* () const { return const_cast<S_MemoryHeap const*>(this); }
};
template<> struct detail::names_map<VkMemoryHeap> { using T = S_MemoryHeap; };
struct S_VertexInputBindingDescription : public VkVertexInputBindingDescription {
public:
    using Otype = VkVertexInputBindingDescription;
public:
    S_VertexInputBindingDescription(Otype& origin_obj_):Otype(origin_obj_){}
    S_VertexInputBindingDescription(
        uint32_t binding_= { },
        uint32_t stride_= { },
        E_VertexInputRate inputRate_= { }
    ) : Otype{
        binding_,
        stride_,
        inputRate_
    } { }
    inL S_VertexInputBindingDescription& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_VertexInputBindingDescription*() { return this; }
    inL operator S_VertexInputBindingDescription const* () const { return const_cast<S_VertexInputBindingDescription const*>(this); }
};
template<> struct detail::names_map<VkVertexInputBindingDescription> { using T = S_VertexInputBindingDescription; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_ImportMemoryWin32HandleInfoKHR : public VkImportMemoryWin32HandleInfoKHR {
public:
    using Otype = VkImportMemoryWin32HandleInfoKHR;
public:
    S_ImportMemoryWin32HandleInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImportMemoryWin32HandleInfoKHR(
        F_ExternalMemoryHandleType handleType_= { },
        HANDLE handle_= { },
        LPCWSTR name_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
        nullptr,
        handleType_,
        handle_,
        name_
    } { }
    inL S_ImportMemoryWin32HandleInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImportMemoryWin32HandleInfoKHR*() { return this; }
    inL operator S_ImportMemoryWin32HandleInfoKHR const* () const { return const_cast<S_ImportMemoryWin32HandleInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkImportMemoryWin32HandleInfoKHR> { using T = S_ImportMemoryWin32HandleInfoKHR; };

#endif
struct S_PhysicalDeviceSubgroupProperties : public VkPhysicalDeviceSubgroupProperties {
public:
    using Otype = VkPhysicalDeviceSubgroupProperties;
public:
    S_PhysicalDeviceSubgroupProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceSubgroupProperties(
        uint32_t subgroupSize_= { },
        VkShaderStageFlags supportedStages_= { },
        VkSubgroupFeatureFlags supportedOperations_= { },
        VkBool32 quadOperationsInAllStages_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
        nullptr,
        subgroupSize_,
        supportedStages_,
        supportedOperations_,
        quadOperationsInAllStages_
    } { }
    inL S_PhysicalDeviceSubgroupProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceSubgroupProperties*() { return this; }
    inL operator S_PhysicalDeviceSubgroupProperties const* () const { return const_cast<S_PhysicalDeviceSubgroupProperties const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceSubgroupProperties> { using T = S_PhysicalDeviceSubgroupProperties; };
struct S_PhysicalDeviceExternalFenceInfo : public VkPhysicalDeviceExternalFenceInfo {
public:
    using Otype = VkPhysicalDeviceExternalFenceInfo;
public:
    S_PhysicalDeviceExternalFenceInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceExternalFenceInfo(
        F_ExternalFenceHandleType handleType_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
        nullptr,
        handleType_
    } { }
    inL S_PhysicalDeviceExternalFenceInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceExternalFenceInfo*() { return this; }
    inL operator S_PhysicalDeviceExternalFenceInfo const* () const { return const_cast<S_PhysicalDeviceExternalFenceInfo const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceExternalFenceInfo> { using T = S_PhysicalDeviceExternalFenceInfo; };
struct S_PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL : public VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
public:
    using Otype = VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL;
public:
    S_PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(
        VkBool32 shaderIntegerFunctions2_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL,
        nullptr,
        shaderIntegerFunctions2_
    } { }
    inL S_PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*() { return this; }
    inL operator S_PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const* () const { return const_cast<S_PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL> { using T = S_PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL; };
struct S_BindImageMemorySwapchainInfoKHR : public VkBindImageMemorySwapchainInfoKHR {
public:
    using Otype = VkBindImageMemorySwapchainInfoKHR;
public:
    S_BindImageMemorySwapchainInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_BindImageMemorySwapchainInfoKHR(
        VkSwapchainKHR swapchain_= { },
        uint32_t imageIndex_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
        nullptr,
        swapchain_,
        imageIndex_
    } { }
    inL S_BindImageMemorySwapchainInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BindImageMemorySwapchainInfoKHR*() { return this; }
    inL operator S_BindImageMemorySwapchainInfoKHR const* () const { return const_cast<S_BindImageMemorySwapchainInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkBindImageMemorySwapchainInfoKHR> { using T = S_BindImageMemorySwapchainInfoKHR; };
struct S_BindImagePlaneMemoryInfo : public VkBindImagePlaneMemoryInfo {
public:
    using Otype = VkBindImagePlaneMemoryInfo;
public:
    S_BindImagePlaneMemoryInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_BindImagePlaneMemoryInfo(
        F_ImageAspect planeAspect_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
        nullptr,
        planeAspect_
    } { }
    inL S_BindImagePlaneMemoryInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BindImagePlaneMemoryInfo*() { return this; }
    inL operator S_BindImagePlaneMemoryInfo const* () const { return const_cast<S_BindImagePlaneMemoryInfo const*>(this); }
};
template<> struct detail::names_map<VkBindImagePlaneMemoryInfo> { using T = S_BindImagePlaneMemoryInfo; };
struct S_BindImageMemoryDeviceGroupInfo : public VkBindImageMemoryDeviceGroupInfo {
public:
    using Otype = VkBindImageMemoryDeviceGroupInfo;
public:
    S_BindImageMemoryDeviceGroupInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_BindImageMemoryDeviceGroupInfo(
        Array_general<uint32_t> pDeviceIndices_= { },
        Array_general<S_Rect2D> pSplitInstanceBindRegions_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
        nullptr,
        pDeviceIndices_.size(),
        reinterpret_cast<uint32_t*>(pDeviceIndices_.data()),
        pSplitInstanceBindRegions_.size(),
        reinterpret_cast<VkRect2D*>(pSplitInstanceBindRegions_.data())
    } { }
    inL S_BindImageMemoryDeviceGroupInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BindImageMemoryDeviceGroupInfo*() { return this; }
    inL operator S_BindImageMemoryDeviceGroupInfo const* () const { return const_cast<S_BindImageMemoryDeviceGroupInfo const*>(this); }
};
template<> struct detail::names_map<VkBindImageMemoryDeviceGroupInfo> { using T = S_BindImageMemoryDeviceGroupInfo; };
struct N_BindImageMemoryInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_BindImageMemoryInfo& n_VkBindImageMemorySwapchainInfoKHR(Aref<S_BindImageMemorySwapchainInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_BindImageMemoryInfo& n_VkBindImagePlaneMemoryInfo(Aref<S_BindImagePlaneMemoryInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_BindImageMemoryInfo& n_VkBindImageMemoryDeviceGroupInfo(Aref<S_BindImageMemoryDeviceGroupInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_BindImageMemoryInfo : public VkBindImageMemoryInfo {
public:
    using Otype = VkBindImageMemoryInfo;
public:
    S_BindImageMemoryInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_BindImageMemoryInfo(
        VkImage image_= { },
        VkDeviceMemory memory_= { },
        VkDeviceSize memoryOffset_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
        nullptr,
        image_,
        memory_,
        memoryOffset_
    } { }
    S_BindImageMemoryInfo& set_next(N_BindImageMemoryInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_BindImageMemoryInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BindImageMemoryInfo*() { return this; }
    inL operator S_BindImageMemoryInfo const* () const { return const_cast<S_BindImageMemoryInfo const*>(this); }
};
template<> struct detail::names_map<VkBindImageMemoryInfo> { using T = S_BindImageMemoryInfo; };
struct S_DisplayEventInfoEXT : public VkDisplayEventInfoEXT {
public:
    using Otype = VkDisplayEventInfoEXT;
public:
    S_DisplayEventInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayEventInfoEXT(
        E_DisplayEventTypeEXT displayEvent_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT,
        nullptr,
        displayEvent_
    } { }
    inL S_DisplayEventInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayEventInfoEXT*() { return this; }
    inL operator S_DisplayEventInfoEXT const* () const { return const_cast<S_DisplayEventInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDisplayEventInfoEXT> { using T = S_DisplayEventInfoEXT; };
struct S_CommandBufferInheritanceConditionalRenderingInfoEXT : public VkCommandBufferInheritanceConditionalRenderingInfoEXT {
public:
    using Otype = VkCommandBufferInheritanceConditionalRenderingInfoEXT;
public:
    S_CommandBufferInheritanceConditionalRenderingInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_CommandBufferInheritanceConditionalRenderingInfoEXT(
        VkBool32 conditionalRenderingEnable_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
        nullptr,
        conditionalRenderingEnable_
    } { }
    inL S_CommandBufferInheritanceConditionalRenderingInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_CommandBufferInheritanceConditionalRenderingInfoEXT*() { return this; }
    inL operator S_CommandBufferInheritanceConditionalRenderingInfoEXT const* () const { return const_cast<S_CommandBufferInheritanceConditionalRenderingInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkCommandBufferInheritanceConditionalRenderingInfoEXT> { using T = S_CommandBufferInheritanceConditionalRenderingInfoEXT; };
struct N_CommandBufferInheritanceInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_CommandBufferInheritanceInfo& n_VkCommandBufferInheritanceConditionalRenderingInfoEXT(Aref<S_CommandBufferInheritanceConditionalRenderingInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_CommandBufferInheritanceInfo : public VkCommandBufferInheritanceInfo {
public:
    using Otype = VkCommandBufferInheritanceInfo;
public:
    S_CommandBufferInheritanceInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_CommandBufferInheritanceInfo(
        VkRenderPass renderPass_= { },
        uint32_t subpass_= { },
        VkFramebuffer framebuffer_= { },
        VkBool32 occlusionQueryEnable_= { },
        VkQueryControlFlags queryFlags_= { },
        VkQueryPipelineStatisticFlags pipelineStatistics_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
        nullptr,
        renderPass_,
        subpass_,
        framebuffer_,
        occlusionQueryEnable_,
        queryFlags_,
        pipelineStatistics_
    } { }
    S_CommandBufferInheritanceInfo& set_next(N_CommandBufferInheritanceInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_CommandBufferInheritanceInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_CommandBufferInheritanceInfo*() { return this; }
    inL operator S_CommandBufferInheritanceInfo const* () const { return const_cast<S_CommandBufferInheritanceInfo const*>(this); }
};
template<> struct detail::names_map<VkCommandBufferInheritanceInfo> { using T = S_CommandBufferInheritanceInfo; };
struct N_CommandBufferBeginInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_CommandBufferBeginInfo& n_VkDeviceGroupCommandBufferBeginInfo(Aref<S_DeviceGroupCommandBufferBeginInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_CommandBufferBeginInfo : public VkCommandBufferBeginInfo {
public:
    using Otype = VkCommandBufferBeginInfo;
public:
    S_CommandBufferBeginInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_CommandBufferBeginInfo(
        VkCommandBufferUsageFlags flags_= { },
        Aptr<S_CommandBufferInheritanceInfo> pInheritanceInfo_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
        nullptr,
        flags_,
        pInheritanceInfo_
    } { }
    S_CommandBufferBeginInfo& set_next(N_CommandBufferBeginInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_CommandBufferBeginInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_CommandBufferBeginInfo*() { return this; }
    inL operator S_CommandBufferBeginInfo const* () const { return const_cast<S_CommandBufferBeginInfo const*>(this); }
};
template<> struct detail::names_map<VkCommandBufferBeginInfo> { using T = S_CommandBufferBeginInfo; };
struct S_SharedPresentSurfaceCapabilitiesKHR : public VkSharedPresentSurfaceCapabilitiesKHR {
public:
    using Otype = VkSharedPresentSurfaceCapabilitiesKHR;
public:
    S_SharedPresentSurfaceCapabilitiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SharedPresentSurfaceCapabilitiesKHR(
        VkImageUsageFlags sharedPresentSupportedUsageFlags_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
        nullptr,
        sharedPresentSupportedUsageFlags_
    } { }
    inL S_SharedPresentSurfaceCapabilitiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SharedPresentSurfaceCapabilitiesKHR*() { return this; }
    inL operator S_SharedPresentSurfaceCapabilitiesKHR const* () const { return const_cast<S_SharedPresentSurfaceCapabilitiesKHR const*>(this); }
};
template<> struct detail::names_map<VkSharedPresentSurfaceCapabilitiesKHR> { using T = S_SharedPresentSurfaceCapabilitiesKHR; };
struct S_DispatchIndirectCommand : public VkDispatchIndirectCommand {
public:
    using Otype = VkDispatchIndirectCommand;
public:
    S_DispatchIndirectCommand(Otype& origin_obj_):Otype(origin_obj_){}
    S_DispatchIndirectCommand(
        uint32_t x_= { },
        uint32_t y_= { },
        uint32_t z_= { }
    ) : Otype{
        x_,
        y_,
        z_
    } { }
    inL S_DispatchIndirectCommand& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DispatchIndirectCommand*() { return this; }
    inL operator S_DispatchIndirectCommand const* () const { return const_cast<S_DispatchIndirectCommand const*>(this); }
};
template<> struct detail::names_map<VkDispatchIndirectCommand> { using T = S_DispatchIndirectCommand; };
struct S_ObjectTablePushConstantEntryNVX : public VkObjectTablePushConstantEntryNVX {
public:
    using Otype = VkObjectTablePushConstantEntryNVX;
public:
    S_ObjectTablePushConstantEntryNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_ObjectTablePushConstantEntryNVX(
        E_ObjectEntryTypeNVX type_= { },
        VkObjectEntryUsageFlagsNVX flags_= { },
        VkPipelineLayout pipelineLayout_= { },
        VkShaderStageFlags stageFlags_= { }
    ) : Otype{
        type_,
        flags_,
        pipelineLayout_,
        stageFlags_
    } { }
    inL S_ObjectTablePushConstantEntryNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ObjectTablePushConstantEntryNVX*() { return this; }
    inL operator S_ObjectTablePushConstantEntryNVX const* () const { return const_cast<S_ObjectTablePushConstantEntryNVX const*>(this); }
};
template<> struct detail::names_map<VkObjectTablePushConstantEntryNVX> { using T = S_ObjectTablePushConstantEntryNVX; };
struct S_PhysicalDeviceSamplerFilterMinmaxPropertiesEXT : public VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT;
public:
    S_PhysicalDeviceSamplerFilterMinmaxPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceSamplerFilterMinmaxPropertiesEXT(
        VkBool32 filterMinmaxSingleComponentFormats_= { },
        VkBool32 filterMinmaxImageComponentMapping_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT,
        nullptr,
        filterMinmaxSingleComponentFormats_,
        filterMinmaxImageComponentMapping_
    } { }
    inL S_PhysicalDeviceSamplerFilterMinmaxPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceSamplerFilterMinmaxPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceSamplerFilterMinmaxPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceSamplerFilterMinmaxPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT> { using T = S_PhysicalDeviceSamplerFilterMinmaxPropertiesEXT; };
struct S_DeviceGroupPresentInfoKHR : public VkDeviceGroupPresentInfoKHR {
public:
    using Otype = VkDeviceGroupPresentInfoKHR;
public:
    S_DeviceGroupPresentInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceGroupPresentInfoKHR(
        Array_general<uint32_t> pDeviceMasks_= { },
        F_DeviceGroupPresentModeKHR mode_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
        nullptr,
        pDeviceMasks_.size(),
        reinterpret_cast<uint32_t*>(pDeviceMasks_.data()),
        mode_
    } { }
    inL S_DeviceGroupPresentInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceGroupPresentInfoKHR*() { return this; }
    inL operator S_DeviceGroupPresentInfoKHR const* () const { return const_cast<S_DeviceGroupPresentInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkDeviceGroupPresentInfoKHR> { using T = S_DeviceGroupPresentInfoKHR; };
struct S_PresentTimeGOOGLE : public VkPresentTimeGOOGLE {
public:
    using Otype = VkPresentTimeGOOGLE;
public:
    S_PresentTimeGOOGLE(Otype& origin_obj_):Otype(origin_obj_){}
    S_PresentTimeGOOGLE(
        uint32_t presentID_= { },
        uint64_t desiredPresentTime_= { }
    ) : Otype{
        presentID_,
        desiredPresentTime_
    } { }
    inL S_PresentTimeGOOGLE& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PresentTimeGOOGLE*() { return this; }
    inL operator S_PresentTimeGOOGLE const* () const { return const_cast<S_PresentTimeGOOGLE const*>(this); }
};
template<> struct detail::names_map<VkPresentTimeGOOGLE> { using T = S_PresentTimeGOOGLE; };
struct S_PresentTimesInfoGOOGLE : public VkPresentTimesInfoGOOGLE {
public:
    using Otype = VkPresentTimesInfoGOOGLE;
public:
    S_PresentTimesInfoGOOGLE(Otype& origin_obj_):Otype(origin_obj_){}
    S_PresentTimesInfoGOOGLE(
        Array_general<S_PresentTimeGOOGLE> pTimes_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE,
        nullptr,
        pTimes_.size(),
        reinterpret_cast<VkPresentTimeGOOGLE*>(pTimes_.data())
    } { }
    inL S_PresentTimesInfoGOOGLE& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PresentTimesInfoGOOGLE*() { return this; }
    inL operator S_PresentTimesInfoGOOGLE const* () const { return const_cast<S_PresentTimesInfoGOOGLE const*>(this); }
};
template<> struct detail::names_map<VkPresentTimesInfoGOOGLE> { using T = S_PresentTimesInfoGOOGLE; };
struct S_DisplayPresentInfoKHR : public VkDisplayPresentInfoKHR {
public:
    using Otype = VkDisplayPresentInfoKHR;
public:
    S_DisplayPresentInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayPresentInfoKHR(
        S_Rect2D srcRect_= { },
        S_Rect2D dstRect_= { },
        VkBool32 persistent_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR,
        nullptr,
        srcRect_,
        dstRect_,
        persistent_
    } { }
    inL S_DisplayPresentInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayPresentInfoKHR*() { return this; }
    inL operator S_DisplayPresentInfoKHR const* () const { return const_cast<S_DisplayPresentInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkDisplayPresentInfoKHR> { using T = S_DisplayPresentInfoKHR; };
struct S_RectLayerKHR : public VkRectLayerKHR {
public:
    using Otype = VkRectLayerKHR;
public:
    S_RectLayerKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_RectLayerKHR(
        S_Offset2D offset_= { },
        S_Extent2D extent_= { },
        uint32_t layer_= { }
    ) : Otype{
        offset_,
        extent_,
        layer_
    } { }
    inL S_RectLayerKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_RectLayerKHR*() { return this; }
    inL operator S_RectLayerKHR const* () const { return const_cast<S_RectLayerKHR const*>(this); }
};
template<> struct detail::names_map<VkRectLayerKHR> { using T = S_RectLayerKHR; };
struct S_PresentRegionKHR : public VkPresentRegionKHR {
public:
    using Otype = VkPresentRegionKHR;
public:
    S_PresentRegionKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PresentRegionKHR(
        Array_general<S_RectLayerKHR> pRectangles_= { }
    ) : Otype{
        pRectangles_.size(),
        reinterpret_cast<VkRectLayerKHR*>(pRectangles_.data())
    } { }
    inL S_PresentRegionKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PresentRegionKHR*() { return this; }
    inL operator S_PresentRegionKHR const* () const { return const_cast<S_PresentRegionKHR const*>(this); }
};
template<> struct detail::names_map<VkPresentRegionKHR> { using T = S_PresentRegionKHR; };
struct S_PresentRegionsKHR : public VkPresentRegionsKHR {
public:
    using Otype = VkPresentRegionsKHR;
public:
    S_PresentRegionsKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PresentRegionsKHR(
        Array_general<S_PresentRegionKHR> pRegions_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR,
        nullptr,
        pRegions_.size(),
        reinterpret_cast<VkPresentRegionKHR*>(pRegions_.data())
    } { }
    inL S_PresentRegionsKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PresentRegionsKHR*() { return this; }
    inL operator S_PresentRegionsKHR const* () const { return const_cast<S_PresentRegionsKHR const*>(this); }
};
template<> struct detail::names_map<VkPresentRegionsKHR> { using T = S_PresentRegionsKHR; };

# if defined(VK_USE_PLATFORM_GGP)
struct S_PresentFrameTokenGGP : public VkPresentFrameTokenGGP {
public:
    using Otype = VkPresentFrameTokenGGP;
public:
    S_PresentFrameTokenGGP(Otype& origin_obj_):Otype(origin_obj_){}
    S_PresentFrameTokenGGP(
        GgpFrameToken frameToken_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP,
        nullptr,
        frameToken_
    } { }
    inL S_PresentFrameTokenGGP& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PresentFrameTokenGGP*() { return this; }
    inL operator S_PresentFrameTokenGGP const* () const { return const_cast<S_PresentFrameTokenGGP const*>(this); }
};
template<> struct detail::names_map<VkPresentFrameTokenGGP> { using T = S_PresentFrameTokenGGP; };

#endif
struct N_PresentInfoKHR{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_PresentInfoKHR& n_VkDeviceGroupPresentInfoKHR(Aref<S_DeviceGroupPresentInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PresentInfoKHR& n_VkPresentTimesInfoGOOGLE(Aref<S_PresentTimesInfoGOOGLE> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PresentInfoKHR& n_VkDisplayPresentInfoKHR(Aref<S_DisplayPresentInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PresentInfoKHR& n_VkPresentRegionsKHR(Aref<S_PresentRegionsKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# if defined(VK_USE_PLATFORM_GGP)
    inL N_PresentInfoKHR& n_VkPresentFrameTokenGGP(Aref<S_PresentFrameTokenGGP> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
};
struct S_PresentInfoKHR : public VkPresentInfoKHR {
public:
    using Otype = VkPresentInfoKHR;
public:
    S_PresentInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PresentInfoKHR(
        Array_general<VkSemaphore> pWaitSemaphores_= { },
        Array_general<VkSwapchainKHR> pSwapchains_= { },
        Array_general<uint32_t> pImageIndices_= { },
        Array_general<E_Result> pResults_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
        nullptr,
        pWaitSemaphores_.size(),
        reinterpret_cast<VkSemaphore*>(pWaitSemaphores_.data()),
        pSwapchains_.size(),
        reinterpret_cast<VkSwapchainKHR*>(pSwapchains_.data()),
        reinterpret_cast<uint32_t*>(pImageIndices_.data()),
        reinterpret_cast<VkResult*>(pResults_.data())
    } { }
# if defined(VK_USE_PLATFORM_GGP)
    inL S_PresentInfoKHR& n_VkPresentFrameTokenGGP(Aref<S_PresentFrameTokenGGP> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    S_PresentInfoKHR& set_next(N_PresentInfoKHR& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_PresentInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PresentInfoKHR*() { return this; }
    inL operator S_PresentInfoKHR const* () const { return const_cast<S_PresentInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkPresentInfoKHR> { using T = S_PresentInfoKHR; };
struct S_ConformanceVersionKHR : public VkConformanceVersionKHR {
public:
    using Otype = VkConformanceVersionKHR;
public:
    S_ConformanceVersionKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_ConformanceVersionKHR(
        uint8_t major_= { },
        uint8_t minor_= { },
        uint8_t subminor_= { },
        uint8_t patch_= { }
    ) : Otype{
        major_,
        minor_,
        subminor_,
        patch_
    } { }
    inL S_ConformanceVersionKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ConformanceVersionKHR*() { return this; }
    inL operator S_ConformanceVersionKHR const* () const { return const_cast<S_ConformanceVersionKHR const*>(this); }
};
template<> struct detail::names_map<VkConformanceVersionKHR> { using T = S_ConformanceVersionKHR; };
struct S_PhysicalDeviceDriverPropertiesKHR : public VkPhysicalDeviceDriverPropertiesKHR {
public:
    using Otype = VkPhysicalDeviceDriverPropertiesKHR;
public:
    S_PhysicalDeviceDriverPropertiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceDriverPropertiesKHR(
        E_DriverIdKHR driverID_= { },
        std::array<char,VK_MAX_DRIVER_NAME_SIZE_KHR> driverName_= { },
        std::array<char,VK_MAX_DRIVER_INFO_SIZE_KHR> driverInfo_= { },
        S_ConformanceVersionKHR conformanceVersion_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR,
        nullptr,
        driverID_,
        { },
        { },
        conformanceVersion_
    } { 
        ::memcpy(&driverName[0], driverName_.data(), driverName_.size() );
        ::memcpy(&driverInfo[0], driverInfo_.data(), driverInfo_.size() );
    }
    inL S_PhysicalDeviceDriverPropertiesKHR& 
        set_driverName(std::array<char,VK_MAX_DRIVER_NAME_SIZE_KHR> driverName_)
        {  return *this; }
    inL S_PhysicalDeviceDriverPropertiesKHR& 
        set_driverInfo(std::array<char,VK_MAX_DRIVER_INFO_SIZE_KHR> driverInfo_)
        {  return *this; }
    inL S_PhysicalDeviceDriverPropertiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceDriverPropertiesKHR*() { return this; }
    inL operator S_PhysicalDeviceDriverPropertiesKHR const* () const { return const_cast<S_PhysicalDeviceDriverPropertiesKHR const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceDriverPropertiesKHR> { using T = S_PhysicalDeviceDriverPropertiesKHR; };
struct S_PhysicalDeviceCooperativeMatrixPropertiesNV : public VkPhysicalDeviceCooperativeMatrixPropertiesNV {
public:
    using Otype = VkPhysicalDeviceCooperativeMatrixPropertiesNV;
public:
    S_PhysicalDeviceCooperativeMatrixPropertiesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceCooperativeMatrixPropertiesNV(
        VkShaderStageFlags cooperativeMatrixSupportedStages_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
        nullptr,
        cooperativeMatrixSupportedStages_
    } { }
    inL S_PhysicalDeviceCooperativeMatrixPropertiesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceCooperativeMatrixPropertiesNV*() { return this; }
    inL operator S_PhysicalDeviceCooperativeMatrixPropertiesNV const* () const { return const_cast<S_PhysicalDeviceCooperativeMatrixPropertiesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceCooperativeMatrixPropertiesNV> { using T = S_PhysicalDeviceCooperativeMatrixPropertiesNV; };
struct S_SparseImageFormatProperties : public VkSparseImageFormatProperties {
public:
    using Otype = VkSparseImageFormatProperties;
public:
    S_SparseImageFormatProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_SparseImageFormatProperties(
        VkImageAspectFlags aspectMask_= { },
        S_Extent3D imageGranularity_= { },
        VkSparseImageFormatFlags flags_= { }
    ) : Otype{
        aspectMask_,
        imageGranularity_,
        flags_
    } { }
    inL S_SparseImageFormatProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SparseImageFormatProperties*() { return this; }
    inL operator S_SparseImageFormatProperties const* () const { return const_cast<S_SparseImageFormatProperties const*>(this); }
};
template<> struct detail::names_map<VkSparseImageFormatProperties> { using T = S_SparseImageFormatProperties; };
struct S_ExtensionProperties : public VkExtensionProperties {
public:
    using Otype = VkExtensionProperties;
public:
    S_ExtensionProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExtensionProperties(
        std::array<char,VK_MAX_EXTENSION_NAME_SIZE> extensionName_= { },
        uint32_t specVersion_= { }
    ) : Otype{
        { },
        specVersion_
    } { 
        ::memcpy(&extensionName[0], extensionName_.data(), extensionName_.size() );
    }
    inL S_ExtensionProperties& 
        set_extensionName(std::array<char,VK_MAX_EXTENSION_NAME_SIZE> extensionName_)
        {  return *this; }
    inL S_ExtensionProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExtensionProperties*() { return this; }
    inL operator S_ExtensionProperties const* () const { return const_cast<S_ExtensionProperties const*>(this); }
};
template<> struct detail::names_map<VkExtensionProperties> { using T = S_ExtensionProperties; };
struct S_BufferDeviceAddressCreateInfoEXT : public VkBufferDeviceAddressCreateInfoEXT {
public:
    using Otype = VkBufferDeviceAddressCreateInfoEXT;
public:
    S_BufferDeviceAddressCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_BufferDeviceAddressCreateInfoEXT(
        VkDeviceAddress deviceAddress_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
        nullptr,
        deviceAddress_
    } { }
    inL S_BufferDeviceAddressCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BufferDeviceAddressCreateInfoEXT*() { return this; }
    inL operator S_BufferDeviceAddressCreateInfoEXT const* () const { return const_cast<S_BufferDeviceAddressCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkBufferDeviceAddressCreateInfoEXT> { using T = S_BufferDeviceAddressCreateInfoEXT; };
struct S_Offset3D : public VkOffset3D {
public:
    using Otype = VkOffset3D;
public:
    S_Offset3D(Otype& origin_obj_):Otype(origin_obj_){}
    S_Offset3D(
        int32_t x_= { },
        int32_t y_= { },
        int32_t z_= { }
    ) : Otype{
        x_,
        y_,
        z_
    } { }
    inL S_Offset3D& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_Offset3D*() { return this; }
    inL operator S_Offset3D const* () const { return const_cast<S_Offset3D const*>(this); }
};
template<> struct detail::names_map<VkOffset3D> { using T = S_Offset3D; };
struct S_AccelerationStructureMemoryRequirementsInfoNV : public VkAccelerationStructureMemoryRequirementsInfoNV {
public:
    using Otype = VkAccelerationStructureMemoryRequirementsInfoNV;
public:
    S_AccelerationStructureMemoryRequirementsInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_AccelerationStructureMemoryRequirementsInfoNV(
        E_AccelerationStructureMemoryRequirementsTypeNV type_= { },
        VkAccelerationStructureNV accelerationStructure_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV,
        nullptr,
        type_,
        accelerationStructure_
    } { }
    inL S_AccelerationStructureMemoryRequirementsInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AccelerationStructureMemoryRequirementsInfoNV*() { return this; }
    inL operator S_AccelerationStructureMemoryRequirementsInfoNV const* () const { return const_cast<S_AccelerationStructureMemoryRequirementsInfoNV const*>(this); }
};
template<> struct detail::names_map<VkAccelerationStructureMemoryRequirementsInfoNV> { using T = S_AccelerationStructureMemoryRequirementsInfoNV; };
struct S_DeviceGeneratedCommandsLimitsNVX : public VkDeviceGeneratedCommandsLimitsNVX {
public:
    using Otype = VkDeviceGeneratedCommandsLimitsNVX;
public:
    S_DeviceGeneratedCommandsLimitsNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceGeneratedCommandsLimitsNVX(
        uint32_t maxIndirectCommandsLayoutTokenCount_= { },
        uint32_t maxObjectEntryCounts_= { },
        uint32_t minSequenceCountBufferOffsetAlignment_= { },
        uint32_t minSequenceIndexBufferOffsetAlignment_= { },
        uint32_t minCommandsTokenBufferOffsetAlignment_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX,
        nullptr,
        maxIndirectCommandsLayoutTokenCount_,
        maxObjectEntryCounts_,
        minSequenceCountBufferOffsetAlignment_,
        minSequenceIndexBufferOffsetAlignment_,
        minCommandsTokenBufferOffsetAlignment_
    } { }
    inL S_DeviceGeneratedCommandsLimitsNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceGeneratedCommandsLimitsNVX*() { return this; }
    inL operator S_DeviceGeneratedCommandsLimitsNVX const* () const { return const_cast<S_DeviceGeneratedCommandsLimitsNVX const*>(this); }
};
template<> struct detail::names_map<VkDeviceGeneratedCommandsLimitsNVX> { using T = S_DeviceGeneratedCommandsLimitsNVX; };
struct S_MemoryRequirements : public VkMemoryRequirements {
public:
    using Otype = VkMemoryRequirements;
public:
    S_MemoryRequirements(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryRequirements(
        VkDeviceSize size_= { },
        VkDeviceSize alignment_= { },
        uint32_t memoryTypeBits_= { }
    ) : Otype{
        size_,
        alignment_,
        memoryTypeBits_
    } { }
    inL S_MemoryRequirements& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryRequirements*() { return this; }
    inL operator S_MemoryRequirements const* () const { return const_cast<S_MemoryRequirements const*>(this); }
};
template<> struct detail::names_map<VkMemoryRequirements> { using T = S_MemoryRequirements; };
struct S_MemoryDedicatedRequirements : public VkMemoryDedicatedRequirements {
public:
    using Otype = VkMemoryDedicatedRequirements;
public:
    S_MemoryDedicatedRequirements(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryDedicatedRequirements(
        VkBool32 prefersDedicatedAllocation_= { },
        VkBool32 requiresDedicatedAllocation_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
        nullptr,
        prefersDedicatedAllocation_,
        requiresDedicatedAllocation_
    } { }
    inL S_MemoryDedicatedRequirements& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryDedicatedRequirements*() { return this; }
    inL operator S_MemoryDedicatedRequirements const* () const { return const_cast<S_MemoryDedicatedRequirements const*>(this); }
};
template<> struct detail::names_map<VkMemoryDedicatedRequirements> { using T = S_MemoryDedicatedRequirements; };
struct N_MemoryRequirements2{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_MemoryRequirements2& n_VkMemoryDedicatedRequirements(Aref<S_MemoryDedicatedRequirements> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_MemoryRequirements2 : public VkMemoryRequirements2 {
public:
    using Otype = VkMemoryRequirements2;
public:
    S_MemoryRequirements2(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryRequirements2(
        S_MemoryRequirements memoryRequirements_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
        nullptr,
        memoryRequirements_
    } { }
    S_MemoryRequirements2& set_next(N_MemoryRequirements2& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_MemoryRequirements2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryRequirements2*() { return this; }
    inL operator S_MemoryRequirements2 const* () const { return const_cast<S_MemoryRequirements2 const*>(this); }
};
template<> struct detail::names_map<VkMemoryRequirements2> { using T = S_MemoryRequirements2; };
struct S_SwapchainCounterCreateInfoEXT : public VkSwapchainCounterCreateInfoEXT {
public:
    using Otype = VkSwapchainCounterCreateInfoEXT;
public:
    S_SwapchainCounterCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_SwapchainCounterCreateInfoEXT(
        VkSurfaceCounterFlagsEXT surfaceCounters_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
        nullptr,
        surfaceCounters_
    } { }
    inL S_SwapchainCounterCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SwapchainCounterCreateInfoEXT*() { return this; }
    inL operator S_SwapchainCounterCreateInfoEXT const* () const { return const_cast<S_SwapchainCounterCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkSwapchainCounterCreateInfoEXT> { using T = S_SwapchainCounterCreateInfoEXT; };
struct S_ImageViewHandleInfoNVX : public VkImageViewHandleInfoNVX {
public:
    using Otype = VkImageViewHandleInfoNVX;
public:
    S_ImageViewHandleInfoNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageViewHandleInfoNVX(
        VkImageView imageView_= { },
        E_DescriptorType descriptorType_= { },
        VkSampler sampler_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX,
        nullptr,
        imageView_,
        descriptorType_,
        sampler_
    } { }
    inL S_ImageViewHandleInfoNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageViewHandleInfoNVX*() { return this; }
    inL operator S_ImageViewHandleInfoNVX const* () const { return const_cast<S_ImageViewHandleInfoNVX const*>(this); }
};
template<> struct detail::names_map<VkImageViewHandleInfoNVX> { using T = S_ImageViewHandleInfoNVX; };
struct S_MemoryGetFdInfoKHR : public VkMemoryGetFdInfoKHR {
public:
    using Otype = VkMemoryGetFdInfoKHR;
public:
    S_MemoryGetFdInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryGetFdInfoKHR(
        VkDeviceMemory memory_= { },
        F_ExternalMemoryHandleType handleType_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR,
        nullptr,
        memory_,
        handleType_
    } { }
    inL S_MemoryGetFdInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryGetFdInfoKHR*() { return this; }
    inL operator S_MemoryGetFdInfoKHR const* () const { return const_cast<S_MemoryGetFdInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkMemoryGetFdInfoKHR> { using T = S_MemoryGetFdInfoKHR; };
struct S_SpecializationMapEntry : public VkSpecializationMapEntry {
public:
    using Otype = VkSpecializationMapEntry;
public:
    S_SpecializationMapEntry(Otype& origin_obj_):Otype(origin_obj_){}
    S_SpecializationMapEntry(
        uint32_t constantID_= { },
        uint32_t offset_= { },
        size_t size_= { }
    ) : Otype{
        constantID_,
        offset_,
        size_
    } { }
    inL S_SpecializationMapEntry& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SpecializationMapEntry*() { return this; }
    inL operator S_SpecializationMapEntry const* () const { return const_cast<S_SpecializationMapEntry const*>(this); }
};
template<> struct detail::names_map<VkSpecializationMapEntry> { using T = S_SpecializationMapEntry; };
struct S_SpecializationInfo : public VkSpecializationInfo {
public:
    using Otype = VkSpecializationInfo;
public:
    S_SpecializationInfo(Otype& origin_obj_):Otype(origin_obj_){ }
    S_SpecializationInfo(
        Array_general<S_SpecializationMapEntry> pMapEntries_= { },
        Array_general<void> pData_= { }
    ) : Otype{
        pMapEntries_.size(),
        reinterpret_cast<VkSpecializationMapEntry*>(pMapEntries_.data()),
        pData_.size(),
        reinterpret_cast<void*>(pData_.data())
    } { }
    inL S_SpecializationInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SpecializationInfo*() { return this; }
    inL operator S_SpecializationInfo const* () const { return const_cast<S_SpecializationInfo const*>(this); }
};
template<> struct detail::names_map<VkSpecializationInfo> { using T = S_SpecializationInfo; };
struct S_PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT : public VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT {
public:
    using Otype = VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT;
public:
    S_PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(
        uint32_t requiredSubgroupSize_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT,
        nullptr,
        requiredSubgroupSize_
    } { }
    inL S_PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT*() { return this; }
    inL operator S_PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const* () const { return const_cast<S_PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT> { using T = S_PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT; };
struct N_PipelineShaderStageCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_PipelineShaderStageCreateInfo& n_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(Aref<S_PipelineShaderStageRequiredSubgroupSizeCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_PipelineShaderStageCreateInfo : public VkPipelineShaderStageCreateInfo {
public:
    using Otype = VkPipelineShaderStageCreateInfo;
public:
    S_PipelineShaderStageCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineShaderStageCreateInfo(
        VkPipelineShaderStageCreateFlags flags_= { },
        F_ShaderStage stage_= { },
        VkShaderModule module_= { },
        Aptr<char> pName_= { },
        Aptr<S_SpecializationInfo> pSpecializationInfo_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
        nullptr,
        flags_,
        stage_,
        module_,
        pName_,
        pSpecializationInfo_
    } { }
    S_PipelineShaderStageCreateInfo& set_next(N_PipelineShaderStageCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_PipelineShaderStageCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineShaderStageCreateInfo*() { return this; }
    inL operator S_PipelineShaderStageCreateInfo const* () const { return const_cast<S_PipelineShaderStageCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkPipelineShaderStageCreateInfo> { using T = S_PipelineShaderStageCreateInfo; };
struct S_RayTracingShaderGroupCreateInfoNV : public VkRayTracingShaderGroupCreateInfoNV {
public:
    using Otype = VkRayTracingShaderGroupCreateInfoNV;
public:
    S_RayTracingShaderGroupCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_RayTracingShaderGroupCreateInfoNV(
        E_RayTracingShaderGroupTypeNV type_= { },
        uint32_t generalShader_= { },
        uint32_t closestHitShader_= { },
        uint32_t anyHitShader_= { },
        uint32_t intersectionShader_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV,
        nullptr,
        type_,
        generalShader_,
        closestHitShader_,
        anyHitShader_,
        intersectionShader_
    } { }
    inL S_RayTracingShaderGroupCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_RayTracingShaderGroupCreateInfoNV*() { return this; }
    inL operator S_RayTracingShaderGroupCreateInfoNV const* () const { return const_cast<S_RayTracingShaderGroupCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkRayTracingShaderGroupCreateInfoNV> { using T = S_RayTracingShaderGroupCreateInfoNV; };
struct S_PipelineCreationFeedbackCreateInfoEXT : public VkPipelineCreationFeedbackCreateInfoEXT {
public:
    using Otype = VkPipelineCreationFeedbackCreateInfoEXT;
public:
    S_PipelineCreationFeedbackCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineCreationFeedbackCreateInfoEXT(
        Aptr<S_PipelineCreationFeedbackEXT> pPipelineCreationFeedback_= { },
        Array_general<S_PipelineCreationFeedbackEXT> pPipelineStageCreationFeedbacks_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT,
        nullptr,
        pPipelineCreationFeedback_,
        pPipelineStageCreationFeedbacks_.size(),
        reinterpret_cast<VkPipelineCreationFeedbackEXT*>(pPipelineStageCreationFeedbacks_.data())
    } { }
    inL S_PipelineCreationFeedbackCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineCreationFeedbackCreateInfoEXT*() { return this; }
    inL operator S_PipelineCreationFeedbackCreateInfoEXT const* () const { return const_cast<S_PipelineCreationFeedbackCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkPipelineCreationFeedbackCreateInfoEXT> { using T = S_PipelineCreationFeedbackCreateInfoEXT; };
struct N_RayTracingPipelineCreateInfoNV{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_RayTracingPipelineCreateInfoNV& n_VkPipelineCreationFeedbackCreateInfoEXT(Aref<S_PipelineCreationFeedbackCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_RayTracingPipelineCreateInfoNV : public VkRayTracingPipelineCreateInfoNV {
public:
    using Otype = VkRayTracingPipelineCreateInfoNV;
public:
    S_RayTracingPipelineCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_RayTracingPipelineCreateInfoNV(
        VkPipelineCreateFlags flags_= { },
        Array_general<S_PipelineShaderStageCreateInfo> pStages_= { },
        Array_general<S_RayTracingShaderGroupCreateInfoNV> pGroups_= { },
        uint32_t maxRecursionDepth_= { },
        VkPipelineLayout layout_= { },
        VkPipeline basePipelineHandle_= { },
        int32_t basePipelineIndex_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV,
        nullptr,
        flags_,
        pStages_.size(),
        reinterpret_cast<VkPipelineShaderStageCreateInfo*>(pStages_.data()),
        pGroups_.size(),
        reinterpret_cast<VkRayTracingShaderGroupCreateInfoNV*>(pGroups_.data()),
        maxRecursionDepth_,
        layout_,
        basePipelineHandle_,
        basePipelineIndex_
    } { }
    S_RayTracingPipelineCreateInfoNV& set_next(N_RayTracingPipelineCreateInfoNV& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_RayTracingPipelineCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_RayTracingPipelineCreateInfoNV*() { return this; }
    inL operator S_RayTracingPipelineCreateInfoNV const* () const { return const_cast<S_RayTracingPipelineCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkRayTracingPipelineCreateInfoNV> { using T = S_RayTracingPipelineCreateInfoNV; };
struct S_DrawIndirectCommand : public VkDrawIndirectCommand {
public:
    using Otype = VkDrawIndirectCommand;
public:
    S_DrawIndirectCommand(Otype& origin_obj_):Otype(origin_obj_){}
    S_DrawIndirectCommand(
        uint32_t vertexCount_= { },
        uint32_t instanceCount_= { },
        uint32_t firstVertex_= { },
        uint32_t firstInstance_= { }
    ) : Otype{
        vertexCount_,
        instanceCount_,
        firstVertex_,
        firstInstance_
    } { }
    inL S_DrawIndirectCommand& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DrawIndirectCommand*() { return this; }
    inL operator S_DrawIndirectCommand const* () const { return const_cast<S_DrawIndirectCommand const*>(this); }
};
template<> struct detail::names_map<VkDrawIndirectCommand> { using T = S_DrawIndirectCommand; };
struct S_PhysicalDeviceBlendOperationAdvancedPropertiesEXT : public VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT;
public:
    S_PhysicalDeviceBlendOperationAdvancedPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceBlendOperationAdvancedPropertiesEXT(
        uint32_t advancedBlendMaxColorAttachments_= { },
        VkBool32 advancedBlendIndependentBlend_= { },
        VkBool32 advancedBlendNonPremultipliedSrcColor_= { },
        VkBool32 advancedBlendNonPremultipliedDstColor_= { },
        VkBool32 advancedBlendCorrelatedOverlap_= { },
        VkBool32 advancedBlendAllOperations_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
        nullptr,
        advancedBlendMaxColorAttachments_,
        advancedBlendIndependentBlend_,
        advancedBlendNonPremultipliedSrcColor_,
        advancedBlendNonPremultipliedDstColor_,
        advancedBlendCorrelatedOverlap_,
        advancedBlendAllOperations_
    } { }
    inL S_PhysicalDeviceBlendOperationAdvancedPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceBlendOperationAdvancedPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceBlendOperationAdvancedPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceBlendOperationAdvancedPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT> { using T = S_PhysicalDeviceBlendOperationAdvancedPropertiesEXT; };
struct S_DeviceQueueInfo2 : public VkDeviceQueueInfo2 {
public:
    using Otype = VkDeviceQueueInfo2;
public:
    S_DeviceQueueInfo2(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceQueueInfo2(
        VkDeviceQueueCreateFlags flags_= { },
        uint32_t queueFamilyIndex_= { },
        uint32_t queueIndex_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2,
        nullptr,
        flags_,
        queueFamilyIndex_,
        queueIndex_
    } { }
    inL S_DeviceQueueInfo2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceQueueInfo2*() { return this; }
    inL operator S_DeviceQueueInfo2 const* () const { return const_cast<S_DeviceQueueInfo2 const*>(this); }
};
template<> struct detail::names_map<VkDeviceQueueInfo2> { using T = S_DeviceQueueInfo2; };
struct S_FilterCubicImageViewImageFormatPropertiesEXT : public VkFilterCubicImageViewImageFormatPropertiesEXT {
public:
    using Otype = VkFilterCubicImageViewImageFormatPropertiesEXT;
public:
    S_FilterCubicImageViewImageFormatPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_FilterCubicImageViewImageFormatPropertiesEXT(
        VkBool32 filterCubic_= { },
        VkBool32 filterCubicMinmax_ = { }
    ) : Otype{
        VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
        nullptr,
        filterCubic_,
        filterCubicMinmax_
    } { }
    inL S_FilterCubicImageViewImageFormatPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_FilterCubicImageViewImageFormatPropertiesEXT*() { return this; }
    inL operator S_FilterCubicImageViewImageFormatPropertiesEXT const* () const { return const_cast<S_FilterCubicImageViewImageFormatPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkFilterCubicImageViewImageFormatPropertiesEXT> { using T = S_FilterCubicImageViewImageFormatPropertiesEXT; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_SemaphoreGetWin32HandleInfoKHR : public VkSemaphoreGetWin32HandleInfoKHR {
public:
    using Otype = VkSemaphoreGetWin32HandleInfoKHR;
public:
    S_SemaphoreGetWin32HandleInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SemaphoreGetWin32HandleInfoKHR(
        VkSemaphore semaphore_= { },
        F_ExternalSemaphoreHandleType handleType_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR,
        nullptr,
        semaphore_,
        handleType_
    } { }
    inL S_SemaphoreGetWin32HandleInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SemaphoreGetWin32HandleInfoKHR*() { return this; }
    inL operator S_SemaphoreGetWin32HandleInfoKHR const* () const { return const_cast<S_SemaphoreGetWin32HandleInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkSemaphoreGetWin32HandleInfoKHR> { using T = S_SemaphoreGetWin32HandleInfoKHR; };

#endif
struct S_VertexInputBindingDivisorDescriptionEXT : public VkVertexInputBindingDivisorDescriptionEXT {
public:
    using Otype = VkVertexInputBindingDivisorDescriptionEXT;
public:
    S_VertexInputBindingDivisorDescriptionEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_VertexInputBindingDivisorDescriptionEXT(
        uint32_t binding_= { },
        uint32_t divisor_= { }
    ) : Otype{
        binding_,
        divisor_
    } { }
    inL S_VertexInputBindingDivisorDescriptionEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_VertexInputBindingDivisorDescriptionEXT*() { return this; }
    inL operator S_VertexInputBindingDivisorDescriptionEXT const* () const { return const_cast<S_VertexInputBindingDivisorDescriptionEXT const*>(this); }
};
template<> struct detail::names_map<VkVertexInputBindingDivisorDescriptionEXT> { using T = S_VertexInputBindingDivisorDescriptionEXT; };
struct S_PipelineVertexInputDivisorStateCreateInfoEXT : public VkPipelineVertexInputDivisorStateCreateInfoEXT {
public:
    using Otype = VkPipelineVertexInputDivisorStateCreateInfoEXT;
public:
    S_PipelineVertexInputDivisorStateCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineVertexInputDivisorStateCreateInfoEXT(
        Array_general<S_VertexInputBindingDivisorDescriptionEXT> pVertexBindingDivisors_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
        nullptr,
        pVertexBindingDivisors_.size(),
        reinterpret_cast<VkVertexInputBindingDivisorDescriptionEXT*>(pVertexBindingDivisors_.data())
    } { }
    inL S_PipelineVertexInputDivisorStateCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineVertexInputDivisorStateCreateInfoEXT*() { return this; }
    inL operator S_PipelineVertexInputDivisorStateCreateInfoEXT const* () const { return const_cast<S_PipelineVertexInputDivisorStateCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkPipelineVertexInputDivisorStateCreateInfoEXT> { using T = S_PipelineVertexInputDivisorStateCreateInfoEXT; };
struct S_PerformanceValueINTEL : public VkPerformanceValueINTEL {
public:
    using Otype = VkPerformanceValueINTEL;
public:
    S_PerformanceValueINTEL(Otype& origin_obj_):Otype(origin_obj_){}
    S_PerformanceValueINTEL(
        E_PerformanceValueTypeINTEL type_= { },
        VkPerformanceValueDataINTEL data_= { }
    ) : Otype{
        type_,
        data_
    } { }
    inL S_PerformanceValueINTEL& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PerformanceValueINTEL*() { return this; }
    inL operator S_PerformanceValueINTEL const* () const { return const_cast<S_PerformanceValueINTEL const*>(this); }
};
template<> struct detail::names_map<VkPerformanceValueINTEL> { using T = S_PerformanceValueINTEL; };
struct S_ComponentMapping : public VkComponentMapping {
public:
    using Otype = VkComponentMapping;
public:
    S_ComponentMapping(Otype& origin_obj_):Otype(origin_obj_){}
    S_ComponentMapping(
        E_ComponentSwizzle r_= { },
        E_ComponentSwizzle g_= { },
        E_ComponentSwizzle b_= { },
        E_ComponentSwizzle a_= { }
    ) : Otype{
        r_,
        g_,
        b_,
        a_
    } { }
    inL S_ComponentMapping& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ComponentMapping*() { return this; }
    inL operator S_ComponentMapping const* () const { return const_cast<S_ComponentMapping const*>(this); }
};
template<> struct detail::names_map<VkComponentMapping> { using T = S_ComponentMapping; };
struct S_DebugUtilsObjectNameInfoEXT : public VkDebugUtilsObjectNameInfoEXT {
public:
    using Otype = VkDebugUtilsObjectNameInfoEXT;
public:
    S_DebugUtilsObjectNameInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DebugUtilsObjectNameInfoEXT(
        E_ObjectType objectType_= { },
        uint64_t objectHandle_= { },
        Aptr<char> pObjectName_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
        nullptr,
        objectType_,
        objectHandle_,
        pObjectName_
    } { }
    inL S_DebugUtilsObjectNameInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DebugUtilsObjectNameInfoEXT*() { return this; }
    inL operator S_DebugUtilsObjectNameInfoEXT const* () const { return const_cast<S_DebugUtilsObjectNameInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDebugUtilsObjectNameInfoEXT> { using T = S_DebugUtilsObjectNameInfoEXT; };
struct S_PhysicalDeviceSampleLocationsPropertiesEXT : public VkPhysicalDeviceSampleLocationsPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceSampleLocationsPropertiesEXT;
public:
    S_PhysicalDeviceSampleLocationsPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceSampleLocationsPropertiesEXT(
        VkSampleCountFlags sampleLocationSampleCounts_= { },
        S_Extent2D maxSampleLocationGridSize_= { },
        std::array<float,2> sampleLocationCoordinateRange_= { },
        uint32_t sampleLocationSubPixelBits_= { },
        VkBool32 variableSampleLocations_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
        nullptr,
        sampleLocationSampleCounts_,
        maxSampleLocationGridSize_,
        { },
        sampleLocationSubPixelBits_,
        variableSampleLocations_
    } { 
        ::memcpy(&sampleLocationCoordinateRange[0], sampleLocationCoordinateRange_.data(), sampleLocationCoordinateRange_.size() );
    }
    inL S_PhysicalDeviceSampleLocationsPropertiesEXT& 
        set_sampleLocationCoordinateRange(std::array<float,2> sampleLocationCoordinateRange_)
        {  return *this; }
    inL S_PhysicalDeviceSampleLocationsPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceSampleLocationsPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceSampleLocationsPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceSampleLocationsPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceSampleLocationsPropertiesEXT> { using T = S_PhysicalDeviceSampleLocationsPropertiesEXT; };
struct S_MemoryType : public VkMemoryType {
public:
    using Otype = VkMemoryType;
public:
    S_MemoryType(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryType(
        VkMemoryPropertyFlags propertyFlags_= { },
        uint32_t heapIndex_= { }
    ) : Otype{
        propertyFlags_,
        heapIndex_
    } { }
    inL S_MemoryType& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryType*() { return this; }
    inL operator S_MemoryType const* () const { return const_cast<S_MemoryType const*>(this); }
};
template<> struct detail::names_map<VkMemoryType> { using T = S_MemoryType; };
struct S_PhysicalDeviceMemoryProperties : public VkPhysicalDeviceMemoryProperties {
public:
    using Otype = VkPhysicalDeviceMemoryProperties;
public:
    S_PhysicalDeviceMemoryProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceMemoryProperties(
        uint32_t memoryTypeCount_= { },
        std::array<S_MemoryType,VK_MAX_MEMORY_TYPES> memoryTypes_= { },
        uint32_t memoryHeapCount_= { },
        std::array<S_MemoryHeap,VK_MAX_MEMORY_HEAPS> memoryHeaps_= { }
    ) : Otype{
        memoryTypeCount_,
        { },
        memoryHeapCount_,
        { }
    } { 
        ::memcpy(&memoryTypes[0], memoryTypes_.data(), memoryTypes_.size() );
        ::memcpy(&memoryHeaps[0], memoryHeaps_.data(), memoryHeaps_.size() );
    }
    inL S_PhysicalDeviceMemoryProperties& 
        set_memoryTypes(std::array<VkMemoryType,VK_MAX_MEMORY_TYPES> memoryTypes_)
        {  return *this; }
    inL S_PhysicalDeviceMemoryProperties& 
        set_memoryHeaps(std::array<VkMemoryHeap,VK_MAX_MEMORY_HEAPS> memoryHeaps_)
        {  return *this; }
    inL S_PhysicalDeviceMemoryProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceMemoryProperties*() { return this; }
    inL operator S_PhysicalDeviceMemoryProperties const* () const { return const_cast<S_PhysicalDeviceMemoryProperties const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceMemoryProperties> { using T = S_PhysicalDeviceMemoryProperties; };
struct S_PhysicalDeviceMemoryBudgetPropertiesEXT : public VkPhysicalDeviceMemoryBudgetPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceMemoryBudgetPropertiesEXT;
public:
    S_PhysicalDeviceMemoryBudgetPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceMemoryBudgetPropertiesEXT(
        std::array<VkDeviceSize,VK_MAX_MEMORY_HEAPS> heapBudget_= { },
        std::array<VkDeviceSize,VK_MAX_MEMORY_HEAPS> heapUsage_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
        nullptr,
        { },
        { }
    } { 
        ::memcpy(&heapBudget[0], heapBudget_.data(), heapBudget_.size() );
        ::memcpy(&heapUsage[0], heapUsage_.data(), heapUsage_.size() );
    }
    inL S_PhysicalDeviceMemoryBudgetPropertiesEXT& 
        set_heapBudget(std::array<VkDeviceSize,VK_MAX_MEMORY_HEAPS> heapBudget_)
        {  return *this; }
    inL S_PhysicalDeviceMemoryBudgetPropertiesEXT& 
        set_heapUsage(std::array<VkDeviceSize,VK_MAX_MEMORY_HEAPS> heapUsage_)
        {  return *this; }
    inL S_PhysicalDeviceMemoryBudgetPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceMemoryBudgetPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceMemoryBudgetPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceMemoryBudgetPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceMemoryBudgetPropertiesEXT> { using T = S_PhysicalDeviceMemoryBudgetPropertiesEXT; };
struct N_PhysicalDeviceMemoryProperties2{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_PhysicalDeviceMemoryProperties2& n_VkPhysicalDeviceMemoryBudgetPropertiesEXT(Aref<S_PhysicalDeviceMemoryBudgetPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_PhysicalDeviceMemoryProperties2 : public VkPhysicalDeviceMemoryProperties2 {
public:
    using Otype = VkPhysicalDeviceMemoryProperties2;
public:
    S_PhysicalDeviceMemoryProperties2(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceMemoryProperties2(
        S_PhysicalDeviceMemoryProperties memoryProperties_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
        nullptr,
        memoryProperties_
    } { }
    S_PhysicalDeviceMemoryProperties2& set_next(N_PhysicalDeviceMemoryProperties2& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_PhysicalDeviceMemoryProperties2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceMemoryProperties2*() { return this; }
    inL operator S_PhysicalDeviceMemoryProperties2 const* () const { return const_cast<S_PhysicalDeviceMemoryProperties2 const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceMemoryProperties2> { using T = S_PhysicalDeviceMemoryProperties2; };
struct S_PhysicalDeviceRepresentativeFragmentTestFeaturesNV : public VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
public:
    using Otype = VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV;
public:
    S_PhysicalDeviceRepresentativeFragmentTestFeaturesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceRepresentativeFragmentTestFeaturesNV(
        VkBool32 representativeFragmentTest_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
        nullptr,
        representativeFragmentTest_
    } { }
    inL S_PhysicalDeviceRepresentativeFragmentTestFeaturesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceRepresentativeFragmentTestFeaturesNV*() { return this; }
    inL operator S_PhysicalDeviceRepresentativeFragmentTestFeaturesNV const* () const { return const_cast<S_PhysicalDeviceRepresentativeFragmentTestFeaturesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV> { using T = S_PhysicalDeviceRepresentativeFragmentTestFeaturesNV; };
struct S_ImageFormatProperties : public VkImageFormatProperties {
public:
    using Otype = VkImageFormatProperties;
public:
    S_ImageFormatProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageFormatProperties(
        S_Extent3D maxExtent_= { },
        uint32_t maxMipLevels_= { },
        uint32_t maxArrayLayers_= { },
        VkSampleCountFlags sampleCounts_= { },
        VkDeviceSize maxResourceSize_= { }
    ) : Otype{
        maxExtent_,
        maxMipLevels_,
        maxArrayLayers_,
        sampleCounts_,
        maxResourceSize_
    } { }
    inL S_ImageFormatProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageFormatProperties*() { return this; }
    inL operator S_ImageFormatProperties const* () const { return const_cast<S_ImageFormatProperties const*>(this); }
};
template<> struct detail::names_map<VkImageFormatProperties> { using T = S_ImageFormatProperties; };
struct S_ImageSubresourceLayers : public VkImageSubresourceLayers {
public:
    using Otype = VkImageSubresourceLayers;
public:
    S_ImageSubresourceLayers(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageSubresourceLayers(
        VkImageAspectFlags aspectMask_= { },
        uint32_t mipLevel_= { },
        uint32_t baseArrayLayer_= { },
        uint32_t layerCount_= { }
    ) : Otype{
        aspectMask_,
        mipLevel_,
        baseArrayLayer_,
        layerCount_
    } { }
    inL S_ImageSubresourceLayers& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageSubresourceLayers*() { return this; }
    inL operator S_ImageSubresourceLayers const* () const { return const_cast<S_ImageSubresourceLayers const*>(this); }
};
template<> struct detail::names_map<VkImageSubresourceLayers> { using T = S_ImageSubresourceLayers; };
struct S_BufferImageCopy : public VkBufferImageCopy {
public:
    using Otype = VkBufferImageCopy;
public:
    S_BufferImageCopy(Otype& origin_obj_):Otype(origin_obj_){}
    S_BufferImageCopy(
        VkDeviceSize bufferOffset_= { },
        uint32_t bufferRowLength_= { },
        uint32_t bufferImageHeight_= { },
        S_ImageSubresourceLayers imageSubresource_= { },
        S_Offset3D imageOffset_= { },
        S_Extent3D imageExtent_= { }
    ) : Otype{
        bufferOffset_,
        bufferRowLength_,
        bufferImageHeight_,
        imageSubresource_,
        imageOffset_,
        imageExtent_
    } { }
    inL S_BufferImageCopy& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BufferImageCopy*() { return this; }
    inL operator S_BufferImageCopy const* () const { return const_cast<S_BufferImageCopy const*>(this); }
};
template<> struct detail::names_map<VkBufferImageCopy> { using T = S_BufferImageCopy; };
struct S_LayerProperties : public VkLayerProperties {
public:
    using Otype = VkLayerProperties;
public:
    S_LayerProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_LayerProperties(
        std::array<char,VK_MAX_EXTENSION_NAME_SIZE> layerName_= { },
        uint32_t specVersion_= { },
        uint32_t implementationVersion_= { },
        std::array<char,VK_MAX_DESCRIPTION_SIZE> description_= { }
    ) : Otype{
        { },
        specVersion_,
        implementationVersion_,
        { }
    } { 
        ::memcpy(&layerName[0], layerName_.data(), layerName_.size() );
        ::memcpy(&description[0], description_.data(), description_.size() );
    }
    inL S_LayerProperties& 
        set_layerName(std::array<char,VK_MAX_EXTENSION_NAME_SIZE> layerName_)
        {  return *this; }
    inL S_LayerProperties& 
        set_description(std::array<char,VK_MAX_DESCRIPTION_SIZE> description_)
        {  return *this; }
    inL S_LayerProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_LayerProperties*() { return this; }
    inL operator S_LayerProperties const* () const { return const_cast<S_LayerProperties const*>(this); }
};
template<> struct detail::names_map<VkLayerProperties> { using T = S_LayerProperties; };
struct S_PhysicalDeviceShaderAtomicInt64FeaturesKHR : public VkPhysicalDeviceShaderAtomicInt64FeaturesKHR {
public:
    using Otype = VkPhysicalDeviceShaderAtomicInt64FeaturesKHR;
public:
    S_PhysicalDeviceShaderAtomicInt64FeaturesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceShaderAtomicInt64FeaturesKHR(
        VkBool32 shaderBufferInt64Atomics_= { },
        VkBool32 shaderSharedInt64Atomics_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR,
        nullptr,
        shaderBufferInt64Atomics_,
        shaderSharedInt64Atomics_
    } { }
    inL S_PhysicalDeviceShaderAtomicInt64FeaturesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceShaderAtomicInt64FeaturesKHR*() { return this; }
    inL operator S_PhysicalDeviceShaderAtomicInt64FeaturesKHR const* () const { return const_cast<S_PhysicalDeviceShaderAtomicInt64FeaturesKHR const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceShaderAtomicInt64FeaturesKHR> { using T = S_PhysicalDeviceShaderAtomicInt64FeaturesKHR; };
struct S_PhysicalDeviceSubgroupSizeControlPropertiesEXT : public VkPhysicalDeviceSubgroupSizeControlPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceSubgroupSizeControlPropertiesEXT;
public:
    S_PhysicalDeviceSubgroupSizeControlPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceSubgroupSizeControlPropertiesEXT(
        uint32_t minSubgroupSize_= { },
        uint32_t maxSubgroupSize_= { },
        uint32_t maxComputeWorkgroupSubgroups_= { },
        VkShaderStageFlags requiredSubgroupSizeStages_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT,
        nullptr,
        minSubgroupSize_,
        maxSubgroupSize_,
        maxComputeWorkgroupSubgroups_,
        requiredSubgroupSizeStages_
    } { }
    inL S_PhysicalDeviceSubgroupSizeControlPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceSubgroupSizeControlPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceSubgroupSizeControlPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceSubgroupSizeControlPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT> { using T = S_PhysicalDeviceSubgroupSizeControlPropertiesEXT; };
struct S_DisplayNativeHdrSurfaceCapabilitiesAMD : public VkDisplayNativeHdrSurfaceCapabilitiesAMD {
public:
    using Otype = VkDisplayNativeHdrSurfaceCapabilitiesAMD;
public:
    S_DisplayNativeHdrSurfaceCapabilitiesAMD(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayNativeHdrSurfaceCapabilitiesAMD(
        VkBool32 localDimmingSupport_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
        nullptr,
        localDimmingSupport_
    } { }
    inL S_DisplayNativeHdrSurfaceCapabilitiesAMD& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayNativeHdrSurfaceCapabilitiesAMD*() { return this; }
    inL operator S_DisplayNativeHdrSurfaceCapabilitiesAMD const* () const { return const_cast<S_DisplayNativeHdrSurfaceCapabilitiesAMD const*>(this); }
};
template<> struct detail::names_map<VkDisplayNativeHdrSurfaceCapabilitiesAMD> { using T = S_DisplayNativeHdrSurfaceCapabilitiesAMD; };
struct S_ShaderResourceUsageAMD : public VkShaderResourceUsageAMD {
public:
    using Otype = VkShaderResourceUsageAMD;
public:
    S_ShaderResourceUsageAMD(Otype& origin_obj_):Otype(origin_obj_){}
    S_ShaderResourceUsageAMD(
        uint32_t numUsedVgprs_= { },
        uint32_t numUsedSgprs_= { },
        uint32_t ldsSizePerLocalWorkGroup_= { },
        size_t ldsUsageSizeInBytes_= { },
        size_t scratchMemUsageInBytes_= { }
    ) : Otype{
        numUsedVgprs_,
        numUsedSgprs_,
        ldsSizePerLocalWorkGroup_,
        ldsUsageSizeInBytes_,
        scratchMemUsageInBytes_
    } { }
    inL S_ShaderResourceUsageAMD& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ShaderResourceUsageAMD*() { return this; }
    inL operator S_ShaderResourceUsageAMD const* () const { return const_cast<S_ShaderResourceUsageAMD const*>(this); }
};
template<> struct detail::names_map<VkShaderResourceUsageAMD> { using T = S_ShaderResourceUsageAMD; };
struct S_AttachmentDescription : public VkAttachmentDescription {
public:
    using Otype = VkAttachmentDescription;
public:
    S_AttachmentDescription(Otype& origin_obj_):Otype(origin_obj_){}
    S_AttachmentDescription(
        VkAttachmentDescriptionFlags flags_= { },
        E_Format format_= { },
        F_SampleCount samples_= { },
        E_AttachmentLoadOp loadOp_= { },
        E_AttachmentStoreOp storeOp_= { },
        E_AttachmentLoadOp stencilLoadOp_= { },
        E_AttachmentStoreOp stencilStoreOp_= { },
        E_ImageLayout initialLayout_= { },
        E_ImageLayout finalLayout_= { }
    ) : Otype{
        flags_,
        format_,
        samples_,
        loadOp_,
        storeOp_,
        stencilLoadOp_,
        stencilStoreOp_,
        initialLayout_,
        finalLayout_
    } { }
    inL S_AttachmentDescription& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AttachmentDescription*() { return this; }
    inL operator S_AttachmentDescription const* () const { return const_cast<S_AttachmentDescription const*>(this); }
};
template<> struct detail::names_map<VkAttachmentDescription> { using T = S_AttachmentDescription; };
struct S_DescriptorPoolSize : public VkDescriptorPoolSize {
public:
    using Otype = VkDescriptorPoolSize;
public:
    S_DescriptorPoolSize(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorPoolSize(
        E_DescriptorType type_= { },
        uint32_t descriptorCount_= { }
    ) : Otype{
        type_,
        descriptorCount_
    } { }
    inL S_DescriptorPoolSize& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorPoolSize*() { return this; }
    inL operator S_DescriptorPoolSize const* () const { return const_cast<S_DescriptorPoolSize const*>(this); }
};
template<> struct detail::names_map<VkDescriptorPoolSize> { using T = S_DescriptorPoolSize; };
struct S_DescriptorPoolInlineUniformBlockCreateInfoEXT : public VkDescriptorPoolInlineUniformBlockCreateInfoEXT {
public:
    using Otype = VkDescriptorPoolInlineUniformBlockCreateInfoEXT;
public:
    S_DescriptorPoolInlineUniformBlockCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorPoolInlineUniformBlockCreateInfoEXT(
        uint32_t maxInlineUniformBlockBindings_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT,
        nullptr,
        maxInlineUniformBlockBindings_
    } { }
    inL S_DescriptorPoolInlineUniformBlockCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorPoolInlineUniformBlockCreateInfoEXT*() { return this; }
    inL operator S_DescriptorPoolInlineUniformBlockCreateInfoEXT const* () const { return const_cast<S_DescriptorPoolInlineUniformBlockCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDescriptorPoolInlineUniformBlockCreateInfoEXT> { using T = S_DescriptorPoolInlineUniformBlockCreateInfoEXT; };
struct N_DescriptorPoolCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_DescriptorPoolCreateInfo& n_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(Aref<S_DescriptorPoolInlineUniformBlockCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_DescriptorPoolCreateInfo : public VkDescriptorPoolCreateInfo {
public:
    using Otype = VkDescriptorPoolCreateInfo;
public:
    S_DescriptorPoolCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorPoolCreateInfo(
        VkDescriptorPoolCreateFlags flags_= { },
        uint32_t maxSets_= { },
        Array_general<S_DescriptorPoolSize> pPoolSizes_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
        nullptr,
        flags_,
        maxSets_,
        pPoolSizes_.size(),
        reinterpret_cast<VkDescriptorPoolSize*>(pPoolSizes_.data())
    } { }
    S_DescriptorPoolCreateInfo& set_next(N_DescriptorPoolCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_DescriptorPoolCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorPoolCreateInfo*() { return this; }
    inL operator S_DescriptorPoolCreateInfo const* () const { return const_cast<S_DescriptorPoolCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkDescriptorPoolCreateInfo> { using T = S_DescriptorPoolCreateInfo; };
struct S_ExternalMemoryBufferCreateInfo : public VkExternalMemoryBufferCreateInfo {
public:
    using Otype = VkExternalMemoryBufferCreateInfo;
public:
    S_ExternalMemoryBufferCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExternalMemoryBufferCreateInfo(
        VkExternalMemoryHandleTypeFlags handleTypes_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
        nullptr,
        handleTypes_
    } { }
    inL S_ExternalMemoryBufferCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExternalMemoryBufferCreateInfo*() { return this; }
    inL operator S_ExternalMemoryBufferCreateInfo const* () const { return const_cast<S_ExternalMemoryBufferCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkExternalMemoryBufferCreateInfo> { using T = S_ExternalMemoryBufferCreateInfo; };
struct S_SubpassEndInfoKHR : public VkSubpassEndInfoKHR {
public:
    using Otype = VkSubpassEndInfoKHR;
public:
    S_SubpassEndInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SubpassEndInfoKHR() : Otype{
        VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR,
        nullptr
    } { }
    inL S_SubpassEndInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SubpassEndInfoKHR*() { return this; }
    inL operator S_SubpassEndInfoKHR const* () const { return const_cast<S_SubpassEndInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkSubpassEndInfoKHR> { using T = S_SubpassEndInfoKHR; };
struct S_PipelineExecutableStatisticKHR : public VkPipelineExecutableStatisticKHR {
public:
    using Otype = VkPipelineExecutableStatisticKHR;
public:
    S_PipelineExecutableStatisticKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineExecutableStatisticKHR(
        std::array<char,VK_MAX_DESCRIPTION_SIZE> name_= { },
        std::array<char,VK_MAX_DESCRIPTION_SIZE> description_= { },
        E_PipelineExecutableStatisticFormatKHR format_= { },
        VkPipelineExecutableStatisticValueKHR value_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR,
        nullptr,
        { },
        { },
        format_,
        value_
    } { 
        ::memcpy(&name[0], name_.data(), name_.size() );
        ::memcpy(&description[0], description_.data(), description_.size() );
    }
    inL S_PipelineExecutableStatisticKHR& 
        set_name(std::array<char,VK_MAX_DESCRIPTION_SIZE> name_)
        {  return *this; }
    inL S_PipelineExecutableStatisticKHR& 
        set_description(std::array<char,VK_MAX_DESCRIPTION_SIZE> description_)
        {  return *this; }
    inL S_PipelineExecutableStatisticKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineExecutableStatisticKHR*() { return this; }
    inL operator S_PipelineExecutableStatisticKHR const* () const { return const_cast<S_PipelineExecutableStatisticKHR const*>(this); }
};
template<> struct detail::names_map<VkPipelineExecutableStatisticKHR> { using T = S_PipelineExecutableStatisticKHR; };
struct S_EventCreateInfo : public VkEventCreateInfo {
public:
    using Otype = VkEventCreateInfo;
public:
    S_EventCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_EventCreateInfo(
        VkEventCreateFlags flags_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EVENT_CREATE_INFO,
        nullptr,
        flags_
    } { }
    inL S_EventCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_EventCreateInfo*() { return this; }
    inL operator S_EventCreateInfo const* () const { return const_cast<S_EventCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkEventCreateInfo> { using T = S_EventCreateInfo; };
struct S_PhysicalDeviceSubgroupSizeControlFeaturesEXT : public VkPhysicalDeviceSubgroupSizeControlFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceSubgroupSizeControlFeaturesEXT;
public:
    S_PhysicalDeviceSubgroupSizeControlFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceSubgroupSizeControlFeaturesEXT(
        VkBool32 subgroupSizeControl_= { },
        VkBool32 computeFullSubgroups_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT,
        nullptr,
        subgroupSizeControl_,
        computeFullSubgroups_
    } { }
    inL S_PhysicalDeviceSubgroupSizeControlFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceSubgroupSizeControlFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceSubgroupSizeControlFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceSubgroupSizeControlFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT> { using T = S_PhysicalDeviceSubgroupSizeControlFeaturesEXT; };
struct S_DebugMarkerMarkerInfoEXT : public VkDebugMarkerMarkerInfoEXT {
public:
    using Otype = VkDebugMarkerMarkerInfoEXT;
public:
    S_DebugMarkerMarkerInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DebugMarkerMarkerInfoEXT(
        Aptr<char> pMarkerName_= { },
        std::array<float,4> color_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
        nullptr,
        pMarkerName_,
        { }
    } { 
        ::memcpy(&color[0], color_.data(), color_.size() );
    }
    inL S_DebugMarkerMarkerInfoEXT& 
        set_color(std::array<float,4> color_)
        {  return *this; }
    inL S_DebugMarkerMarkerInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DebugMarkerMarkerInfoEXT*() { return this; }
    inL operator S_DebugMarkerMarkerInfoEXT const* () const { return const_cast<S_DebugMarkerMarkerInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDebugMarkerMarkerInfoEXT> { using T = S_DebugMarkerMarkerInfoEXT; };
struct S_BufferMemoryBarrier : public VkBufferMemoryBarrier {
public:
    using Otype = VkBufferMemoryBarrier;
public:
    S_BufferMemoryBarrier(Otype& origin_obj_):Otype(origin_obj_){}
    S_BufferMemoryBarrier(
        VkAccessFlags srcAccessMask_= { },
        VkAccessFlags dstAccessMask_= { },
        uint32_t srcQueueFamilyIndex_= { },
        uint32_t dstQueueFamilyIndex_= { },
        VkBuffer buffer_= { },
        VkDeviceSize offset_= { },
        VkDeviceSize size_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
        nullptr,
        srcAccessMask_,
        dstAccessMask_,
        srcQueueFamilyIndex_,
        dstQueueFamilyIndex_,
        buffer_,
        offset_,
        size_
    } { }
    inL S_BufferMemoryBarrier& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BufferMemoryBarrier*() { return this; }
    inL operator S_BufferMemoryBarrier const* () const { return const_cast<S_BufferMemoryBarrier const*>(this); }
};
template<> struct detail::names_map<VkBufferMemoryBarrier> { using T = S_BufferMemoryBarrier; };
struct S_MemoryBarrier : public VkMemoryBarrier {
public:
    using Otype = VkMemoryBarrier;
public:
    S_MemoryBarrier(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryBarrier(
        VkAccessFlags srcAccessMask_= { },
        VkAccessFlags dstAccessMask_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MEMORY_BARRIER,
        nullptr,
        srcAccessMask_,
        dstAccessMask_
    } { }
    inL S_MemoryBarrier& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryBarrier*() { return this; }
    inL operator S_MemoryBarrier const* () const { return const_cast<S_MemoryBarrier const*>(this); }
};
template<> struct detail::names_map<VkMemoryBarrier> { using T = S_MemoryBarrier; };
struct S_DisplayPlaneInfo2KHR : public VkDisplayPlaneInfo2KHR {
public:
    using Otype = VkDisplayPlaneInfo2KHR;
public:
    S_DisplayPlaneInfo2KHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayPlaneInfo2KHR(
        VkDisplayModeKHR mode_= { },
        uint32_t planeIndex_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR,
        nullptr,
        mode_,
        planeIndex_
    } { }
    inL S_DisplayPlaneInfo2KHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayPlaneInfo2KHR*() { return this; }
    inL operator S_DisplayPlaneInfo2KHR const* () const { return const_cast<S_DisplayPlaneInfo2KHR const*>(this); }
};
template<> struct detail::names_map<VkDisplayPlaneInfo2KHR> { using T = S_DisplayPlaneInfo2KHR; };
struct S_ImportMemoryFdInfoKHR : public VkImportMemoryFdInfoKHR {
public:
    using Otype = VkImportMemoryFdInfoKHR;
public:
    S_ImportMemoryFdInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImportMemoryFdInfoKHR(
        F_ExternalMemoryHandleType handleType_= { },
        int fd_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
        nullptr,
        handleType_,
        fd_
    } { }
    inL S_ImportMemoryFdInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImportMemoryFdInfoKHR*() { return this; }
    inL operator S_ImportMemoryFdInfoKHR const* () const { return const_cast<S_ImportMemoryFdInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkImportMemoryFdInfoKHR> { using T = S_ImportMemoryFdInfoKHR; };
struct S_DeviceGroupPresentCapabilitiesKHR : public VkDeviceGroupPresentCapabilitiesKHR {
public:
    using Otype = VkDeviceGroupPresentCapabilitiesKHR;
public:
    S_DeviceGroupPresentCapabilitiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceGroupPresentCapabilitiesKHR(
        std::array<uint32_t,VK_MAX_DEVICE_GROUP_SIZE> presentMask_= { },
        VkDeviceGroupPresentModeFlagsKHR modes_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
        nullptr,
        { },
        modes_
    } { 
        ::memcpy(&presentMask[0], presentMask_.data(), presentMask_.size() );
    }
    inL S_DeviceGroupPresentCapabilitiesKHR& 
        set_presentMask(std::array<uint32_t,VK_MAX_DEVICE_GROUP_SIZE> presentMask_)
        {  return *this; }
    inL S_DeviceGroupPresentCapabilitiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceGroupPresentCapabilitiesKHR*() { return this; }
    inL operator S_DeviceGroupPresentCapabilitiesKHR const* () const { return const_cast<S_DeviceGroupPresentCapabilitiesKHR const*>(this); }
};
template<> struct detail::names_map<VkDeviceGroupPresentCapabilitiesKHR> { using T = S_DeviceGroupPresentCapabilitiesKHR; };
struct S_PhysicalDeviceImageViewImageFormatInfoEXT : public VkPhysicalDeviceImageViewImageFormatInfoEXT {
public:
    using Otype = VkPhysicalDeviceImageViewImageFormatInfoEXT;
public:
    S_PhysicalDeviceImageViewImageFormatInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceImageViewImageFormatInfoEXT(
        E_ImageViewType imageViewType_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
        nullptr,
        imageViewType_
    } { }
    inL S_PhysicalDeviceImageViewImageFormatInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceImageViewImageFormatInfoEXT*() { return this; }
    inL operator S_PhysicalDeviceImageViewImageFormatInfoEXT const* () const { return const_cast<S_PhysicalDeviceImageViewImageFormatInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceImageViewImageFormatInfoEXT> { using T = S_PhysicalDeviceImageViewImageFormatInfoEXT; };
struct S_DescriptorUpdateTemplateEntry : public VkDescriptorUpdateTemplateEntry {
public:
    using Otype = VkDescriptorUpdateTemplateEntry;
public:
    S_DescriptorUpdateTemplateEntry(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorUpdateTemplateEntry(
        uint32_t dstBinding_= { },
        uint32_t dstArrayElement_= { },
        uint32_t descriptorCount_= { },
        E_DescriptorType descriptorType_= { },
        size_t offset_= { },
        size_t stride_= { }
    ) : Otype{
        dstBinding_,
        dstArrayElement_,
        descriptorCount_,
        descriptorType_,
        offset_,
        stride_
    } { }
    inL S_DescriptorUpdateTemplateEntry& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorUpdateTemplateEntry*() { return this; }
    inL operator S_DescriptorUpdateTemplateEntry const* () const { return const_cast<S_DescriptorUpdateTemplateEntry const*>(this); }
};
template<> struct detail::names_map<VkDescriptorUpdateTemplateEntry> { using T = S_DescriptorUpdateTemplateEntry; };
struct S_PhysicalDeviceDiscardRectanglePropertiesEXT : public VkPhysicalDeviceDiscardRectanglePropertiesEXT {
public:
    using Otype = VkPhysicalDeviceDiscardRectanglePropertiesEXT;
public:
    S_PhysicalDeviceDiscardRectanglePropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceDiscardRectanglePropertiesEXT(
        uint32_t maxDiscardRectangles_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
        nullptr,
        maxDiscardRectangles_
    } { }
    inL S_PhysicalDeviceDiscardRectanglePropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceDiscardRectanglePropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceDiscardRectanglePropertiesEXT const* () const { return const_cast<S_PhysicalDeviceDiscardRectanglePropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceDiscardRectanglePropertiesEXT> { using T = S_PhysicalDeviceDiscardRectanglePropertiesEXT; };
struct S_ExternalSemaphoreProperties : public VkExternalSemaphoreProperties {
public:
    using Otype = VkExternalSemaphoreProperties;
public:
    S_ExternalSemaphoreProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExternalSemaphoreProperties(
        VkExternalSemaphoreHandleTypeFlags exportFromImportedHandleTypes_= { },
        VkExternalSemaphoreHandleTypeFlags compatibleHandleTypes_= { },
        VkExternalSemaphoreFeatureFlags externalSemaphoreFeatures_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
        nullptr,
        exportFromImportedHandleTypes_,
        compatibleHandleTypes_,
        externalSemaphoreFeatures_
    } { }
    inL S_ExternalSemaphoreProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExternalSemaphoreProperties*() { return this; }
    inL operator S_ExternalSemaphoreProperties const* () const { return const_cast<S_ExternalSemaphoreProperties const*>(this); }
};
template<> struct detail::names_map<VkExternalSemaphoreProperties> { using T = S_ExternalSemaphoreProperties; };
struct S_FramebufferMixedSamplesCombinationNV : public VkFramebufferMixedSamplesCombinationNV {
public:
    using Otype = VkFramebufferMixedSamplesCombinationNV;
public:
    S_FramebufferMixedSamplesCombinationNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_FramebufferMixedSamplesCombinationNV(
        E_CoverageReductionModeNV coverageReductionMode_= { },
        F_SampleCount rasterizationSamples_= { },
        VkSampleCountFlags depthStencilSamples_= { },
        VkSampleCountFlags colorSamples_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV,
        nullptr,
        coverageReductionMode_,
        rasterizationSamples_,
        depthStencilSamples_,
        colorSamples_
    } { }
    inL S_FramebufferMixedSamplesCombinationNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_FramebufferMixedSamplesCombinationNV*() { return this; }
    inL operator S_FramebufferMixedSamplesCombinationNV const* () const { return const_cast<S_FramebufferMixedSamplesCombinationNV const*>(this); }
};
template<> struct detail::names_map<VkFramebufferMixedSamplesCombinationNV> { using T = S_FramebufferMixedSamplesCombinationNV; };
struct S_SurfaceFormatKHR : public VkSurfaceFormatKHR {
public:
    using Otype = VkSurfaceFormatKHR;
public:
    S_SurfaceFormatKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SurfaceFormatKHR(
        E_Format format_= { },
        E_ColorSpaceKHR colorSpace_= { }
    ) : Otype{
        format_,
        colorSpace_
    } { }
    inL S_SurfaceFormatKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SurfaceFormatKHR*() { return this; }
    inL operator S_SurfaceFormatKHR const* () const { return const_cast<S_SurfaceFormatKHR const*>(this); }
};
template<> struct detail::names_map<VkSurfaceFormatKHR> { using T = S_SurfaceFormatKHR; };
struct S_SurfaceFormat2KHR : public VkSurfaceFormat2KHR {
public:
    using Otype = VkSurfaceFormat2KHR;
public:
    S_SurfaceFormat2KHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SurfaceFormat2KHR(
        S_SurfaceFormatKHR surfaceFormat_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR,
        nullptr,
        surfaceFormat_
    } { }
    inL S_SurfaceFormat2KHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SurfaceFormat2KHR*() { return this; }
    inL operator S_SurfaceFormat2KHR const* () const { return const_cast<S_SurfaceFormat2KHR const*>(this); }
};
template<> struct detail::names_map<VkSurfaceFormat2KHR> { using T = S_SurfaceFormat2KHR; };
struct S_SurfaceProtectedCapabilitiesKHR : public VkSurfaceProtectedCapabilitiesKHR {
public:
    using Otype = VkSurfaceProtectedCapabilitiesKHR;
public:
    S_SurfaceProtectedCapabilitiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SurfaceProtectedCapabilitiesKHR(
        VkBool32 supportsProtected_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR,
        nullptr,
        supportsProtected_
    } { }
    inL S_SurfaceProtectedCapabilitiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SurfaceProtectedCapabilitiesKHR*() { return this; }
    inL operator S_SurfaceProtectedCapabilitiesKHR const* () const { return const_cast<S_SurfaceProtectedCapabilitiesKHR const*>(this); }
};
template<> struct detail::names_map<VkSurfaceProtectedCapabilitiesKHR> { using T = S_SurfaceProtectedCapabilitiesKHR; };
struct S_PhysicalDeviceFeatures : public VkPhysicalDeviceFeatures {
public:
    using Otype = VkPhysicalDeviceFeatures;
public:
    S_PhysicalDeviceFeatures(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceFeatures(
        VkBool32 robustBufferAccess_= { },
        VkBool32 fullDrawIndexUint32_= { },
        VkBool32 imageCubeArray_= { },
        VkBool32 independentBlend_= { },
        VkBool32 geometryShader_= { },
        VkBool32 tessellationShader_= { },
        VkBool32 sampleRateShading_= { },
        VkBool32 dualSrcBlend_= { },
        VkBool32 logicOp_= { },
        VkBool32 multiDrawIndirect_= { },
        VkBool32 drawIndirectFirstInstance_= { },
        VkBool32 depthClamp_= { },
        VkBool32 depthBiasClamp_= { },
        VkBool32 fillModeNonSolid_= { },
        VkBool32 depthBounds_= { },
        VkBool32 wideLines_= { },
        VkBool32 largePoints_= { },
        VkBool32 alphaToOne_= { },
        VkBool32 multiViewport_= { },
        VkBool32 samplerAnisotropy_= { },
        VkBool32 textureCompressionETC2_= { },
        VkBool32 textureCompressionASTC_LDR_= { },
        VkBool32 textureCompressionBC_= { },
        VkBool32 occlusionQueryPrecise_= { },
        VkBool32 pipelineStatisticsQuery_= { },
        VkBool32 vertexPipelineStoresAndAtomics_= { },
        VkBool32 fragmentStoresAndAtomics_= { },
        VkBool32 shaderTessellationAndGeometryPointSize_= { },
        VkBool32 shaderImageGatherExtended_= { },
        VkBool32 shaderStorageImageExtendedFormats_= { },
        VkBool32 shaderStorageImageMultisample_= { },
        VkBool32 shaderStorageImageReadWithoutFormat_= { },
        VkBool32 shaderStorageImageWriteWithoutFormat_= { },
        VkBool32 shaderUniformBufferArrayDynamicIndexing_= { },
        VkBool32 shaderSampledImageArrayDynamicIndexing_= { },
        VkBool32 shaderStorageBufferArrayDynamicIndexing_= { },
        VkBool32 shaderStorageImageArrayDynamicIndexing_= { },
        VkBool32 shaderClipDistance_= { },
        VkBool32 shaderCullDistance_= { },
        VkBool32 shaderFloat64_= { },
        VkBool32 shaderInt64_= { },
        VkBool32 shaderInt16_= { },
        VkBool32 shaderResourceResidency_= { },
        VkBool32 shaderResourceMinLod_= { },
        VkBool32 sparseBinding_= { },
        VkBool32 sparseResidencyBuffer_= { },
        VkBool32 sparseResidencyImage2D_= { },
        VkBool32 sparseResidencyImage3D_= { },
        VkBool32 sparseResidency2Samples_= { },
        VkBool32 sparseResidency4Samples_= { },
        VkBool32 sparseResidency8Samples_= { },
        VkBool32 sparseResidency16Samples_= { },
        VkBool32 sparseResidencyAliased_= { },
        VkBool32 variableMultisampleRate_= { },
        VkBool32 inheritedQueries_= { }
    ) : Otype{
        robustBufferAccess_,
        fullDrawIndexUint32_,
        imageCubeArray_,
        independentBlend_,
        geometryShader_,
        tessellationShader_,
        sampleRateShading_,
        dualSrcBlend_,
        logicOp_,
        multiDrawIndirect_,
        drawIndirectFirstInstance_,
        depthClamp_,
        depthBiasClamp_,
        fillModeNonSolid_,
        depthBounds_,
        wideLines_,
        largePoints_,
        alphaToOne_,
        multiViewport_,
        samplerAnisotropy_,
        textureCompressionETC2_,
        textureCompressionASTC_LDR_,
        textureCompressionBC_,
        occlusionQueryPrecise_,
        pipelineStatisticsQuery_,
        vertexPipelineStoresAndAtomics_,
        fragmentStoresAndAtomics_,
        shaderTessellationAndGeometryPointSize_,
        shaderImageGatherExtended_,
        shaderStorageImageExtendedFormats_,
        shaderStorageImageMultisample_,
        shaderStorageImageReadWithoutFormat_,
        shaderStorageImageWriteWithoutFormat_,
        shaderUniformBufferArrayDynamicIndexing_,
        shaderSampledImageArrayDynamicIndexing_,
        shaderStorageBufferArrayDynamicIndexing_,
        shaderStorageImageArrayDynamicIndexing_,
        shaderClipDistance_,
        shaderCullDistance_,
        shaderFloat64_,
        shaderInt64_,
        shaderInt16_,
        shaderResourceResidency_,
        shaderResourceMinLod_,
        sparseBinding_,
        sparseResidencyBuffer_,
        sparseResidencyImage2D_,
        sparseResidencyImage3D_,
        sparseResidency2Samples_,
        sparseResidency4Samples_,
        sparseResidency8Samples_,
        sparseResidency16Samples_,
        sparseResidencyAliased_,
        variableMultisampleRate_,
        inheritedQueries_
    } { }
    inL S_PhysicalDeviceFeatures& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceFeatures*() { return this; }
    inL operator S_PhysicalDeviceFeatures const* () const { return const_cast<S_PhysicalDeviceFeatures const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceFeatures> { using T = S_PhysicalDeviceFeatures; };
struct S_DisplaySurfaceCreateInfoKHR : public VkDisplaySurfaceCreateInfoKHR {
public:
    using Otype = VkDisplaySurfaceCreateInfoKHR;
public:
    S_DisplaySurfaceCreateInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplaySurfaceCreateInfoKHR(
        VkDisplaySurfaceCreateFlagsKHR flags_= { },
        VkDisplayModeKHR displayMode_= { },
        uint32_t planeIndex_= { },
        uint32_t planeStackIndex_= { },
        F_SurfaceTransformKHR transform_= { },
        float globalAlpha_= { },
        F_DisplayPlaneAlphaKHR alphaMode_= { },
        S_Extent2D imageExtent_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,
        nullptr,
        flags_,
        displayMode_,
        planeIndex_,
        planeStackIndex_,
        transform_,
        globalAlpha_,
        alphaMode_,
        imageExtent_
    } { }
    inL S_DisplaySurfaceCreateInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplaySurfaceCreateInfoKHR*() { return this; }
    inL operator S_DisplaySurfaceCreateInfoKHR const* () const { return const_cast<S_DisplaySurfaceCreateInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkDisplaySurfaceCreateInfoKHR> { using T = S_DisplaySurfaceCreateInfoKHR; };
struct S_ImagePlaneMemoryRequirementsInfo : public VkImagePlaneMemoryRequirementsInfo {
public:
    using Otype = VkImagePlaneMemoryRequirementsInfo;
public:
    S_ImagePlaneMemoryRequirementsInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImagePlaneMemoryRequirementsInfo(
        F_ImageAspect planeAspect_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
        nullptr,
        planeAspect_
    } { }
    inL S_ImagePlaneMemoryRequirementsInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImagePlaneMemoryRequirementsInfo*() { return this; }
    inL operator S_ImagePlaneMemoryRequirementsInfo const* () const { return const_cast<S_ImagePlaneMemoryRequirementsInfo const*>(this); }
};
template<> struct detail::names_map<VkImagePlaneMemoryRequirementsInfo> { using T = S_ImagePlaneMemoryRequirementsInfo; };
struct N_ImageMemoryRequirementsInfo2{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_ImageMemoryRequirementsInfo2& n_VkImagePlaneMemoryRequirementsInfo(Aref<S_ImagePlaneMemoryRequirementsInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_ImageMemoryRequirementsInfo2 : public VkImageMemoryRequirementsInfo2 {
public:
    using Otype = VkImageMemoryRequirementsInfo2;
public:
    S_ImageMemoryRequirementsInfo2(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageMemoryRequirementsInfo2(
        VkImage image_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
        nullptr,
        image_
    } { }
    S_ImageMemoryRequirementsInfo2& set_next(N_ImageMemoryRequirementsInfo2& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_ImageMemoryRequirementsInfo2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageMemoryRequirementsInfo2*() { return this; }
    inL operator S_ImageMemoryRequirementsInfo2 const* () const { return const_cast<S_ImageMemoryRequirementsInfo2 const*>(this); }
};
template<> struct detail::names_map<VkImageMemoryRequirementsInfo2> { using T = S_ImageMemoryRequirementsInfo2; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_ExportMemoryWin32HandleInfoKHR : public VkExportMemoryWin32HandleInfoKHR {
public:
    using Otype = VkExportMemoryWin32HandleInfoKHR;
public:
    S_ExportMemoryWin32HandleInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExportMemoryWin32HandleInfoKHR(
        Aptr<SECURITY_ATTRIBUTES> pAttributes_= { },
        DWORD dwAccess_= { },
        LPCWSTR name_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR,
        nullptr,
        pAttributes_,
        dwAccess_,
        name_
    } { }
    inL S_ExportMemoryWin32HandleInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExportMemoryWin32HandleInfoKHR*() { return this; }
    inL operator S_ExportMemoryWin32HandleInfoKHR const* () const { return const_cast<S_ExportMemoryWin32HandleInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkExportMemoryWin32HandleInfoKHR> { using T = S_ExportMemoryWin32HandleInfoKHR; };

#endif
struct S_ApplicationInfo : public VkApplicationInfo {
public:
    using Otype = VkApplicationInfo;
public:
    S_ApplicationInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_ApplicationInfo(
        Aptr<char> pApplicationName_= { },
        uint32_t applicationVersion_= { },
        Aptr<char> pEngineName_= { },
        uint32_t engineVersion_= { },
        uint32_t apiVersion_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_APPLICATION_INFO,
        nullptr,
        pApplicationName_,
        applicationVersion_,
        pEngineName_,
        engineVersion_,
        apiVersion_
    } { }
    inL S_ApplicationInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ApplicationInfo*() { return this; }
    inL operator S_ApplicationInfo const* () const { return const_cast<S_ApplicationInfo const*>(this); }
};
template<> struct detail::names_map<VkApplicationInfo> { using T = S_ApplicationInfo; };
struct S_DebugUtilsMessengerCreateInfoEXT : public VkDebugUtilsMessengerCreateInfoEXT {
public:
    using Otype = VkDebugUtilsMessengerCreateInfoEXT;
public:
    S_DebugUtilsMessengerCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DebugUtilsMessengerCreateInfoEXT(
        VkDebugUtilsMessengerCreateFlagsEXT flags_= { },
        VkDebugUtilsMessageSeverityFlagsEXT messageSeverity_= { },
        VkDebugUtilsMessageTypeFlagsEXT messageType_= { },
        PFN_vkDebugUtilsMessengerCallbackEXT pfnUserCallback_= { },
        Aptr<void> pUserData_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
        nullptr,
        flags_,
        messageSeverity_,
        messageType_,
        pfnUserCallback_,
        pUserData_
    } { }
    inL S_DebugUtilsMessengerCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DebugUtilsMessengerCreateInfoEXT*() { return this; }
    inL operator S_DebugUtilsMessengerCreateInfoEXT const* () const { return const_cast<S_DebugUtilsMessengerCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDebugUtilsMessengerCreateInfoEXT> { using T = S_DebugUtilsMessengerCreateInfoEXT; };
struct S_DebugReportCallbackCreateInfoEXT : public VkDebugReportCallbackCreateInfoEXT {
public:
    using Otype = VkDebugReportCallbackCreateInfoEXT;
public:
    S_DebugReportCallbackCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DebugReportCallbackCreateInfoEXT(
        VkDebugReportFlagsEXT flags_= { },
        PFN_vkDebugReportCallbackEXT pfnCallback_= { },
        Aptr<void> pUserData_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
        nullptr,
        flags_,
        pfnCallback_,
        pUserData_
    } { }
    inL S_DebugReportCallbackCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DebugReportCallbackCreateInfoEXT*() { return this; }
    inL operator S_DebugReportCallbackCreateInfoEXT const* () const { return const_cast<S_DebugReportCallbackCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDebugReportCallbackCreateInfoEXT> { using T = S_DebugReportCallbackCreateInfoEXT; };
struct S_ValidationFeaturesEXT : public VkValidationFeaturesEXT {
public:
    using Otype = VkValidationFeaturesEXT;
public:
    S_ValidationFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_ValidationFeaturesEXT(
        Array_general<E_ValidationFeatureEnableEXT> pEnabledValidationFeatures_= { },
        Array_general<E_ValidationFeatureDisableEXT> pDisabledValidationFeatures_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT,
        nullptr,
        pEnabledValidationFeatures_.size(),
        reinterpret_cast<VkValidationFeatureEnableEXT*>(pEnabledValidationFeatures_.data()),
        pDisabledValidationFeatures_.size(),
        reinterpret_cast<VkValidationFeatureDisableEXT*>(pDisabledValidationFeatures_.data())
    } { }
    inL S_ValidationFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ValidationFeaturesEXT*() { return this; }
    inL operator S_ValidationFeaturesEXT const* () const { return const_cast<S_ValidationFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkValidationFeaturesEXT> { using T = S_ValidationFeaturesEXT; };
struct N_InstanceCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_InstanceCreateInfo& n_VkValidationFlagsEXT(Aref<S_ValidationFlagsEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_InstanceCreateInfo& n_VkDebugUtilsMessengerCreateInfoEXT(Aref<S_DebugUtilsMessengerCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_InstanceCreateInfo& n_VkDebugReportCallbackCreateInfoEXT(Aref<S_DebugReportCallbackCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_InstanceCreateInfo& n_VkValidationFeaturesEXT(Aref<S_ValidationFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_InstanceCreateInfo : public VkInstanceCreateInfo {
public:
    using Otype = VkInstanceCreateInfo;
public:
    S_InstanceCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_InstanceCreateInfo(
        VkInstanceCreateFlags flags_= { },
        Aptr<S_ApplicationInfo> pApplicationInfo_= { },
        Array_general<char*> ppEnabledLayerNames_= { },
        Array_general<char*> ppEnabledExtensionNames_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        nullptr,
        flags_,
        pApplicationInfo_,
        ppEnabledLayerNames_.size(),
        reinterpret_cast<char**>(ppEnabledLayerNames_.data()),
        ppEnabledExtensionNames_.size(),
        reinterpret_cast<char**>(ppEnabledExtensionNames_.data())
    } { }
    S_InstanceCreateInfo& set_next(N_InstanceCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_InstanceCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_InstanceCreateInfo*() { return this; }
    inL operator S_InstanceCreateInfo const* () const { return const_cast<S_InstanceCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkInstanceCreateInfo> { using T = S_InstanceCreateInfo; };
struct S_PhysicalDeviceShadingRateImageFeaturesNV : public VkPhysicalDeviceShadingRateImageFeaturesNV {
public:
    using Otype = VkPhysicalDeviceShadingRateImageFeaturesNV;
public:
    S_PhysicalDeviceShadingRateImageFeaturesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceShadingRateImageFeaturesNV(
        VkBool32 shadingRateImage_= { },
        VkBool32 shadingRateCoarseSampleOrder_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
        nullptr,
        shadingRateImage_,
        shadingRateCoarseSampleOrder_
    } { }
    inL S_PhysicalDeviceShadingRateImageFeaturesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceShadingRateImageFeaturesNV*() { return this; }
    inL operator S_PhysicalDeviceShadingRateImageFeaturesNV const* () const { return const_cast<S_PhysicalDeviceShadingRateImageFeaturesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceShadingRateImageFeaturesNV> { using T = S_PhysicalDeviceShadingRateImageFeaturesNV; };
struct S_PipelineCoverageModulationStateCreateInfoNV : public VkPipelineCoverageModulationStateCreateInfoNV {
public:
    using Otype = VkPipelineCoverageModulationStateCreateInfoNV;
public:
    S_PipelineCoverageModulationStateCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineCoverageModulationStateCreateInfoNV(
        VkPipelineCoverageModulationStateCreateFlagsNV flags_= { },
        E_CoverageModulationModeNV coverageModulationMode_= { },
        VkBool32 coverageModulationTableEnable_= { },
        Array_general<float> pCoverageModulationTable_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
        nullptr,
        flags_,
        coverageModulationMode_,
        coverageModulationTableEnable_,
        pCoverageModulationTable_.size(),
        reinterpret_cast<float*>(pCoverageModulationTable_.data())
    } { }
    inL S_PipelineCoverageModulationStateCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineCoverageModulationStateCreateInfoNV*() { return this; }
    inL operator S_PipelineCoverageModulationStateCreateInfoNV const* () const { return const_cast<S_PipelineCoverageModulationStateCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkPipelineCoverageModulationStateCreateInfoNV> { using T = S_PipelineCoverageModulationStateCreateInfoNV; };

# if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct S_AndroidHardwareBufferFormatPropertiesANDROID : public VkAndroidHardwareBufferFormatPropertiesANDROID {
public:
    using Otype = VkAndroidHardwareBufferFormatPropertiesANDROID;
public:
    S_AndroidHardwareBufferFormatPropertiesANDROID(Otype& origin_obj_):Otype(origin_obj_){}
    S_AndroidHardwareBufferFormatPropertiesANDROID(
        E_Format format_= { },
        uint64_t externalFormat_= { },
        VkFormatFeatureFlags formatFeatures_= { },
        S_ComponentMapping samplerYcbcrConversionComponents_= { },
        E_SamplerYcbcrModelConversion suggestedYcbcrModel_= { },
        E_SamplerYcbcrRange suggestedYcbcrRange_= { },
        E_ChromaLocation suggestedXChromaOffset_= { },
        E_ChromaLocation suggestedYChromaOffset_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID,
        nullptr,
        format_,
        externalFormat_,
        formatFeatures_,
        samplerYcbcrConversionComponents_,
        suggestedYcbcrModel_,
        suggestedYcbcrRange_,
        suggestedXChromaOffset_,
        suggestedYChromaOffset_
    } { }
    inL S_AndroidHardwareBufferFormatPropertiesANDROID& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AndroidHardwareBufferFormatPropertiesANDROID*() { return this; }
    inL operator S_AndroidHardwareBufferFormatPropertiesANDROID const* () const { return const_cast<S_AndroidHardwareBufferFormatPropertiesANDROID const*>(this); }
};
template<> struct detail::names_map<VkAndroidHardwareBufferFormatPropertiesANDROID> { using T = S_AndroidHardwareBufferFormatPropertiesANDROID; };

#endif

# if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct N_AndroidHardwareBufferPropertiesANDROID{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
# if defined(VK_USE_PLATFORM_ANDROID_KHR)
    inL N_AndroidHardwareBufferPropertiesANDROID& n_VkAndroidHardwareBufferFormatPropertiesANDROID(Aref<S_AndroidHardwareBufferFormatPropertiesANDROID> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
};
struct S_AndroidHardwareBufferPropertiesANDROID : public VkAndroidHardwareBufferPropertiesANDROID {
public:
    using Otype = VkAndroidHardwareBufferPropertiesANDROID;
public:
    S_AndroidHardwareBufferPropertiesANDROID(Otype& origin_obj_):Otype(origin_obj_){}
    S_AndroidHardwareBufferPropertiesANDROID(
        VkDeviceSize allocationSize_= { },
        uint32_t memoryTypeBits_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID,
        nullptr,
        allocationSize_,
        memoryTypeBits_
    } { }
# if defined(VK_USE_PLATFORM_ANDROID_KHR)
    inL S_AndroidHardwareBufferPropertiesANDROID& n_VkAndroidHardwareBufferFormatPropertiesANDROID(Aref<S_AndroidHardwareBufferFormatPropertiesANDROID> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    S_AndroidHardwareBufferPropertiesANDROID& set_next(N_AndroidHardwareBufferPropertiesANDROID& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_AndroidHardwareBufferPropertiesANDROID& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AndroidHardwareBufferPropertiesANDROID*() { return this; }
    inL operator S_AndroidHardwareBufferPropertiesANDROID const* () const { return const_cast<S_AndroidHardwareBufferPropertiesANDROID const*>(this); }
};
template<> struct detail::names_map<VkAndroidHardwareBufferPropertiesANDROID> { using T = S_AndroidHardwareBufferPropertiesANDROID; };

#endif
struct S_ObjectTableIndexBufferEntryNVX : public VkObjectTableIndexBufferEntryNVX {
public:
    using Otype = VkObjectTableIndexBufferEntryNVX;
public:
    S_ObjectTableIndexBufferEntryNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_ObjectTableIndexBufferEntryNVX(
        E_ObjectEntryTypeNVX type_= { },
        VkObjectEntryUsageFlagsNVX flags_= { },
        VkBuffer buffer_= { },
        E_IndexType indexType_= { }
    ) : Otype{
        type_,
        flags_,
        buffer_,
        indexType_
    } { }
    inL S_ObjectTableIndexBufferEntryNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ObjectTableIndexBufferEntryNVX*() { return this; }
    inL operator S_ObjectTableIndexBufferEntryNVX const* () const { return const_cast<S_ObjectTableIndexBufferEntryNVX const*>(this); }
};
template<> struct detail::names_map<VkObjectTableIndexBufferEntryNVX> { using T = S_ObjectTableIndexBufferEntryNVX; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_MemoryWin32HandlePropertiesKHR : public VkMemoryWin32HandlePropertiesKHR {
public:
    using Otype = VkMemoryWin32HandlePropertiesKHR;
public:
    S_MemoryWin32HandlePropertiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryWin32HandlePropertiesKHR(
        uint32_t memoryTypeBits_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR,
        nullptr,
        memoryTypeBits_
    } { }
    inL S_MemoryWin32HandlePropertiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryWin32HandlePropertiesKHR*() { return this; }
    inL operator S_MemoryWin32HandlePropertiesKHR const* () const { return const_cast<S_MemoryWin32HandlePropertiesKHR const*>(this); }
};
template<> struct detail::names_map<VkMemoryWin32HandlePropertiesKHR> { using T = S_MemoryWin32HandlePropertiesKHR; };

#endif
struct S_AttachmentReference : public VkAttachmentReference {
public:
    using Otype = VkAttachmentReference;
public:
    S_AttachmentReference(Otype& origin_obj_):Otype(origin_obj_){}
    S_AttachmentReference(
        uint32_t attachment_= { },
        E_ImageLayout layout_= { }
    ) : Otype{
        attachment_,
        layout_
    } { }
    inL S_AttachmentReference& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AttachmentReference*() { return this; }
    inL operator S_AttachmentReference const* () const { return const_cast<S_AttachmentReference const*>(this); }
};
template<> struct detail::names_map<VkAttachmentReference> { using T = S_AttachmentReference; };
struct S_SubpassDescription : public VkSubpassDescription {
public:
    using Otype = VkSubpassDescription;
public:
    S_SubpassDescription(Otype& origin_obj_):Otype(origin_obj_){}
    S_SubpassDescription(
        VkSubpassDescriptionFlags flags_= { },
        E_PipelineBindPoint pipelineBindPoint_= { },
        Array_general<S_AttachmentReference> pInputAttachments_= { },
        Array_general<S_AttachmentReference> pColorAttachments_= { },
        Array_general<S_AttachmentReference> pResolveAttachments_= { },
        Aptr<S_AttachmentReference> pDepthStencilAttachment_= { },
        Array_general<uint32_t> pPreserveAttachments_= { }
    ) : Otype{
        flags_,
        pipelineBindPoint_,
        pInputAttachments_.size(),
        reinterpret_cast<VkAttachmentReference*>(pInputAttachments_.data()),
        pColorAttachments_.size(),
        reinterpret_cast<VkAttachmentReference*>(pColorAttachments_.data()),
        reinterpret_cast<VkAttachmentReference*>(pResolveAttachments_.data()),
        pDepthStencilAttachment_,
        pPreserveAttachments_.size(),
        reinterpret_cast<uint32_t*>(pPreserveAttachments_.data())
    } { }
    inL S_SubpassDescription& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SubpassDescription*() { return this; }
    inL operator S_SubpassDescription const* () const { return const_cast<S_SubpassDescription const*>(this); }
};
template<> struct detail::names_map<VkSubpassDescription> { using T = S_SubpassDescription; };
struct S_PhysicalDeviceDescriptorIndexingPropertiesEXT : public VkPhysicalDeviceDescriptorIndexingPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceDescriptorIndexingPropertiesEXT;
public:
    S_PhysicalDeviceDescriptorIndexingPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceDescriptorIndexingPropertiesEXT(
        uint32_t maxUpdateAfterBindDescriptorsInAllPools_= { },
        VkBool32 shaderUniformBufferArrayNonUniformIndexingNative_= { },
        VkBool32 shaderSampledImageArrayNonUniformIndexingNative_= { },
        VkBool32 shaderStorageBufferArrayNonUniformIndexingNative_= { },
        VkBool32 shaderStorageImageArrayNonUniformIndexingNative_= { },
        VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative_= { },
        VkBool32 robustBufferAccessUpdateAfterBind_= { },
        VkBool32 quadDivergentImplicitLod_= { },
        uint32_t maxPerStageDescriptorUpdateAfterBindSamplers_= { },
        uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers_= { },
        uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers_= { },
        uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages_= { },
        uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages_= { },
        uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments_= { },
        uint32_t maxPerStageUpdateAfterBindResources_= { },
        uint32_t maxDescriptorSetUpdateAfterBindSamplers_= { },
        uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers_= { },
        uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_= { },
        uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers_= { },
        uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_= { },
        uint32_t maxDescriptorSetUpdateAfterBindSampledImages_= { },
        uint32_t maxDescriptorSetUpdateAfterBindStorageImages_= { },
        uint32_t maxDescriptorSetUpdateAfterBindInputAttachments_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT,
        nullptr,
        maxUpdateAfterBindDescriptorsInAllPools_,
        shaderUniformBufferArrayNonUniformIndexingNative_,
        shaderSampledImageArrayNonUniformIndexingNative_,
        shaderStorageBufferArrayNonUniformIndexingNative_,
        shaderStorageImageArrayNonUniformIndexingNative_,
        shaderInputAttachmentArrayNonUniformIndexingNative_,
        robustBufferAccessUpdateAfterBind_,
        quadDivergentImplicitLod_,
        maxPerStageDescriptorUpdateAfterBindSamplers_,
        maxPerStageDescriptorUpdateAfterBindUniformBuffers_,
        maxPerStageDescriptorUpdateAfterBindStorageBuffers_,
        maxPerStageDescriptorUpdateAfterBindSampledImages_,
        maxPerStageDescriptorUpdateAfterBindStorageImages_,
        maxPerStageDescriptorUpdateAfterBindInputAttachments_,
        maxPerStageUpdateAfterBindResources_,
        maxDescriptorSetUpdateAfterBindSamplers_,
        maxDescriptorSetUpdateAfterBindUniformBuffers_,
        maxDescriptorSetUpdateAfterBindUniformBuffersDynamic_,
        maxDescriptorSetUpdateAfterBindStorageBuffers_,
        maxDescriptorSetUpdateAfterBindStorageBuffersDynamic_,
        maxDescriptorSetUpdateAfterBindSampledImages_,
        maxDescriptorSetUpdateAfterBindStorageImages_,
        maxDescriptorSetUpdateAfterBindInputAttachments_
    } { }
    inL S_PhysicalDeviceDescriptorIndexingPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceDescriptorIndexingPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceDescriptorIndexingPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceDescriptorIndexingPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceDescriptorIndexingPropertiesEXT> { using T = S_PhysicalDeviceDescriptorIndexingPropertiesEXT; };
struct S_PhysicalDeviceMeshShaderFeaturesNV : public VkPhysicalDeviceMeshShaderFeaturesNV {
public:
    using Otype = VkPhysicalDeviceMeshShaderFeaturesNV;
public:
    S_PhysicalDeviceMeshShaderFeaturesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceMeshShaderFeaturesNV(
        VkBool32 taskShader_= { },
        VkBool32 meshShader_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
        nullptr,
        taskShader_,
        meshShader_
    } { }
    inL S_PhysicalDeviceMeshShaderFeaturesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceMeshShaderFeaturesNV*() { return this; }
    inL operator S_PhysicalDeviceMeshShaderFeaturesNV const* () const { return const_cast<S_PhysicalDeviceMeshShaderFeaturesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceMeshShaderFeaturesNV> { using T = S_PhysicalDeviceMeshShaderFeaturesNV; };
struct S_InputAttachmentAspectReference : public VkInputAttachmentAspectReference {
public:
    using Otype = VkInputAttachmentAspectReference;
public:
    S_InputAttachmentAspectReference(Otype& origin_obj_):Otype(origin_obj_){}
    S_InputAttachmentAspectReference(
        uint32_t subpass_= { },
        uint32_t inputAttachmentIndex_= { },
        VkImageAspectFlags aspectMask_= { }
    ) : Otype{
        subpass_,
        inputAttachmentIndex_,
        aspectMask_
    } { }
    inL S_InputAttachmentAspectReference& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_InputAttachmentAspectReference*() { return this; }
    inL operator S_InputAttachmentAspectReference const* () const { return const_cast<S_InputAttachmentAspectReference const*>(this); }
};
template<> struct detail::names_map<VkInputAttachmentAspectReference> { using T = S_InputAttachmentAspectReference; };

# if defined(VK_USE_PLATFORM_IOS_MVK)
struct S_IOSSurfaceCreateInfoMVK : public VkIOSSurfaceCreateInfoMVK {
public:
    using Otype = VkIOSSurfaceCreateInfoMVK;
public:
    S_IOSSurfaceCreateInfoMVK(Otype& origin_obj_):Otype(origin_obj_){}
    S_IOSSurfaceCreateInfoMVK(
        VkIOSSurfaceCreateFlagsMVK flags_= { },
        Aptr<void> pView_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK,
        nullptr,
        flags_,
        pView_
    } { }
    inL S_IOSSurfaceCreateInfoMVK& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_IOSSurfaceCreateInfoMVK*() { return this; }
    inL operator S_IOSSurfaceCreateInfoMVK const* () const { return const_cast<S_IOSSurfaceCreateInfoMVK const*>(this); }
};
template<> struct detail::names_map<VkIOSSurfaceCreateInfoMVK> { using T = S_IOSSurfaceCreateInfoMVK; };

#endif
struct S_SwapchainDisplayNativeHdrCreateInfoAMD : public VkSwapchainDisplayNativeHdrCreateInfoAMD {
public:
    using Otype = VkSwapchainDisplayNativeHdrCreateInfoAMD;
public:
    S_SwapchainDisplayNativeHdrCreateInfoAMD(Otype& origin_obj_):Otype(origin_obj_){}
    S_SwapchainDisplayNativeHdrCreateInfoAMD(
        VkBool32 localDimmingEnable_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
        nullptr,
        localDimmingEnable_
    } { }
    inL S_SwapchainDisplayNativeHdrCreateInfoAMD& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SwapchainDisplayNativeHdrCreateInfoAMD*() { return this; }
    inL operator S_SwapchainDisplayNativeHdrCreateInfoAMD const* () const { return const_cast<S_SwapchainDisplayNativeHdrCreateInfoAMD const*>(this); }
};
template<> struct detail::names_map<VkSwapchainDisplayNativeHdrCreateInfoAMD> { using T = S_SwapchainDisplayNativeHdrCreateInfoAMD; };
struct S_PhysicalDeviceGroupProperties : public VkPhysicalDeviceGroupProperties {
public:
    using Otype = VkPhysicalDeviceGroupProperties;
public:
    S_PhysicalDeviceGroupProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceGroupProperties(
        uint32_t physicalDeviceCount_= { },
        std::array<VkPhysicalDevice,VK_MAX_DEVICE_GROUP_SIZE> physicalDevices_= { },
        VkBool32 subsetAllocation_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
        nullptr,
        physicalDeviceCount_,
        { },
        subsetAllocation_
    } { 
        ::memcpy(&physicalDevices[0], physicalDevices_.data(), physicalDevices_.size() );
    }
    inL S_PhysicalDeviceGroupProperties& 
        set_physicalDevices(std::array<VkPhysicalDevice,VK_MAX_DEVICE_GROUP_SIZE> physicalDevices_)
        {  return *this; }
    inL S_PhysicalDeviceGroupProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceGroupProperties*() { return this; }
    inL operator S_PhysicalDeviceGroupProperties const* () const { return const_cast<S_PhysicalDeviceGroupProperties const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceGroupProperties> { using T = S_PhysicalDeviceGroupProperties; };
struct S_MemoryHostPointerPropertiesEXT : public VkMemoryHostPointerPropertiesEXT {
public:
    using Otype = VkMemoryHostPointerPropertiesEXT;
public:
    S_MemoryHostPointerPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryHostPointerPropertiesEXT(
        uint32_t memoryTypeBits_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
        nullptr,
        memoryTypeBits_
    } { }
    inL S_MemoryHostPointerPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryHostPointerPropertiesEXT*() { return this; }
    inL operator S_MemoryHostPointerPropertiesEXT const* () const { return const_cast<S_MemoryHostPointerPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkMemoryHostPointerPropertiesEXT> { using T = S_MemoryHostPointerPropertiesEXT; };
struct S_VertexInputAttributeDescription : public VkVertexInputAttributeDescription {
public:
    using Otype = VkVertexInputAttributeDescription;
public:
    S_VertexInputAttributeDescription(Otype& origin_obj_):Otype(origin_obj_){}
    S_VertexInputAttributeDescription(
        uint32_t location_= { },
        uint32_t binding_= { },
        E_Format format_= { },
        uint32_t offset_= { }
    ) : Otype{
        location_,
        binding_,
        format_,
        offset_
    } { }
    inL S_VertexInputAttributeDescription& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_VertexInputAttributeDescription*() { return this; }
    inL operator S_VertexInputAttributeDescription const* () const { return const_cast<S_VertexInputAttributeDescription const*>(this); }
};
template<> struct detail::names_map<VkVertexInputAttributeDescription> { using T = S_VertexInputAttributeDescription; };
struct S_ImportFenceFdInfoKHR : public VkImportFenceFdInfoKHR {
public:
    using Otype = VkImportFenceFdInfoKHR;
public:
    S_ImportFenceFdInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImportFenceFdInfoKHR(
        VkFence fence_= { },
        VkFenceImportFlags flags_= { },
        F_ExternalFenceHandleType handleType_= { },
        int fd_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR,
        nullptr,
        fence_,
        flags_,
        handleType_,
        fd_
    } { }
    inL S_ImportFenceFdInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImportFenceFdInfoKHR*() { return this; }
    inL operator S_ImportFenceFdInfoKHR const* () const { return const_cast<S_ImportFenceFdInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkImportFenceFdInfoKHR> { using T = S_ImportFenceFdInfoKHR; };
struct S_DeviceMemoryOverallocationCreateInfoAMD : public VkDeviceMemoryOverallocationCreateInfoAMD {
public:
    using Otype = VkDeviceMemoryOverallocationCreateInfoAMD;
public:
    S_DeviceMemoryOverallocationCreateInfoAMD(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceMemoryOverallocationCreateInfoAMD(
        E_MemoryOverallocationBehaviorAMD overallocationBehavior_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
        nullptr,
        overallocationBehavior_
    } { }
    inL S_DeviceMemoryOverallocationCreateInfoAMD& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceMemoryOverallocationCreateInfoAMD*() { return this; }
    inL operator S_DeviceMemoryOverallocationCreateInfoAMD const* () const { return const_cast<S_DeviceMemoryOverallocationCreateInfoAMD const*>(this); }
};
template<> struct detail::names_map<VkDeviceMemoryOverallocationCreateInfoAMD> { using T = S_DeviceMemoryOverallocationCreateInfoAMD; };
struct S_PerformanceStreamMarkerInfoINTEL : public VkPerformanceStreamMarkerInfoINTEL {
public:
    using Otype = VkPerformanceStreamMarkerInfoINTEL;
public:
    S_PerformanceStreamMarkerInfoINTEL(Otype& origin_obj_):Otype(origin_obj_){}
    S_PerformanceStreamMarkerInfoINTEL(
        uint32_t marker_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL,
        nullptr,
        marker_
    } { }
    inL S_PerformanceStreamMarkerInfoINTEL& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PerformanceStreamMarkerInfoINTEL*() { return this; }
    inL operator S_PerformanceStreamMarkerInfoINTEL const* () const { return const_cast<S_PerformanceStreamMarkerInfoINTEL const*>(this); }
};
template<> struct detail::names_map<VkPerformanceStreamMarkerInfoINTEL> { using T = S_PerformanceStreamMarkerInfoINTEL; };
struct S_PhysicalDeviceCornerSampledImageFeaturesNV : public VkPhysicalDeviceCornerSampledImageFeaturesNV {
public:
    using Otype = VkPhysicalDeviceCornerSampledImageFeaturesNV;
public:
    S_PhysicalDeviceCornerSampledImageFeaturesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceCornerSampledImageFeaturesNV(
        VkBool32 cornerSampledImage_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
        nullptr,
        cornerSampledImage_
    } { }
    inL S_PhysicalDeviceCornerSampledImageFeaturesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceCornerSampledImageFeaturesNV*() { return this; }
    inL operator S_PhysicalDeviceCornerSampledImageFeaturesNV const* () const { return const_cast<S_PhysicalDeviceCornerSampledImageFeaturesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceCornerSampledImageFeaturesNV> { using T = S_PhysicalDeviceCornerSampledImageFeaturesNV; };
struct S_SamplerYcbcrConversionImageFormatProperties : public VkSamplerYcbcrConversionImageFormatProperties {
public:
    using Otype = VkSamplerYcbcrConversionImageFormatProperties;
public:
    S_SamplerYcbcrConversionImageFormatProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_SamplerYcbcrConversionImageFormatProperties(
        uint32_t combinedImageSamplerDescriptorCount_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
        nullptr,
        combinedImageSamplerDescriptorCount_
    } { }
    inL S_SamplerYcbcrConversionImageFormatProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SamplerYcbcrConversionImageFormatProperties*() { return this; }
    inL operator S_SamplerYcbcrConversionImageFormatProperties const* () const { return const_cast<S_SamplerYcbcrConversionImageFormatProperties const*>(this); }
};
template<> struct detail::names_map<VkSamplerYcbcrConversionImageFormatProperties> { using T = S_SamplerYcbcrConversionImageFormatProperties; };

# if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct S_AndroidHardwareBufferUsageANDROID : public VkAndroidHardwareBufferUsageANDROID {
public:
    using Otype = VkAndroidHardwareBufferUsageANDROID;
public:
    S_AndroidHardwareBufferUsageANDROID(Otype& origin_obj_):Otype(origin_obj_){}
    S_AndroidHardwareBufferUsageANDROID(
        uint64_t androidHardwareBufferUsage_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID,
        nullptr,
        androidHardwareBufferUsage_
    } { }
    inL S_AndroidHardwareBufferUsageANDROID& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AndroidHardwareBufferUsageANDROID*() { return this; }
    inL operator S_AndroidHardwareBufferUsageANDROID const* () const { return const_cast<S_AndroidHardwareBufferUsageANDROID const*>(this); }
};
template<> struct detail::names_map<VkAndroidHardwareBufferUsageANDROID> { using T = S_AndroidHardwareBufferUsageANDROID; };

#endif
struct S_ExternalMemoryProperties : public VkExternalMemoryProperties {
public:
    using Otype = VkExternalMemoryProperties;
public:
    S_ExternalMemoryProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExternalMemoryProperties(
        VkExternalMemoryFeatureFlags externalMemoryFeatures_= { },
        VkExternalMemoryHandleTypeFlags exportFromImportedHandleTypes_= { },
        VkExternalMemoryHandleTypeFlags compatibleHandleTypes_= { }
    ) : Otype{
        externalMemoryFeatures_,
        exportFromImportedHandleTypes_,
        compatibleHandleTypes_
    } { }
    inL S_ExternalMemoryProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExternalMemoryProperties*() { return this; }
    inL operator S_ExternalMemoryProperties const* () const { return const_cast<S_ExternalMemoryProperties const*>(this); }
};
template<> struct detail::names_map<VkExternalMemoryProperties> { using T = S_ExternalMemoryProperties; };
struct S_ExternalImageFormatProperties : public VkExternalImageFormatProperties {
public:
    using Otype = VkExternalImageFormatProperties;
public:
    S_ExternalImageFormatProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExternalImageFormatProperties(
        S_ExternalMemoryProperties externalMemoryProperties_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
        nullptr,
        externalMemoryProperties_
    } { }
    inL S_ExternalImageFormatProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExternalImageFormatProperties*() { return this; }
    inL operator S_ExternalImageFormatProperties const* () const { return const_cast<S_ExternalImageFormatProperties const*>(this); }
};
template<> struct detail::names_map<VkExternalImageFormatProperties> { using T = S_ExternalImageFormatProperties; };
struct S_TextureLODGatherFormatPropertiesAMD : public VkTextureLODGatherFormatPropertiesAMD {
public:
    using Otype = VkTextureLODGatherFormatPropertiesAMD;
public:
    S_TextureLODGatherFormatPropertiesAMD(Otype& origin_obj_):Otype(origin_obj_){}
    S_TextureLODGatherFormatPropertiesAMD(
        VkBool32 supportsTextureGatherLODBiasAMD_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD,
        nullptr,
        supportsTextureGatherLODBiasAMD_
    } { }
    inL S_TextureLODGatherFormatPropertiesAMD& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_TextureLODGatherFormatPropertiesAMD*() { return this; }
    inL operator S_TextureLODGatherFormatPropertiesAMD const* () const { return const_cast<S_TextureLODGatherFormatPropertiesAMD const*>(this); }
};
template<> struct detail::names_map<VkTextureLODGatherFormatPropertiesAMD> { using T = S_TextureLODGatherFormatPropertiesAMD; };
struct N_ImageFormatProperties2{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_ImageFormatProperties2& n_VkFilterCubicImageViewImageFormatPropertiesEXT(Aref<S_FilterCubicImageViewImageFormatPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_ImageFormatProperties2& n_VkSamplerYcbcrConversionImageFormatProperties(Aref<S_SamplerYcbcrConversionImageFormatProperties> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# if defined(VK_USE_PLATFORM_ANDROID_KHR)
    inL N_ImageFormatProperties2& n_VkAndroidHardwareBufferUsageANDROID(Aref<S_AndroidHardwareBufferUsageANDROID> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    inL N_ImageFormatProperties2& n_VkExternalImageFormatProperties(Aref<S_ExternalImageFormatProperties> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_ImageFormatProperties2& n_VkTextureLODGatherFormatPropertiesAMD(Aref<S_TextureLODGatherFormatPropertiesAMD> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_ImageFormatProperties2 : public VkImageFormatProperties2 {
public:
    using Otype = VkImageFormatProperties2;
public:
    S_ImageFormatProperties2(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageFormatProperties2(
        S_ImageFormatProperties imageFormatProperties_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
        nullptr,
        imageFormatProperties_
    } { }
# if defined(VK_USE_PLATFORM_ANDROID_KHR)
    inL S_ImageFormatProperties2& n_VkAndroidHardwareBufferUsageANDROID(Aref<S_AndroidHardwareBufferUsageANDROID> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    S_ImageFormatProperties2& set_next(N_ImageFormatProperties2& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_ImageFormatProperties2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageFormatProperties2*() { return this; }
    inL operator S_ImageFormatProperties2 const* () const { return const_cast<S_ImageFormatProperties2 const*>(this); }
};
template<> struct detail::names_map<VkImageFormatProperties2> { using T = S_ImageFormatProperties2; };

# if defined(VK_USE_PLATFORM_XLIB_KHR)
struct S_XlibSurfaceCreateInfoKHR : public VkXlibSurfaceCreateInfoKHR {
public:
    using Otype = VkXlibSurfaceCreateInfoKHR;
public:
    S_XlibSurfaceCreateInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_XlibSurfaceCreateInfoKHR(
        VkXlibSurfaceCreateFlagsKHR flags_= { },
        Aptr<Display> dpy_= { },
        Window window_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR,
        nullptr,
        flags_,
        dpy_,
        window_
    } { }
    inL S_XlibSurfaceCreateInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_XlibSurfaceCreateInfoKHR*() { return this; }
    inL operator S_XlibSurfaceCreateInfoKHR const* () const { return const_cast<S_XlibSurfaceCreateInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkXlibSurfaceCreateInfoKHR> { using T = S_XlibSurfaceCreateInfoKHR; };

#endif
struct S_BufferMemoryRequirementsInfo2 : public VkBufferMemoryRequirementsInfo2 {
public:
    using Otype = VkBufferMemoryRequirementsInfo2;
public:
    S_BufferMemoryRequirementsInfo2(Otype& origin_obj_):Otype(origin_obj_){}
    S_BufferMemoryRequirementsInfo2(
        VkBuffer buffer_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
        nullptr,
        buffer_
    } { }
    inL S_BufferMemoryRequirementsInfo2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BufferMemoryRequirementsInfo2*() { return this; }
    inL operator S_BufferMemoryRequirementsInfo2 const* () const { return const_cast<S_BufferMemoryRequirementsInfo2 const*>(this); }
};
template<> struct detail::names_map<VkBufferMemoryRequirementsInfo2> { using T = S_BufferMemoryRequirementsInfo2; };
struct S_AccelerationStructureCreateInfoNV : public VkAccelerationStructureCreateInfoNV {
public:
    using Otype = VkAccelerationStructureCreateInfoNV;
public:
    S_AccelerationStructureCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_AccelerationStructureCreateInfoNV(
        VkDeviceSize compactedSize_= { },
        S_AccelerationStructureInfoNV info_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV,
        nullptr,
        compactedSize_,
        info_
    } { }
    inL S_AccelerationStructureCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AccelerationStructureCreateInfoNV*() { return this; }
    inL operator S_AccelerationStructureCreateInfoNV const* () const { return const_cast<S_AccelerationStructureCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkAccelerationStructureCreateInfoNV> { using T = S_AccelerationStructureCreateInfoNV; };
struct S_PhysicalDeviceExternalSemaphoreInfo : public VkPhysicalDeviceExternalSemaphoreInfo {
public:
    using Otype = VkPhysicalDeviceExternalSemaphoreInfo;
public:
    S_PhysicalDeviceExternalSemaphoreInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceExternalSemaphoreInfo(
        F_ExternalSemaphoreHandleType handleType_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
        nullptr,
        handleType_
    } { }
    inL S_PhysicalDeviceExternalSemaphoreInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceExternalSemaphoreInfo*() { return this; }
    inL operator S_PhysicalDeviceExternalSemaphoreInfo const* () const { return const_cast<S_PhysicalDeviceExternalSemaphoreInfo const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceExternalSemaphoreInfo> { using T = S_PhysicalDeviceExternalSemaphoreInfo; };
struct S_ImageResolve : public VkImageResolve {
public:
    using Otype = VkImageResolve;
public:
    S_ImageResolve(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageResolve(
        S_ImageSubresourceLayers srcSubresource_= { },
        S_Offset3D srcOffset_= { },
        S_ImageSubresourceLayers dstSubresource_= { },
        S_Offset3D dstOffset_= { },
        S_Extent3D extent_= { }
    ) : Otype{
        srcSubresource_,
        srcOffset_,
        dstSubresource_,
        dstOffset_,
        extent_
    } { }
    inL S_ImageResolve& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageResolve*() { return this; }
    inL operator S_ImageResolve const* () const { return const_cast<S_ImageResolve const*>(this); }
};
template<> struct detail::names_map<VkImageResolve> { using T = S_ImageResolve; };
struct S_RenderPassInputAttachmentAspectCreateInfo : public VkRenderPassInputAttachmentAspectCreateInfo {
public:
    using Otype = VkRenderPassInputAttachmentAspectCreateInfo;
public:
    S_RenderPassInputAttachmentAspectCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_RenderPassInputAttachmentAspectCreateInfo(
        Array_general<S_InputAttachmentAspectReference> pAspectReferences_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
        nullptr,
        pAspectReferences_.size(),
        reinterpret_cast<VkInputAttachmentAspectReference*>(pAspectReferences_.data())
    } { }
    inL S_RenderPassInputAttachmentAspectCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_RenderPassInputAttachmentAspectCreateInfo*() { return this; }
    inL operator S_RenderPassInputAttachmentAspectCreateInfo const* () const { return const_cast<S_RenderPassInputAttachmentAspectCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkRenderPassInputAttachmentAspectCreateInfo> { using T = S_RenderPassInputAttachmentAspectCreateInfo; };
struct S_FramebufferAttachmentImageInfoKHR : public VkFramebufferAttachmentImageInfoKHR {
public:
    using Otype = VkFramebufferAttachmentImageInfoKHR;
public:
    S_FramebufferAttachmentImageInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_FramebufferAttachmentImageInfoKHR(
        VkImageCreateFlags flags_= { },
        VkImageUsageFlags usage_= { },
        uint32_t width_= { },
        uint32_t height_= { },
        uint32_t layerCount_= { },
        Array_general<E_Format> pViewFormats_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR,
        nullptr,
        flags_,
        usage_,
        width_,
        height_,
        layerCount_,
        pViewFormats_.size(),
        reinterpret_cast<VkFormat*>(pViewFormats_.data())
    } { }
    inL S_FramebufferAttachmentImageInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_FramebufferAttachmentImageInfoKHR*() { return this; }
    inL operator S_FramebufferAttachmentImageInfoKHR const* () const { return const_cast<S_FramebufferAttachmentImageInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkFramebufferAttachmentImageInfoKHR> { using T = S_FramebufferAttachmentImageInfoKHR; };
struct S_FramebufferAttachmentsCreateInfoKHR : public VkFramebufferAttachmentsCreateInfoKHR {
public:
    using Otype = VkFramebufferAttachmentsCreateInfoKHR;
public:
    S_FramebufferAttachmentsCreateInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_FramebufferAttachmentsCreateInfoKHR(
        Array_general<S_FramebufferAttachmentImageInfoKHR> pAttachmentImageInfos_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR,
        nullptr,
        pAttachmentImageInfos_.size(),
        reinterpret_cast<VkFramebufferAttachmentImageInfoKHR*>(pAttachmentImageInfos_.data())
    } { }
    inL S_FramebufferAttachmentsCreateInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_FramebufferAttachmentsCreateInfoKHR*() { return this; }
    inL operator S_FramebufferAttachmentsCreateInfoKHR const* () const { return const_cast<S_FramebufferAttachmentsCreateInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkFramebufferAttachmentsCreateInfoKHR> { using T = S_FramebufferAttachmentsCreateInfoKHR; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_SurfaceCapabilitiesFullScreenExclusiveEXT : public VkSurfaceCapabilitiesFullScreenExclusiveEXT {
public:
    using Otype = VkSurfaceCapabilitiesFullScreenExclusiveEXT;
public:
    S_SurfaceCapabilitiesFullScreenExclusiveEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_SurfaceCapabilitiesFullScreenExclusiveEXT(
        VkBool32 fullScreenExclusiveSupported_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT,
        nullptr,
        fullScreenExclusiveSupported_
    } { }
    inL S_SurfaceCapabilitiesFullScreenExclusiveEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SurfaceCapabilitiesFullScreenExclusiveEXT*() { return this; }
    inL operator S_SurfaceCapabilitiesFullScreenExclusiveEXT const* () const { return const_cast<S_SurfaceCapabilitiesFullScreenExclusiveEXT const*>(this); }
};
template<> struct detail::names_map<VkSurfaceCapabilitiesFullScreenExclusiveEXT> { using T = S_SurfaceCapabilitiesFullScreenExclusiveEXT; };

#endif
struct N_SurfaceCapabilities2KHR{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_SurfaceCapabilities2KHR& n_VkDisplayNativeHdrSurfaceCapabilitiesAMD(Aref<S_DisplayNativeHdrSurfaceCapabilitiesAMD> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_SurfaceCapabilities2KHR& n_VkSurfaceProtectedCapabilitiesKHR(Aref<S_SurfaceProtectedCapabilitiesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_SurfaceCapabilities2KHR& n_VkSharedPresentSurfaceCapabilitiesKHR(Aref<S_SharedPresentSurfaceCapabilitiesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_SurfaceCapabilities2KHR& n_VkSurfaceCapabilitiesFullScreenExclusiveEXT(Aref<S_SurfaceCapabilitiesFullScreenExclusiveEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
};
struct S_SurfaceCapabilities2KHR : public VkSurfaceCapabilities2KHR {
public:
    using Otype = VkSurfaceCapabilities2KHR;
public:
    S_SurfaceCapabilities2KHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SurfaceCapabilities2KHR(
        S_SurfaceCapabilitiesKHR surfaceCapabilities_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR,
        nullptr,
        surfaceCapabilities_
    } { }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_SurfaceCapabilities2KHR& n_VkSurfaceCapabilitiesFullScreenExclusiveEXT(Aref<S_SurfaceCapabilitiesFullScreenExclusiveEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    S_SurfaceCapabilities2KHR& set_next(N_SurfaceCapabilities2KHR& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_SurfaceCapabilities2KHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SurfaceCapabilities2KHR*() { return this; }
    inL operator S_SurfaceCapabilities2KHR const* () const { return const_cast<S_SurfaceCapabilities2KHR const*>(this); }
};
template<> struct detail::names_map<VkSurfaceCapabilities2KHR> { using T = S_SurfaceCapabilities2KHR; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_MemoryGetWin32HandleInfoKHR : public VkMemoryGetWin32HandleInfoKHR {
public:
    using Otype = VkMemoryGetWin32HandleInfoKHR;
public:
    S_MemoryGetWin32HandleInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryGetWin32HandleInfoKHR(
        VkDeviceMemory memory_= { },
        F_ExternalMemoryHandleType handleType_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR,
        nullptr,
        memory_,
        handleType_
    } { }
    inL S_MemoryGetWin32HandleInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryGetWin32HandleInfoKHR*() { return this; }
    inL operator S_MemoryGetWin32HandleInfoKHR const* () const { return const_cast<S_MemoryGetWin32HandleInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkMemoryGetWin32HandleInfoKHR> { using T = S_MemoryGetWin32HandleInfoKHR; };

#endif
struct S_SampleLocationEXT : public VkSampleLocationEXT {
public:
    using Otype = VkSampleLocationEXT;
public:
    S_SampleLocationEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_SampleLocationEXT(
        float x_= { },
        float y_= { }
    ) : Otype{
        x_,
        y_
    } { }
    inL S_SampleLocationEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SampleLocationEXT*() { return this; }
    inL operator S_SampleLocationEXT const* () const { return const_cast<S_SampleLocationEXT const*>(this); }
};
template<> struct detail::names_map<VkSampleLocationEXT> { using T = S_SampleLocationEXT; };
struct S_SampleLocationsInfoEXT : public VkSampleLocationsInfoEXT {
public:
    using Otype = VkSampleLocationsInfoEXT;
public:
    S_SampleLocationsInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_SampleLocationsInfoEXT(
        F_SampleCount sampleLocationsPerPixel_= { },
        S_Extent2D sampleLocationGridSize_= { },
        Array_general<S_SampleLocationEXT> pSampleLocations_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
        nullptr,
        sampleLocationsPerPixel_,
        sampleLocationGridSize_,
        pSampleLocations_.size(),
        reinterpret_cast<VkSampleLocationEXT*>(pSampleLocations_.data())
    } { }
    inL S_SampleLocationsInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SampleLocationsInfoEXT*() { return this; }
    inL operator S_SampleLocationsInfoEXT const* () const { return const_cast<S_SampleLocationsInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkSampleLocationsInfoEXT> { using T = S_SampleLocationsInfoEXT; };
struct N_ImageMemoryBarrier{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_ImageMemoryBarrier& n_VkSampleLocationsInfoEXT(Aref<S_SampleLocationsInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_ImageMemoryBarrier : public VkImageMemoryBarrier {
public:
    using Otype = VkImageMemoryBarrier;
public:
    S_ImageMemoryBarrier(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageMemoryBarrier(
        VkAccessFlags srcAccessMask_= { },
        VkAccessFlags dstAccessMask_= { },
        E_ImageLayout oldLayout_= { },
        E_ImageLayout newLayout_= { },
        uint32_t srcQueueFamilyIndex_= { },
        uint32_t dstQueueFamilyIndex_= { },
        VkImage image_= { },
        S_ImageSubresourceRange subresourceRange_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
        nullptr,
        srcAccessMask_,
        dstAccessMask_,
        oldLayout_,
        newLayout_,
        srcQueueFamilyIndex_,
        dstQueueFamilyIndex_,
        image_,
        subresourceRange_
    } { }
    S_ImageMemoryBarrier& set_next(N_ImageMemoryBarrier& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_ImageMemoryBarrier& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageMemoryBarrier*() { return this; }
    inL operator S_ImageMemoryBarrier const* () const { return const_cast<S_ImageMemoryBarrier const*>(this); }
};
template<> struct detail::names_map<VkImageMemoryBarrier> { using T = S_ImageMemoryBarrier; };
struct S_PhysicalDeviceLimits : public VkPhysicalDeviceLimits {
public:
    using Otype = VkPhysicalDeviceLimits;
public:
    S_PhysicalDeviceLimits(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceLimits(
        uint32_t maxImageDimension1D_= { },
        uint32_t maxImageDimension2D_= { },
        uint32_t maxImageDimension3D_= { },
        uint32_t maxImageDimensionCube_= { },
        uint32_t maxImageArrayLayers_= { },
        uint32_t maxTexelBufferElements_= { },
        uint32_t maxUniformBufferRange_= { },
        uint32_t maxStorageBufferRange_= { },
        uint32_t maxPushConstantsSize_= { },
        uint32_t maxMemoryAllocationCount_= { },
        uint32_t maxSamplerAllocationCount_= { },
        VkDeviceSize bufferImageGranularity_= { },
        VkDeviceSize sparseAddressSpaceSize_= { },
        uint32_t maxBoundDescriptorSets_= { },
        uint32_t maxPerStageDescriptorSamplers_= { },
        uint32_t maxPerStageDescriptorUniformBuffers_= { },
        uint32_t maxPerStageDescriptorStorageBuffers_= { },
        uint32_t maxPerStageDescriptorSampledImages_= { },
        uint32_t maxPerStageDescriptorStorageImages_= { },
        uint32_t maxPerStageDescriptorInputAttachments_= { },
        uint32_t maxPerStageResources_= { },
        uint32_t maxDescriptorSetSamplers_= { },
        uint32_t maxDescriptorSetUniformBuffers_= { },
        uint32_t maxDescriptorSetUniformBuffersDynamic_= { },
        uint32_t maxDescriptorSetStorageBuffers_= { },
        uint32_t maxDescriptorSetStorageBuffersDynamic_= { },
        uint32_t maxDescriptorSetSampledImages_= { },
        uint32_t maxDescriptorSetStorageImages_= { },
        uint32_t maxDescriptorSetInputAttachments_= { },
        uint32_t maxVertexInputAttributes_= { },
        uint32_t maxVertexInputBindings_= { },
        uint32_t maxVertexInputAttributeOffset_= { },
        uint32_t maxVertexInputBindingStride_= { },
        uint32_t maxVertexOutputComponents_= { },
        uint32_t maxTessellationGenerationLevel_= { },
        uint32_t maxTessellationPatchSize_= { },
        uint32_t maxTessellationControlPerVertexInputComponents_= { },
        uint32_t maxTessellationControlPerVertexOutputComponents_= { },
        uint32_t maxTessellationControlPerPatchOutputComponents_= { },
        uint32_t maxTessellationControlTotalOutputComponents_= { },
        uint32_t maxTessellationEvaluationInputComponents_= { },
        uint32_t maxTessellationEvaluationOutputComponents_= { },
        uint32_t maxGeometryShaderInvocations_= { },
        uint32_t maxGeometryInputComponents_= { },
        uint32_t maxGeometryOutputComponents_= { },
        uint32_t maxGeometryOutputVertices_= { },
        uint32_t maxGeometryTotalOutputComponents_= { },
        uint32_t maxFragmentInputComponents_= { },
        uint32_t maxFragmentOutputAttachments_= { },
        uint32_t maxFragmentDualSrcAttachments_= { },
        uint32_t maxFragmentCombinedOutputResources_= { },
        uint32_t maxComputeSharedMemorySize_= { },
        std::array<uint32_t,3> maxComputeWorkGroupCount_= { },
        uint32_t maxComputeWorkGroupInvocations_= { },
        std::array<uint32_t,3> maxComputeWorkGroupSize_= { },
        uint32_t subPixelPrecisionBits_= { },
        uint32_t subTexelPrecisionBits_= { },
        uint32_t mipmapPrecisionBits_= { },
        uint32_t maxDrawIndexedIndexValue_= { },
        uint32_t maxDrawIndirectCount_= { },
        float maxSamplerLodBias_= { },
        float maxSamplerAnisotropy_= { },
        uint32_t maxViewports_= { },
        std::array<uint32_t,2> maxViewportDimensions_= { },
        std::array<float,2> viewportBoundsRange_= { },
        uint32_t viewportSubPixelBits_= { },
        size_t minMemoryMapAlignment_= { },
        VkDeviceSize minTexelBufferOffsetAlignment_= { },
        VkDeviceSize minUniformBufferOffsetAlignment_= { },
        VkDeviceSize minStorageBufferOffsetAlignment_= { },
        int32_t minTexelOffset_= { },
        uint32_t maxTexelOffset_= { },
        int32_t minTexelGatherOffset_= { },
        uint32_t maxTexelGatherOffset_= { },
        float minInterpolationOffset_= { },
        float maxInterpolationOffset_= { },
        uint32_t subPixelInterpolationOffsetBits_= { },
        uint32_t maxFramebufferWidth_= { },
        uint32_t maxFramebufferHeight_= { },
        uint32_t maxFramebufferLayers_= { },
        VkSampleCountFlags framebufferColorSampleCounts_= { },
        VkSampleCountFlags framebufferDepthSampleCounts_= { },
        VkSampleCountFlags framebufferStencilSampleCounts_= { },
        VkSampleCountFlags framebufferNoAttachmentsSampleCounts_= { },
        uint32_t maxColorAttachments_= { },
        VkSampleCountFlags sampledImageColorSampleCounts_= { },
        VkSampleCountFlags sampledImageIntegerSampleCounts_= { },
        VkSampleCountFlags sampledImageDepthSampleCounts_= { },
        VkSampleCountFlags sampledImageStencilSampleCounts_= { },
        VkSampleCountFlags storageImageSampleCounts_= { },
        uint32_t maxSampleMaskWords_= { },
        VkBool32 timestampComputeAndGraphics_= { },
        float timestampPeriod_= { },
        uint32_t maxClipDistances_= { },
        uint32_t maxCullDistances_= { },
        uint32_t maxCombinedClipAndCullDistances_= { },
        uint32_t discreteQueuePriorities_= { },
        std::array<float,2> pointSizeRange_= { },
        std::array<float,2> lineWidthRange_= { },
        float pointSizeGranularity_= { },
        float lineWidthGranularity_= { },
        VkBool32 strictLines_= { },
        VkBool32 standardSampleLocations_= { },
        VkDeviceSize optimalBufferCopyOffsetAlignment_= { },
        VkDeviceSize optimalBufferCopyRowPitchAlignment_= { },
        VkDeviceSize nonCoherentAtomSize_= { }
    ) : Otype{
        maxImageDimension1D_,
        maxImageDimension2D_,
        maxImageDimension3D_,
        maxImageDimensionCube_,
        maxImageArrayLayers_,
        maxTexelBufferElements_,
        maxUniformBufferRange_,
        maxStorageBufferRange_,
        maxPushConstantsSize_,
        maxMemoryAllocationCount_,
        maxSamplerAllocationCount_,
        bufferImageGranularity_,
        sparseAddressSpaceSize_,
        maxBoundDescriptorSets_,
        maxPerStageDescriptorSamplers_,
        maxPerStageDescriptorUniformBuffers_,
        maxPerStageDescriptorStorageBuffers_,
        maxPerStageDescriptorSampledImages_,
        maxPerStageDescriptorStorageImages_,
        maxPerStageDescriptorInputAttachments_,
        maxPerStageResources_,
        maxDescriptorSetSamplers_,
        maxDescriptorSetUniformBuffers_,
        maxDescriptorSetUniformBuffersDynamic_,
        maxDescriptorSetStorageBuffers_,
        maxDescriptorSetStorageBuffersDynamic_,
        maxDescriptorSetSampledImages_,
        maxDescriptorSetStorageImages_,
        maxDescriptorSetInputAttachments_,
        maxVertexInputAttributes_,
        maxVertexInputBindings_,
        maxVertexInputAttributeOffset_,
        maxVertexInputBindingStride_,
        maxVertexOutputComponents_,
        maxTessellationGenerationLevel_,
        maxTessellationPatchSize_,
        maxTessellationControlPerVertexInputComponents_,
        maxTessellationControlPerVertexOutputComponents_,
        maxTessellationControlPerPatchOutputComponents_,
        maxTessellationControlTotalOutputComponents_,
        maxTessellationEvaluationInputComponents_,
        maxTessellationEvaluationOutputComponents_,
        maxGeometryShaderInvocations_,
        maxGeometryInputComponents_,
        maxGeometryOutputComponents_,
        maxGeometryOutputVertices_,
        maxGeometryTotalOutputComponents_,
        maxFragmentInputComponents_,
        maxFragmentOutputAttachments_,
        maxFragmentDualSrcAttachments_,
        maxFragmentCombinedOutputResources_,
        maxComputeSharedMemorySize_,
        { },
        maxComputeWorkGroupInvocations_,
        { },
        subPixelPrecisionBits_,
        subTexelPrecisionBits_,
        mipmapPrecisionBits_,
        maxDrawIndexedIndexValue_,
        maxDrawIndirectCount_,
        maxSamplerLodBias_,
        maxSamplerAnisotropy_,
        maxViewports_,
        { },
        { },
        viewportSubPixelBits_,
        minMemoryMapAlignment_,
        minTexelBufferOffsetAlignment_,
        minUniformBufferOffsetAlignment_,
        minStorageBufferOffsetAlignment_,
        minTexelOffset_,
        maxTexelOffset_,
        minTexelGatherOffset_,
        maxTexelGatherOffset_,
        minInterpolationOffset_,
        maxInterpolationOffset_,
        subPixelInterpolationOffsetBits_,
        maxFramebufferWidth_,
        maxFramebufferHeight_,
        maxFramebufferLayers_,
        framebufferColorSampleCounts_,
        framebufferDepthSampleCounts_,
        framebufferStencilSampleCounts_,
        framebufferNoAttachmentsSampleCounts_,
        maxColorAttachments_,
        sampledImageColorSampleCounts_,
        sampledImageIntegerSampleCounts_,
        sampledImageDepthSampleCounts_,
        sampledImageStencilSampleCounts_,
        storageImageSampleCounts_,
        maxSampleMaskWords_,
        timestampComputeAndGraphics_,
        timestampPeriod_,
        maxClipDistances_,
        maxCullDistances_,
        maxCombinedClipAndCullDistances_,
        discreteQueuePriorities_,
        { },
        { },
        pointSizeGranularity_,
        lineWidthGranularity_,
        strictLines_,
        standardSampleLocations_,
        optimalBufferCopyOffsetAlignment_,
        optimalBufferCopyRowPitchAlignment_,
        nonCoherentAtomSize_
    } { 
        ::memcpy(&maxComputeWorkGroupCount[0], maxComputeWorkGroupCount_.data(), maxComputeWorkGroupCount_.size() );
        ::memcpy(&maxComputeWorkGroupSize[0], maxComputeWorkGroupSize_.data(), maxComputeWorkGroupSize_.size() );
        ::memcpy(&maxViewportDimensions[0], maxViewportDimensions_.data(), maxViewportDimensions_.size() );
        ::memcpy(&viewportBoundsRange[0], viewportBoundsRange_.data(), viewportBoundsRange_.size() );
        ::memcpy(&pointSizeRange[0], pointSizeRange_.data(), pointSizeRange_.size() );
        ::memcpy(&lineWidthRange[0], lineWidthRange_.data(), lineWidthRange_.size() );
    }
    inL S_PhysicalDeviceLimits& 
        set_maxComputeWorkGroupCount(std::array<uint32_t,3> maxComputeWorkGroupCount_)
        {  return *this; }
    inL S_PhysicalDeviceLimits& 
        set_maxComputeWorkGroupSize(std::array<uint32_t,3> maxComputeWorkGroupSize_)
        {  return *this; }
    inL S_PhysicalDeviceLimits& 
        set_maxViewportDimensions(std::array<uint32_t,2> maxViewportDimensions_)
        {  return *this; }
    inL S_PhysicalDeviceLimits& 
        set_viewportBoundsRange(std::array<float,2> viewportBoundsRange_)
        {  return *this; }
    inL S_PhysicalDeviceLimits& 
        set_pointSizeRange(std::array<float,2> pointSizeRange_)
        {  return *this; }
    inL S_PhysicalDeviceLimits& 
        set_lineWidthRange(std::array<float,2> lineWidthRange_)
        {  return *this; }
    inL S_PhysicalDeviceLimits& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceLimits*() { return this; }
    inL operator S_PhysicalDeviceLimits const* () const { return const_cast<S_PhysicalDeviceLimits const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceLimits> { using T = S_PhysicalDeviceLimits; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_ExportSemaphoreWin32HandleInfoKHR : public VkExportSemaphoreWin32HandleInfoKHR {
public:
    using Otype = VkExportSemaphoreWin32HandleInfoKHR;
public:
    S_ExportSemaphoreWin32HandleInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExportSemaphoreWin32HandleInfoKHR(
        Aptr<SECURITY_ATTRIBUTES> pAttributes_= { },
        DWORD dwAccess_= { },
        LPCWSTR name_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
        nullptr,
        pAttributes_,
        dwAccess_,
        name_
    } { }
    inL S_ExportSemaphoreWin32HandleInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExportSemaphoreWin32HandleInfoKHR*() { return this; }
    inL operator S_ExportSemaphoreWin32HandleInfoKHR const* () const { return const_cast<S_ExportSemaphoreWin32HandleInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkExportSemaphoreWin32HandleInfoKHR> { using T = S_ExportSemaphoreWin32HandleInfoKHR; };

#endif

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_ImportSemaphoreWin32HandleInfoKHR : public VkImportSemaphoreWin32HandleInfoKHR {
public:
    using Otype = VkImportSemaphoreWin32HandleInfoKHR;
public:
    S_ImportSemaphoreWin32HandleInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImportSemaphoreWin32HandleInfoKHR(
        VkSemaphore semaphore_= { },
        VkSemaphoreImportFlags flags_= { },
        F_ExternalSemaphoreHandleType handleType_= { },
        HANDLE handle_= { },
        LPCWSTR name_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR,
        nullptr,
        semaphore_,
        flags_,
        handleType_,
        handle_,
        name_
    } { }
    inL S_ImportSemaphoreWin32HandleInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImportSemaphoreWin32HandleInfoKHR*() { return this; }
    inL operator S_ImportSemaphoreWin32HandleInfoKHR const* () const { return const_cast<S_ImportSemaphoreWin32HandleInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkImportSemaphoreWin32HandleInfoKHR> { using T = S_ImportSemaphoreWin32HandleInfoKHR; };

#endif
struct S_MultisamplePropertiesEXT : public VkMultisamplePropertiesEXT {
public:
    using Otype = VkMultisamplePropertiesEXT;
public:
    S_MultisamplePropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_MultisamplePropertiesEXT(
        S_Extent2D maxSampleLocationGridSize_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT,
        nullptr,
        maxSampleLocationGridSize_
    } { }
    inL S_MultisamplePropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MultisamplePropertiesEXT*() { return this; }
    inL operator S_MultisamplePropertiesEXT const* () const { return const_cast<S_MultisamplePropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkMultisamplePropertiesEXT> { using T = S_MultisamplePropertiesEXT; };
struct S_PhysicalDeviceExternalImageFormatInfo : public VkPhysicalDeviceExternalImageFormatInfo {
public:
    using Otype = VkPhysicalDeviceExternalImageFormatInfo;
public:
    S_PhysicalDeviceExternalImageFormatInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceExternalImageFormatInfo(
        F_ExternalMemoryHandleType handleType_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
        nullptr,
        handleType_
    } { }
    inL S_PhysicalDeviceExternalImageFormatInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceExternalImageFormatInfo*() { return this; }
    inL operator S_PhysicalDeviceExternalImageFormatInfo const* () const { return const_cast<S_PhysicalDeviceExternalImageFormatInfo const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceExternalImageFormatInfo> { using T = S_PhysicalDeviceExternalImageFormatInfo; };
struct S_SparseMemoryBind : public VkSparseMemoryBind {
public:
    using Otype = VkSparseMemoryBind;
public:
    S_SparseMemoryBind(Otype& origin_obj_):Otype(origin_obj_){}
    S_SparseMemoryBind(
        VkDeviceSize resourceOffset_= { },
        VkDeviceSize size_= { },
        VkDeviceMemory memory_= { },
        VkDeviceSize memoryOffset_= { },
        VkSparseMemoryBindFlags flags_= { }
    ) : Otype{
        resourceOffset_,
        size_,
        memory_,
        memoryOffset_,
        flags_
    } { }
    inL S_SparseMemoryBind& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SparseMemoryBind*() { return this; }
    inL operator S_SparseMemoryBind const* () const { return const_cast<S_SparseMemoryBind const*>(this); }
};
template<> struct detail::names_map<VkSparseMemoryBind> { using T = S_SparseMemoryBind; };
struct S_PhysicalDeviceShadingRateImagePropertiesNV : public VkPhysicalDeviceShadingRateImagePropertiesNV {
public:
    using Otype = VkPhysicalDeviceShadingRateImagePropertiesNV;
public:
    S_PhysicalDeviceShadingRateImagePropertiesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceShadingRateImagePropertiesNV(
        S_Extent2D shadingRateTexelSize_= { },
        uint32_t shadingRatePaletteSize_= { },
        uint32_t shadingRateMaxCoarseSamples_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
        nullptr,
        shadingRateTexelSize_,
        shadingRatePaletteSize_,
        shadingRateMaxCoarseSamples_
    } { }
    inL S_PhysicalDeviceShadingRateImagePropertiesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceShadingRateImagePropertiesNV*() { return this; }
    inL operator S_PhysicalDeviceShadingRateImagePropertiesNV const* () const { return const_cast<S_PhysicalDeviceShadingRateImagePropertiesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceShadingRateImagePropertiesNV> { using T = S_PhysicalDeviceShadingRateImagePropertiesNV; };
struct S_PipelineRasterizationDepthClipStateCreateInfoEXT : public VkPipelineRasterizationDepthClipStateCreateInfoEXT {
public:
    using Otype = VkPipelineRasterizationDepthClipStateCreateInfoEXT;
public:
    S_PipelineRasterizationDepthClipStateCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineRasterizationDepthClipStateCreateInfoEXT(
        VkPipelineRasterizationDepthClipStateCreateFlagsEXT flags_= { },
        VkBool32 depthClipEnable_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
        nullptr,
        flags_,
        depthClipEnable_
    } { }
    inL S_PipelineRasterizationDepthClipStateCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineRasterizationDepthClipStateCreateInfoEXT*() { return this; }
    inL operator S_PipelineRasterizationDepthClipStateCreateInfoEXT const* () const { return const_cast<S_PipelineRasterizationDepthClipStateCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkPipelineRasterizationDepthClipStateCreateInfoEXT> { using T = S_PipelineRasterizationDepthClipStateCreateInfoEXT; };
struct S_DrawMeshTasksIndirectCommandNV : public VkDrawMeshTasksIndirectCommandNV {
public:
    using Otype = VkDrawMeshTasksIndirectCommandNV;
public:
    S_DrawMeshTasksIndirectCommandNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_DrawMeshTasksIndirectCommandNV(
        uint32_t taskCount_= { },
        uint32_t firstTask_= { }
    ) : Otype{
        taskCount_,
        firstTask_
    } { }
    inL S_DrawMeshTasksIndirectCommandNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DrawMeshTasksIndirectCommandNV*() { return this; }
    inL operator S_DrawMeshTasksIndirectCommandNV const* () const { return const_cast<S_DrawMeshTasksIndirectCommandNV const*>(this); }
};
template<> struct detail::names_map<VkDrawMeshTasksIndirectCommandNV> { using T = S_DrawMeshTasksIndirectCommandNV; };
struct S_AttachmentSampleLocationsEXT : public VkAttachmentSampleLocationsEXT {
public:
    using Otype = VkAttachmentSampleLocationsEXT;
public:
    S_AttachmentSampleLocationsEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_AttachmentSampleLocationsEXT(
        uint32_t attachmentIndex_= { },
        S_SampleLocationsInfoEXT sampleLocationsInfo_= { }
    ) : Otype{
        attachmentIndex_,
        sampleLocationsInfo_
    } { }
    inL S_AttachmentSampleLocationsEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AttachmentSampleLocationsEXT*() { return this; }
    inL operator S_AttachmentSampleLocationsEXT const* () const { return const_cast<S_AttachmentSampleLocationsEXT const*>(this); }
};
template<> struct detail::names_map<VkAttachmentSampleLocationsEXT> { using T = S_AttachmentSampleLocationsEXT; };
struct S_SamplerYcbcrConversionInfo : public VkSamplerYcbcrConversionInfo {
public:
    using Otype = VkSamplerYcbcrConversionInfo;
public:
    S_SamplerYcbcrConversionInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_SamplerYcbcrConversionInfo(
        VkSamplerYcbcrConversion conversion_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
        nullptr,
        conversion_
    } { }
    inL S_SamplerYcbcrConversionInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SamplerYcbcrConversionInfo*() { return this; }
    inL operator S_SamplerYcbcrConversionInfo const* () const { return const_cast<S_SamplerYcbcrConversionInfo const*>(this); }
};
template<> struct detail::names_map<VkSamplerYcbcrConversionInfo> { using T = S_SamplerYcbcrConversionInfo; };
struct S_DisplayModeParametersKHR : public VkDisplayModeParametersKHR {
public:
    using Otype = VkDisplayModeParametersKHR;
public:
    S_DisplayModeParametersKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayModeParametersKHR(
        S_Extent2D visibleRegion_= { },
        uint32_t refreshRate_= { }
    ) : Otype{
        visibleRegion_,
        refreshRate_
    } { }
    inL S_DisplayModeParametersKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayModeParametersKHR*() { return this; }
    inL operator S_DisplayModeParametersKHR const* () const { return const_cast<S_DisplayModeParametersKHR const*>(this); }
};
template<> struct detail::names_map<VkDisplayModeParametersKHR> { using T = S_DisplayModeParametersKHR; };
struct S_DisplayModeCreateInfoKHR : public VkDisplayModeCreateInfoKHR {
public:
    using Otype = VkDisplayModeCreateInfoKHR;
public:
    S_DisplayModeCreateInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayModeCreateInfoKHR(
        VkDisplayModeCreateFlagsKHR flags_= { },
        S_DisplayModeParametersKHR parameters_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR,
        nullptr,
        flags_,
        parameters_
    } { }
    inL S_DisplayModeCreateInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayModeCreateInfoKHR*() { return this; }
    inL operator S_DisplayModeCreateInfoKHR const* () const { return const_cast<S_DisplayModeCreateInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkDisplayModeCreateInfoKHR> { using T = S_DisplayModeCreateInfoKHR; };
struct S_DescriptorUpdateTemplateCreateInfo : public VkDescriptorUpdateTemplateCreateInfo {
public:
    using Otype = VkDescriptorUpdateTemplateCreateInfo;
public:
    S_DescriptorUpdateTemplateCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorUpdateTemplateCreateInfo(
        VkDescriptorUpdateTemplateCreateFlags flags_= { },
        Array_general<S_DescriptorUpdateTemplateEntry> pDescriptorUpdateEntries_= { },
        E_DescriptorUpdateTemplateType templateType_= { },
        VkDescriptorSetLayout descriptorSetLayout_= { },
        E_PipelineBindPoint pipelineBindPoint_= { },
        VkPipelineLayout pipelineLayout_= { },
        uint32_t set_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
        nullptr,
        flags_,
        pDescriptorUpdateEntries_.size(),
        reinterpret_cast<VkDescriptorUpdateTemplateEntry*>(pDescriptorUpdateEntries_.data()),
        templateType_,
        descriptorSetLayout_,
        pipelineBindPoint_,
        pipelineLayout_,
        set_
    } { }
    inL S_DescriptorUpdateTemplateCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorUpdateTemplateCreateInfo*() { return this; }
    inL operator S_DescriptorUpdateTemplateCreateInfo const* () const { return const_cast<S_DescriptorUpdateTemplateCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkDescriptorUpdateTemplateCreateInfo> { using T = S_DescriptorUpdateTemplateCreateInfo; };
struct S_MappedMemoryRange : public VkMappedMemoryRange {
public:
    using Otype = VkMappedMemoryRange;
public:
    S_MappedMemoryRange(Otype& origin_obj_):Otype(origin_obj_){}
    S_MappedMemoryRange(
        VkDeviceMemory memory_= { },
        VkDeviceSize offset_= { },
        VkDeviceSize size_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
        nullptr,
        memory_,
        offset_,
        size_
    } { }
    inL S_MappedMemoryRange& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MappedMemoryRange*() { return this; }
    inL operator S_MappedMemoryRange const* () const { return const_cast<S_MappedMemoryRange const*>(this); }
};
template<> struct detail::names_map<VkMappedMemoryRange> { using T = S_MappedMemoryRange; };
struct S_SubpassSampleLocationsEXT : public VkSubpassSampleLocationsEXT {
public:
    using Otype = VkSubpassSampleLocationsEXT;
public:
    S_SubpassSampleLocationsEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_SubpassSampleLocationsEXT(
        uint32_t subpassIndex_= { },
        S_SampleLocationsInfoEXT sampleLocationsInfo_= { }
    ) : Otype{
        subpassIndex_,
        sampleLocationsInfo_
    } { }
    inL S_SubpassSampleLocationsEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SubpassSampleLocationsEXT*() { return this; }
    inL operator S_SubpassSampleLocationsEXT const* () const { return const_cast<S_SubpassSampleLocationsEXT const*>(this); }
};
template<> struct detail::names_map<VkSubpassSampleLocationsEXT> { using T = S_SubpassSampleLocationsEXT; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_FenceGetWin32HandleInfoKHR : public VkFenceGetWin32HandleInfoKHR {
public:
    using Otype = VkFenceGetWin32HandleInfoKHR;
public:
    S_FenceGetWin32HandleInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_FenceGetWin32HandleInfoKHR(
        VkFence fence_= { },
        F_ExternalFenceHandleType handleType_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR,
        nullptr,
        fence_,
        handleType_
    } { }
    inL S_FenceGetWin32HandleInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_FenceGetWin32HandleInfoKHR*() { return this; }
    inL operator S_FenceGetWin32HandleInfoKHR const* () const { return const_cast<S_FenceGetWin32HandleInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkFenceGetWin32HandleInfoKHR> { using T = S_FenceGetWin32HandleInfoKHR; };

#endif
struct S_ObjectTablePipelineEntryNVX : public VkObjectTablePipelineEntryNVX {
public:
    using Otype = VkObjectTablePipelineEntryNVX;
public:
    S_ObjectTablePipelineEntryNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_ObjectTablePipelineEntryNVX(
        E_ObjectEntryTypeNVX type_= { },
        VkObjectEntryUsageFlagsNVX flags_= { },
        VkPipeline pipeline_= { }
    ) : Otype{
        type_,
        flags_,
        pipeline_
    } { }
    inL S_ObjectTablePipelineEntryNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ObjectTablePipelineEntryNVX*() { return this; }
    inL operator S_ObjectTablePipelineEntryNVX const* () const { return const_cast<S_ObjectTablePipelineEntryNVX const*>(this); }
};
template<> struct detail::names_map<VkObjectTablePipelineEntryNVX> { using T = S_ObjectTablePipelineEntryNVX; };
struct S_PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV : public VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
public:
    using Otype = VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV;
public:
    S_PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(
        VkBool32 dedicatedAllocationImageAliasing_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
        nullptr,
        dedicatedAllocationImageAliasing_
    } { }
    inL S_PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*() { return this; }
    inL operator S_PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const* () const { return const_cast<S_PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV> { using T = S_PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV; };
struct S_PhysicalDevice8BitStorageFeaturesKHR : public VkPhysicalDevice8BitStorageFeaturesKHR {
public:
    using Otype = VkPhysicalDevice8BitStorageFeaturesKHR;
public:
    S_PhysicalDevice8BitStorageFeaturesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDevice8BitStorageFeaturesKHR(
        VkBool32 storageBuffer8BitAccess_= { },
        VkBool32 uniformAndStorageBuffer8BitAccess_= { },
        VkBool32 storagePushConstant8_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR,
        nullptr,
        storageBuffer8BitAccess_,
        uniformAndStorageBuffer8BitAccess_,
        storagePushConstant8_
    } { }
    inL S_PhysicalDevice8BitStorageFeaturesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDevice8BitStorageFeaturesKHR*() { return this; }
    inL operator S_PhysicalDevice8BitStorageFeaturesKHR const* () const { return const_cast<S_PhysicalDevice8BitStorageFeaturesKHR const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDevice8BitStorageFeaturesKHR> { using T = S_PhysicalDevice8BitStorageFeaturesKHR; };
struct S_PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT : public VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT;
public:
    S_PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(
        VkBool32 shaderDemoteToHelperInvocation_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT,
        nullptr,
        shaderDemoteToHelperInvocation_
    } { }
    inL S_PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT> { using T = S_PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT; };
struct S_PhysicalDeviceHostQueryResetFeaturesEXT : public VkPhysicalDeviceHostQueryResetFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceHostQueryResetFeaturesEXT;
public:
    S_PhysicalDeviceHostQueryResetFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceHostQueryResetFeaturesEXT(
        VkBool32 hostQueryReset_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT,
        nullptr,
        hostQueryReset_
    } { }
    inL S_PhysicalDeviceHostQueryResetFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceHostQueryResetFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceHostQueryResetFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceHostQueryResetFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceHostQueryResetFeaturesEXT> { using T = S_PhysicalDeviceHostQueryResetFeaturesEXT; };
struct S_PhysicalDeviceMultiviewFeatures : public VkPhysicalDeviceMultiviewFeatures {
public:
    using Otype = VkPhysicalDeviceMultiviewFeatures;
public:
    S_PhysicalDeviceMultiviewFeatures(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceMultiviewFeatures(
        VkBool32 multiview_= { },
        VkBool32 multiviewGeometryShader_= { },
        VkBool32 multiviewTessellationShader_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
        nullptr,
        multiview_,
        multiviewGeometryShader_,
        multiviewTessellationShader_
    } { }
    inL S_PhysicalDeviceMultiviewFeatures& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceMultiviewFeatures*() { return this; }
    inL operator S_PhysicalDeviceMultiviewFeatures const* () const { return const_cast<S_PhysicalDeviceMultiviewFeatures const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceMultiviewFeatures> { using T = S_PhysicalDeviceMultiviewFeatures; };
struct S_PhysicalDeviceProtectedMemoryFeatures : public VkPhysicalDeviceProtectedMemoryFeatures {
public:
    using Otype = VkPhysicalDeviceProtectedMemoryFeatures;
public:
    S_PhysicalDeviceProtectedMemoryFeatures(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceProtectedMemoryFeatures(
        VkBool32 protectedMemory_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
        nullptr,
        protectedMemory_
    } { }
    inL S_PhysicalDeviceProtectedMemoryFeatures& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceProtectedMemoryFeatures*() { return this; }
    inL operator S_PhysicalDeviceProtectedMemoryFeatures const* () const { return const_cast<S_PhysicalDeviceProtectedMemoryFeatures const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceProtectedMemoryFeatures> { using T = S_PhysicalDeviceProtectedMemoryFeatures; };
struct S_PhysicalDevice16BitStorageFeatures : public VkPhysicalDevice16BitStorageFeatures {
public:
    using Otype = VkPhysicalDevice16BitStorageFeatures;
public:
    S_PhysicalDevice16BitStorageFeatures(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDevice16BitStorageFeatures(
        VkBool32 storageBuffer16BitAccess_= { },
        VkBool32 uniformAndStorageBuffer16BitAccess_= { },
        VkBool32 storagePushConstant16_= { },
        VkBool32 storageInputOutput16_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
        nullptr,
        storageBuffer16BitAccess_,
        uniformAndStorageBuffer16BitAccess_,
        storagePushConstant16_,
        storageInputOutput16_
    } { }
    inL S_PhysicalDevice16BitStorageFeatures& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDevice16BitStorageFeatures*() { return this; }
    inL operator S_PhysicalDevice16BitStorageFeatures const* () const { return const_cast<S_PhysicalDevice16BitStorageFeatures const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDevice16BitStorageFeatures> { using T = S_PhysicalDevice16BitStorageFeatures; };
struct S_PhysicalDeviceImagelessFramebufferFeaturesKHR : public VkPhysicalDeviceImagelessFramebufferFeaturesKHR {
public:
    using Otype = VkPhysicalDeviceImagelessFramebufferFeaturesKHR;
public:
    S_PhysicalDeviceImagelessFramebufferFeaturesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceImagelessFramebufferFeaturesKHR(
        VkBool32 imagelessFramebuffer_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR,
        nullptr,
        imagelessFramebuffer_
    } { }
    inL S_PhysicalDeviceImagelessFramebufferFeaturesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceImagelessFramebufferFeaturesKHR*() { return this; }
    inL operator S_PhysicalDeviceImagelessFramebufferFeaturesKHR const* () const { return const_cast<S_PhysicalDeviceImagelessFramebufferFeaturesKHR const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceImagelessFramebufferFeaturesKHR> { using T = S_PhysicalDeviceImagelessFramebufferFeaturesKHR; };
struct S_PhysicalDeviceExclusiveScissorFeaturesNV : public VkPhysicalDeviceExclusiveScissorFeaturesNV {
public:
    using Otype = VkPhysicalDeviceExclusiveScissorFeaturesNV;
public:
    S_PhysicalDeviceExclusiveScissorFeaturesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceExclusiveScissorFeaturesNV(
        VkBool32 exclusiveScissor_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
        nullptr,
        exclusiveScissor_
    } { }
    inL S_PhysicalDeviceExclusiveScissorFeaturesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceExclusiveScissorFeaturesNV*() { return this; }
    inL operator S_PhysicalDeviceExclusiveScissorFeaturesNV const* () const { return const_cast<S_PhysicalDeviceExclusiveScissorFeaturesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceExclusiveScissorFeaturesNV> { using T = S_PhysicalDeviceExclusiveScissorFeaturesNV; };
struct S_PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR : public VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR {
public:
    using Otype = VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR;
public:
    S_PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR(
        VkBool32 uniformBufferStandardLayout_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR,
        nullptr,
        uniformBufferStandardLayout_
    } { }
    inL S_PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR*() { return this; }
    inL operator S_PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR const* () const { return const_cast<S_PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR> { using T = S_PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR; };
struct S_PhysicalDeviceYcbcrImageArraysFeaturesEXT : public VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceYcbcrImageArraysFeaturesEXT;
public:
    S_PhysicalDeviceYcbcrImageArraysFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceYcbcrImageArraysFeaturesEXT(
        VkBool32 ycbcrImageArrays_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
        nullptr,
        ycbcrImageArrays_
    } { }
    inL S_PhysicalDeviceYcbcrImageArraysFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceYcbcrImageArraysFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceYcbcrImageArraysFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceYcbcrImageArraysFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT> { using T = S_PhysicalDeviceYcbcrImageArraysFeaturesEXT; };
struct S_PhysicalDeviceIndexTypeUint8FeaturesEXT : public VkPhysicalDeviceIndexTypeUint8FeaturesEXT {
public:
    using Otype = VkPhysicalDeviceIndexTypeUint8FeaturesEXT;
public:
    S_PhysicalDeviceIndexTypeUint8FeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceIndexTypeUint8FeaturesEXT(
        VkBool32 indexTypeUint8_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT,
        nullptr,
        indexTypeUint8_
    } { }
    inL S_PhysicalDeviceIndexTypeUint8FeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceIndexTypeUint8FeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceIndexTypeUint8FeaturesEXT const* () const { return const_cast<S_PhysicalDeviceIndexTypeUint8FeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceIndexTypeUint8FeaturesEXT> { using T = S_PhysicalDeviceIndexTypeUint8FeaturesEXT; };
struct S_PhysicalDeviceDepthClipEnableFeaturesEXT : public VkPhysicalDeviceDepthClipEnableFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceDepthClipEnableFeaturesEXT;
public:
    S_PhysicalDeviceDepthClipEnableFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceDepthClipEnableFeaturesEXT(
        VkBool32 depthClipEnable_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
        nullptr,
        depthClipEnable_
    } { }
    inL S_PhysicalDeviceDepthClipEnableFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceDepthClipEnableFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceDepthClipEnableFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceDepthClipEnableFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceDepthClipEnableFeaturesEXT> { using T = S_PhysicalDeviceDepthClipEnableFeaturesEXT; };
struct S_PhysicalDeviceTexelBufferAlignmentFeaturesEXT : public VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT;
public:
    S_PhysicalDeviceTexelBufferAlignmentFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceTexelBufferAlignmentFeaturesEXT(
        VkBool32 texelBufferAlignment_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
        nullptr,
        texelBufferAlignment_
    } { }
    inL S_PhysicalDeviceTexelBufferAlignmentFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceTexelBufferAlignmentFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceTexelBufferAlignmentFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceTexelBufferAlignmentFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT> { using T = S_PhysicalDeviceTexelBufferAlignmentFeaturesEXT; };
struct S_PhysicalDeviceDescriptorIndexingFeaturesEXT : public VkPhysicalDeviceDescriptorIndexingFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceDescriptorIndexingFeaturesEXT;
public:
    S_PhysicalDeviceDescriptorIndexingFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceDescriptorIndexingFeaturesEXT(
        VkBool32 shaderInputAttachmentArrayDynamicIndexing_= { },
        VkBool32 shaderUniformTexelBufferArrayDynamicIndexing_= { },
        VkBool32 shaderStorageTexelBufferArrayDynamicIndexing_= { },
        VkBool32 shaderUniformBufferArrayNonUniformIndexing_= { },
        VkBool32 shaderSampledImageArrayNonUniformIndexing_= { },
        VkBool32 shaderStorageBufferArrayNonUniformIndexing_= { },
        VkBool32 shaderStorageImageArrayNonUniformIndexing_= { },
        VkBool32 shaderInputAttachmentArrayNonUniformIndexing_= { },
        VkBool32 shaderUniformTexelBufferArrayNonUniformIndexing_= { },
        VkBool32 shaderStorageTexelBufferArrayNonUniformIndexing_= { },
        VkBool32 descriptorBindingUniformBufferUpdateAfterBind_= { },
        VkBool32 descriptorBindingSampledImageUpdateAfterBind_= { },
        VkBool32 descriptorBindingStorageImageUpdateAfterBind_= { },
        VkBool32 descriptorBindingStorageBufferUpdateAfterBind_= { },
        VkBool32 descriptorBindingUniformTexelBufferUpdateAfterBind_= { },
        VkBool32 descriptorBindingStorageTexelBufferUpdateAfterBind_= { },
        VkBool32 descriptorBindingUpdateUnusedWhilePending_= { },
        VkBool32 descriptorBindingPartiallyBound_= { },
        VkBool32 descriptorBindingVariableDescriptorCount_= { },
        VkBool32 runtimeDescriptorArray_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT,
        nullptr,
        shaderInputAttachmentArrayDynamicIndexing_,
        shaderUniformTexelBufferArrayDynamicIndexing_,
        shaderStorageTexelBufferArrayDynamicIndexing_,
        shaderUniformBufferArrayNonUniformIndexing_,
        shaderSampledImageArrayNonUniformIndexing_,
        shaderStorageBufferArrayNonUniformIndexing_,
        shaderStorageImageArrayNonUniformIndexing_,
        shaderInputAttachmentArrayNonUniformIndexing_,
        shaderUniformTexelBufferArrayNonUniformIndexing_,
        shaderStorageTexelBufferArrayNonUniformIndexing_,
        descriptorBindingUniformBufferUpdateAfterBind_,
        descriptorBindingSampledImageUpdateAfterBind_,
        descriptorBindingStorageImageUpdateAfterBind_,
        descriptorBindingStorageBufferUpdateAfterBind_,
        descriptorBindingUniformTexelBufferUpdateAfterBind_,
        descriptorBindingStorageTexelBufferUpdateAfterBind_,
        descriptorBindingUpdateUnusedWhilePending_,
        descriptorBindingPartiallyBound_,
        descriptorBindingVariableDescriptorCount_,
        runtimeDescriptorArray_
    } { }
    inL S_PhysicalDeviceDescriptorIndexingFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceDescriptorIndexingFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceDescriptorIndexingFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceDescriptorIndexingFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceDescriptorIndexingFeaturesEXT> { using T = S_PhysicalDeviceDescriptorIndexingFeaturesEXT; };
struct S_PhysicalDeviceScalarBlockLayoutFeaturesEXT : public VkPhysicalDeviceScalarBlockLayoutFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceScalarBlockLayoutFeaturesEXT;
public:
    S_PhysicalDeviceScalarBlockLayoutFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceScalarBlockLayoutFeaturesEXT(
        VkBool32 scalarBlockLayout_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT,
        nullptr,
        scalarBlockLayout_
    } { }
    inL S_PhysicalDeviceScalarBlockLayoutFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceScalarBlockLayoutFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceScalarBlockLayoutFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceScalarBlockLayoutFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceScalarBlockLayoutFeaturesEXT> { using T = S_PhysicalDeviceScalarBlockLayoutFeaturesEXT; };
struct S_PhysicalDeviceShaderDrawParametersFeatures : public VkPhysicalDeviceShaderDrawParametersFeatures {
public:
    using Otype = VkPhysicalDeviceShaderDrawParametersFeatures;
public:
    S_PhysicalDeviceShaderDrawParametersFeatures(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceShaderDrawParametersFeatures(
        VkBool32 shaderDrawParameters_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
        nullptr,
        shaderDrawParameters_
    } { }
    inL S_PhysicalDeviceShaderDrawParametersFeatures& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceShaderDrawParametersFeatures*() { return this; }
    inL operator S_PhysicalDeviceShaderDrawParametersFeatures const* () const { return const_cast<S_PhysicalDeviceShaderDrawParametersFeatures const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceShaderDrawParametersFeatures> { using T = S_PhysicalDeviceShaderDrawParametersFeatures; };
struct S_PhysicalDeviceVariablePointersFeatures : public VkPhysicalDeviceVariablePointersFeatures {
public:
    using Otype = VkPhysicalDeviceVariablePointersFeatures;
public:
    S_PhysicalDeviceVariablePointersFeatures(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceVariablePointersFeatures(
        VkBool32 variablePointersStorageBuffer_= { },
        VkBool32 variablePointers_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
        nullptr,
        variablePointersStorageBuffer_,
        variablePointers_
    } { }
    inL S_PhysicalDeviceVariablePointersFeatures& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceVariablePointersFeatures*() { return this; }
    inL operator S_PhysicalDeviceVariablePointersFeatures const* () const { return const_cast<S_PhysicalDeviceVariablePointersFeatures const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceVariablePointersFeatures> { using T = S_PhysicalDeviceVariablePointersFeatures; };
struct S_PhysicalDeviceShaderSMBuiltinsFeaturesNV : public VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
public:
    using Otype = VkPhysicalDeviceShaderSMBuiltinsFeaturesNV;
public:
    S_PhysicalDeviceShaderSMBuiltinsFeaturesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceShaderSMBuiltinsFeaturesNV(
        VkBool32 shaderSMBuiltins_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV,
        nullptr,
        shaderSMBuiltins_
    } { }
    inL S_PhysicalDeviceShaderSMBuiltinsFeaturesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceShaderSMBuiltinsFeaturesNV*() { return this; }
    inL operator S_PhysicalDeviceShaderSMBuiltinsFeaturesNV const* () const { return const_cast<S_PhysicalDeviceShaderSMBuiltinsFeaturesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV> { using T = S_PhysicalDeviceShaderSMBuiltinsFeaturesNV; };
struct S_PhysicalDeviceConditionalRenderingFeaturesEXT : public VkPhysicalDeviceConditionalRenderingFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceConditionalRenderingFeaturesEXT;
public:
    S_PhysicalDeviceConditionalRenderingFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceConditionalRenderingFeaturesEXT(
        VkBool32 conditionalRendering_= { },
        VkBool32 inheritedConditionalRendering_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
        nullptr,
        conditionalRendering_,
        inheritedConditionalRendering_
    } { }
    inL S_PhysicalDeviceConditionalRenderingFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceConditionalRenderingFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceConditionalRenderingFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceConditionalRenderingFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceConditionalRenderingFeaturesEXT> { using T = S_PhysicalDeviceConditionalRenderingFeaturesEXT; };
struct S_PhysicalDeviceShaderImageFootprintFeaturesNV : public VkPhysicalDeviceShaderImageFootprintFeaturesNV {
public:
    using Otype = VkPhysicalDeviceShaderImageFootprintFeaturesNV;
public:
    S_PhysicalDeviceShaderImageFootprintFeaturesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceShaderImageFootprintFeaturesNV(
        VkBool32 imageFootprint_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
        nullptr,
        imageFootprint_
    } { }
    inL S_PhysicalDeviceShaderImageFootprintFeaturesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceShaderImageFootprintFeaturesNV*() { return this; }
    inL operator S_PhysicalDeviceShaderImageFootprintFeaturesNV const* () const { return const_cast<S_PhysicalDeviceShaderImageFootprintFeaturesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceShaderImageFootprintFeaturesNV> { using T = S_PhysicalDeviceShaderImageFootprintFeaturesNV; };
struct S_PhysicalDeviceShaderFloat16Int8FeaturesKHR : public VkPhysicalDeviceShaderFloat16Int8FeaturesKHR {
public:
    using Otype = VkPhysicalDeviceShaderFloat16Int8FeaturesKHR;
public:
    S_PhysicalDeviceShaderFloat16Int8FeaturesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceShaderFloat16Int8FeaturesKHR(
        VkBool32 shaderFloat16_= { },
        VkBool32 shaderInt8_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR,
        nullptr,
        shaderFloat16_,
        shaderInt8_
    } { }
    inL S_PhysicalDeviceShaderFloat16Int8FeaturesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceShaderFloat16Int8FeaturesKHR*() { return this; }
    inL operator S_PhysicalDeviceShaderFloat16Int8FeaturesKHR const* () const { return const_cast<S_PhysicalDeviceShaderFloat16Int8FeaturesKHR const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceShaderFloat16Int8FeaturesKHR> { using T = S_PhysicalDeviceShaderFloat16Int8FeaturesKHR; };
struct S_PhysicalDeviceInlineUniformBlockFeaturesEXT : public VkPhysicalDeviceInlineUniformBlockFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceInlineUniformBlockFeaturesEXT;
public:
    S_PhysicalDeviceInlineUniformBlockFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceInlineUniformBlockFeaturesEXT(
        VkBool32 inlineUniformBlock_= { },
        VkBool32 descriptorBindingInlineUniformBlockUpdateAfterBind_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT,
        nullptr,
        inlineUniformBlock_,
        descriptorBindingInlineUniformBlockUpdateAfterBind_
    } { }
    inL S_PhysicalDeviceInlineUniformBlockFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceInlineUniformBlockFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceInlineUniformBlockFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceInlineUniformBlockFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceInlineUniformBlockFeaturesEXT> { using T = S_PhysicalDeviceInlineUniformBlockFeaturesEXT; };
struct S_PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT : public VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT;
public:
    S_PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(
        VkBool32 textureCompressionASTC_HDR_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT,
        nullptr,
        textureCompressionASTC_HDR_
    } { }
    inL S_PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT> { using T = S_PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT; };
struct S_PhysicalDeviceASTCDecodeFeaturesEXT : public VkPhysicalDeviceASTCDecodeFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceASTCDecodeFeaturesEXT;
public:
    S_PhysicalDeviceASTCDecodeFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceASTCDecodeFeaturesEXT(
        VkBool32 decodeModeSharedExponent_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT,
        nullptr,
        decodeModeSharedExponent_
    } { }
    inL S_PhysicalDeviceASTCDecodeFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceASTCDecodeFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceASTCDecodeFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceASTCDecodeFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceASTCDecodeFeaturesEXT> { using T = S_PhysicalDeviceASTCDecodeFeaturesEXT; };
struct S_PhysicalDeviceBufferDeviceAddressFeaturesEXT : public VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
public:
    S_PhysicalDeviceBufferDeviceAddressFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceBufferDeviceAddressFeaturesEXT(
        VkBool32 bufferDeviceAddress_= { },
        VkBool32 bufferDeviceAddressCaptureReplay_= { },
        VkBool32 bufferDeviceAddressMultiDevice_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
        nullptr,
        bufferDeviceAddress_,
        bufferDeviceAddressCaptureReplay_,
        bufferDeviceAddressMultiDevice_
    } { }
    inL S_PhysicalDeviceBufferDeviceAddressFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceBufferDeviceAddressFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceBufferDeviceAddressFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceBufferDeviceAddressFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT> { using T = S_PhysicalDeviceBufferDeviceAddressFeaturesEXT; };
struct S_PhysicalDeviceLineRasterizationFeaturesEXT : public VkPhysicalDeviceLineRasterizationFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceLineRasterizationFeaturesEXT;
public:
    S_PhysicalDeviceLineRasterizationFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceLineRasterizationFeaturesEXT(
        VkBool32 rectangularLines_= { },
        VkBool32 bresenhamLines_= { },
        VkBool32 smoothLines_= { },
        VkBool32 stippledRectangularLines_= { },
        VkBool32 stippledBresenhamLines_= { },
        VkBool32 stippledSmoothLines_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT,
        nullptr,
        rectangularLines_,
        bresenhamLines_,
        smoothLines_,
        stippledRectangularLines_,
        stippledBresenhamLines_,
        stippledSmoothLines_
    } { }
    inL S_PhysicalDeviceLineRasterizationFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceLineRasterizationFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceLineRasterizationFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceLineRasterizationFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceLineRasterizationFeaturesEXT> { using T = S_PhysicalDeviceLineRasterizationFeaturesEXT; };
struct S_PhysicalDevicePipelineExecutablePropertiesFeaturesKHR : public VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
public:
    using Otype = VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR;
public:
    S_PhysicalDevicePipelineExecutablePropertiesFeaturesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDevicePipelineExecutablePropertiesFeaturesKHR(
        VkBool32 pipelineExecutableInfo_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
        nullptr,
        pipelineExecutableInfo_
    } { }
    inL S_PhysicalDevicePipelineExecutablePropertiesFeaturesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDevicePipelineExecutablePropertiesFeaturesKHR*() { return this; }
    inL operator S_PhysicalDevicePipelineExecutablePropertiesFeaturesKHR const* () const { return const_cast<S_PhysicalDevicePipelineExecutablePropertiesFeaturesKHR const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR> { using T = S_PhysicalDevicePipelineExecutablePropertiesFeaturesKHR; };
struct S_PhysicalDeviceSamplerYcbcrConversionFeatures : public VkPhysicalDeviceSamplerYcbcrConversionFeatures {
public:
    using Otype = VkPhysicalDeviceSamplerYcbcrConversionFeatures;
public:
    S_PhysicalDeviceSamplerYcbcrConversionFeatures(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceSamplerYcbcrConversionFeatures(
        VkBool32 samplerYcbcrConversion_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
        nullptr,
        samplerYcbcrConversion_
    } { }
    inL S_PhysicalDeviceSamplerYcbcrConversionFeatures& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceSamplerYcbcrConversionFeatures*() { return this; }
    inL operator S_PhysicalDeviceSamplerYcbcrConversionFeatures const* () const { return const_cast<S_PhysicalDeviceSamplerYcbcrConversionFeatures const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceSamplerYcbcrConversionFeatures> { using T = S_PhysicalDeviceSamplerYcbcrConversionFeatures; };
struct S_PhysicalDeviceFragmentShaderBarycentricFeaturesNV : public VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV {
public:
    using Otype = VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV;
public:
    S_PhysicalDeviceFragmentShaderBarycentricFeaturesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceFragmentShaderBarycentricFeaturesNV(
        VkBool32 fragmentShaderBarycentric_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV,
        nullptr,
        fragmentShaderBarycentric_
    } { }
    inL S_PhysicalDeviceFragmentShaderBarycentricFeaturesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceFragmentShaderBarycentricFeaturesNV*() { return this; }
    inL operator S_PhysicalDeviceFragmentShaderBarycentricFeaturesNV const* () const { return const_cast<S_PhysicalDeviceFragmentShaderBarycentricFeaturesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV> { using T = S_PhysicalDeviceFragmentShaderBarycentricFeaturesNV; };
struct S_PhysicalDeviceCoverageReductionModeFeaturesNV : public VkPhysicalDeviceCoverageReductionModeFeaturesNV {
public:
    using Otype = VkPhysicalDeviceCoverageReductionModeFeaturesNV;
public:
    S_PhysicalDeviceCoverageReductionModeFeaturesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceCoverageReductionModeFeaturesNV(
        VkBool32 coverageReductionMode_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV,
        nullptr,
        coverageReductionMode_
    } { }
    inL S_PhysicalDeviceCoverageReductionModeFeaturesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceCoverageReductionModeFeaturesNV*() { return this; }
    inL operator S_PhysicalDeviceCoverageReductionModeFeaturesNV const* () const { return const_cast<S_PhysicalDeviceCoverageReductionModeFeaturesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceCoverageReductionModeFeaturesNV> { using T = S_PhysicalDeviceCoverageReductionModeFeaturesNV; };
struct S_PhysicalDeviceComputeShaderDerivativesFeaturesNV : public VkPhysicalDeviceComputeShaderDerivativesFeaturesNV {
public:
    using Otype = VkPhysicalDeviceComputeShaderDerivativesFeaturesNV;
public:
    S_PhysicalDeviceComputeShaderDerivativesFeaturesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceComputeShaderDerivativesFeaturesNV(
        VkBool32 computeDerivativeGroupQuads_= { },
        VkBool32 computeDerivativeGroupLinear_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV,
        nullptr,
        computeDerivativeGroupQuads_,
        computeDerivativeGroupLinear_
    } { }
    inL S_PhysicalDeviceComputeShaderDerivativesFeaturesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceComputeShaderDerivativesFeaturesNV*() { return this; }
    inL operator S_PhysicalDeviceComputeShaderDerivativesFeaturesNV const* () const { return const_cast<S_PhysicalDeviceComputeShaderDerivativesFeaturesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV> { using T = S_PhysicalDeviceComputeShaderDerivativesFeaturesNV; };
struct S_PhysicalDeviceTransformFeedbackFeaturesEXT : public VkPhysicalDeviceTransformFeedbackFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceTransformFeedbackFeaturesEXT;
public:
    S_PhysicalDeviceTransformFeedbackFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceTransformFeedbackFeaturesEXT(
        VkBool32 transformFeedback_= { },
        VkBool32 geometryStreams_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
        nullptr,
        transformFeedback_,
        geometryStreams_
    } { }
    inL S_PhysicalDeviceTransformFeedbackFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceTransformFeedbackFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceTransformFeedbackFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceTransformFeedbackFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceTransformFeedbackFeaturesEXT> { using T = S_PhysicalDeviceTransformFeedbackFeaturesEXT; };
struct S_PhysicalDeviceVulkanMemoryModelFeaturesKHR : public VkPhysicalDeviceVulkanMemoryModelFeaturesKHR {
public:
    using Otype = VkPhysicalDeviceVulkanMemoryModelFeaturesKHR;
public:
    S_PhysicalDeviceVulkanMemoryModelFeaturesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceVulkanMemoryModelFeaturesKHR(
        VkBool32 vulkanMemoryModel_= { },
        VkBool32 vulkanMemoryModelDeviceScope_= { },
        VkBool32 vulkanMemoryModelAvailabilityVisibilityChains_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR,
        nullptr,
        vulkanMemoryModel_,
        vulkanMemoryModelDeviceScope_,
        vulkanMemoryModelAvailabilityVisibilityChains_
    } { }
    inL S_PhysicalDeviceVulkanMemoryModelFeaturesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceVulkanMemoryModelFeaturesKHR*() { return this; }
    inL operator S_PhysicalDeviceVulkanMemoryModelFeaturesKHR const* () const { return const_cast<S_PhysicalDeviceVulkanMemoryModelFeaturesKHR const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceVulkanMemoryModelFeaturesKHR> { using T = S_PhysicalDeviceVulkanMemoryModelFeaturesKHR; };
struct S_PhysicalDeviceCoherentMemoryFeaturesAMD : public VkPhysicalDeviceCoherentMemoryFeaturesAMD {
public:
    using Otype = VkPhysicalDeviceCoherentMemoryFeaturesAMD;
public:
    S_PhysicalDeviceCoherentMemoryFeaturesAMD(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceCoherentMemoryFeaturesAMD(
        VkBool32 deviceCoherentMemory_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD,
        nullptr,
        deviceCoherentMemory_
    } { }
    inL S_PhysicalDeviceCoherentMemoryFeaturesAMD& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceCoherentMemoryFeaturesAMD*() { return this; }
    inL operator S_PhysicalDeviceCoherentMemoryFeaturesAMD const* () const { return const_cast<S_PhysicalDeviceCoherentMemoryFeaturesAMD const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceCoherentMemoryFeaturesAMD> { using T = S_PhysicalDeviceCoherentMemoryFeaturesAMD; };
struct S_PhysicalDeviceFragmentDensityMapFeaturesEXT : public VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceFragmentDensityMapFeaturesEXT;
public:
    S_PhysicalDeviceFragmentDensityMapFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceFragmentDensityMapFeaturesEXT(
        VkBool32 fragmentDensityMap_= { },
        VkBool32 fragmentDensityMapDynamic_= { },
        VkBool32 fragmentDensityMapNonSubsampledImages_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
        nullptr,
        fragmentDensityMap_,
        fragmentDensityMapDynamic_,
        fragmentDensityMapNonSubsampledImages_
    } { }
    inL S_PhysicalDeviceFragmentDensityMapFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceFragmentDensityMapFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceFragmentDensityMapFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceFragmentDensityMapFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceFragmentDensityMapFeaturesEXT> { using T = S_PhysicalDeviceFragmentDensityMapFeaturesEXT; };
struct S_PhysicalDeviceVertexAttributeDivisorFeaturesEXT : public VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT;
public:
    S_PhysicalDeviceVertexAttributeDivisorFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceVertexAttributeDivisorFeaturesEXT(
        VkBool32 vertexAttributeInstanceRateDivisor_= { },
        VkBool32 vertexAttributeInstanceRateZeroDivisor_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT,
        nullptr,
        vertexAttributeInstanceRateDivisor_,
        vertexAttributeInstanceRateZeroDivisor_
    } { }
    inL S_PhysicalDeviceVertexAttributeDivisorFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceVertexAttributeDivisorFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceVertexAttributeDivisorFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceVertexAttributeDivisorFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT> { using T = S_PhysicalDeviceVertexAttributeDivisorFeaturesEXT; };
struct S_PhysicalDeviceFragmentShaderInterlockFeaturesEXT : public VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT;
public:
    S_PhysicalDeviceFragmentShaderInterlockFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceFragmentShaderInterlockFeaturesEXT(
        VkBool32 fragmentShaderSampleInterlock_= { },
        VkBool32 fragmentShaderPixelInterlock_= { },
        VkBool32 fragmentShaderShadingRateInterlock_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
        nullptr,
        fragmentShaderSampleInterlock_,
        fragmentShaderPixelInterlock_,
        fragmentShaderShadingRateInterlock_
    } { }
    inL S_PhysicalDeviceFragmentShaderInterlockFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceFragmentShaderInterlockFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceFragmentShaderInterlockFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceFragmentShaderInterlockFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT> { using T = S_PhysicalDeviceFragmentShaderInterlockFeaturesEXT; };
struct S_PhysicalDeviceMemoryPriorityFeaturesEXT : public VkPhysicalDeviceMemoryPriorityFeaturesEXT {
public:
    using Otype = VkPhysicalDeviceMemoryPriorityFeaturesEXT;
public:
    S_PhysicalDeviceMemoryPriorityFeaturesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceMemoryPriorityFeaturesEXT(
        VkBool32 memoryPriority_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
        nullptr,
        memoryPriority_
    } { }
    inL S_PhysicalDeviceMemoryPriorityFeaturesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceMemoryPriorityFeaturesEXT*() { return this; }
    inL operator S_PhysicalDeviceMemoryPriorityFeaturesEXT const* () const { return const_cast<S_PhysicalDeviceMemoryPriorityFeaturesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceMemoryPriorityFeaturesEXT> { using T = S_PhysicalDeviceMemoryPriorityFeaturesEXT; };
struct N_PhysicalDeviceFeatures2{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceCooperativeMatrixFeaturesNV(Aref<S_PhysicalDeviceCooperativeMatrixFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(Aref<S_PhysicalDeviceBlendOperationAdvancedFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(Aref<S_PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(Aref<S_PhysicalDeviceRepresentativeFragmentTestFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(Aref<S_PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDevice8BitStorageFeaturesKHR(Aref<S_PhysicalDevice8BitStorageFeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR(Aref<S_PhysicalDeviceShaderAtomicInt64FeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(Aref<S_PhysicalDeviceSubgroupSizeControlFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(Aref<S_PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceShadingRateImageFeaturesNV(Aref<S_PhysicalDeviceShadingRateImageFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceHostQueryResetFeaturesEXT(Aref<S_PhysicalDeviceHostQueryResetFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceMeshShaderFeaturesNV(Aref<S_PhysicalDeviceMeshShaderFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceCornerSampledImageFeaturesNV(Aref<S_PhysicalDeviceCornerSampledImageFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceMultiviewFeatures(Aref<S_PhysicalDeviceMultiviewFeatures> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceProtectedMemoryFeatures(Aref<S_PhysicalDeviceProtectedMemoryFeatures> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDevice16BitStorageFeatures(Aref<S_PhysicalDevice16BitStorageFeatures> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceImagelessFramebufferFeaturesKHR(Aref<S_PhysicalDeviceImagelessFramebufferFeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceExclusiveScissorFeaturesNV(Aref<S_PhysicalDeviceExclusiveScissorFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR(Aref<S_PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(Aref<S_PhysicalDeviceYcbcrImageArraysFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(Aref<S_PhysicalDeviceIndexTypeUint8FeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceDepthClipEnableFeaturesEXT(Aref<S_PhysicalDeviceDepthClipEnableFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(Aref<S_PhysicalDeviceTexelBufferAlignmentFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(Aref<S_PhysicalDeviceDescriptorIndexingFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT(Aref<S_PhysicalDeviceScalarBlockLayoutFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceShaderDrawParametersFeatures(Aref<S_PhysicalDeviceShaderDrawParametersFeatures> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceVariablePointersFeatures(Aref<S_PhysicalDeviceVariablePointersFeatures> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(Aref<S_PhysicalDeviceShaderSMBuiltinsFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceConditionalRenderingFeaturesEXT(Aref<S_PhysicalDeviceConditionalRenderingFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceShaderImageFootprintFeaturesNV(Aref<S_PhysicalDeviceShaderImageFootprintFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR(Aref<S_PhysicalDeviceShaderFloat16Int8FeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(Aref<S_PhysicalDeviceInlineUniformBlockFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(Aref<S_PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceASTCDecodeFeaturesEXT(Aref<S_PhysicalDeviceASTCDecodeFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(Aref<S_PhysicalDeviceBufferDeviceAddressFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceLineRasterizationFeaturesEXT(Aref<S_PhysicalDeviceLineRasterizationFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(Aref<S_PhysicalDevicePipelineExecutablePropertiesFeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceSamplerYcbcrConversionFeatures(Aref<S_PhysicalDeviceSamplerYcbcrConversionFeatures> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(Aref<S_PhysicalDeviceFragmentShaderBarycentricFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceCoverageReductionModeFeaturesNV(Aref<S_PhysicalDeviceCoverageReductionModeFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(Aref<S_PhysicalDeviceComputeShaderDerivativesFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceTransformFeedbackFeaturesEXT(Aref<S_PhysicalDeviceTransformFeedbackFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR(Aref<S_PhysicalDeviceVulkanMemoryModelFeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceCoherentMemoryFeaturesAMD(Aref<S_PhysicalDeviceCoherentMemoryFeaturesAMD> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(Aref<S_PhysicalDeviceFragmentDensityMapFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(Aref<S_PhysicalDeviceVertexAttributeDivisorFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(Aref<S_PhysicalDeviceFragmentShaderInterlockFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceFeatures2& n_VkPhysicalDeviceMemoryPriorityFeaturesEXT(Aref<S_PhysicalDeviceMemoryPriorityFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_PhysicalDeviceFeatures2 : public VkPhysicalDeviceFeatures2 {
public:
    using Otype = VkPhysicalDeviceFeatures2;
public:
    S_PhysicalDeviceFeatures2(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceFeatures2(
        S_PhysicalDeviceFeatures features_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
        nullptr,
        features_
    } { }
    S_PhysicalDeviceFeatures2& set_next(N_PhysicalDeviceFeatures2& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_PhysicalDeviceFeatures2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceFeatures2*() { return this; }
    inL operator S_PhysicalDeviceFeatures2 const* () const { return const_cast<S_PhysicalDeviceFeatures2 const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceFeatures2> { using T = S_PhysicalDeviceFeatures2; };
struct S_CalibratedTimestampInfoEXT : public VkCalibratedTimestampInfoEXT {
public:
    using Otype = VkCalibratedTimestampInfoEXT;
public:
    S_CalibratedTimestampInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_CalibratedTimestampInfoEXT(
        E_TimeDomainEXT timeDomain_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT,
        nullptr,
        timeDomain_
    } { }
    inL S_CalibratedTimestampInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_CalibratedTimestampInfoEXT*() { return this; }
    inL operator S_CalibratedTimestampInfoEXT const* () const { return const_cast<S_CalibratedTimestampInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkCalibratedTimestampInfoEXT> { using T = S_CalibratedTimestampInfoEXT; };
struct S_ObjectTableVertexBufferEntryNVX : public VkObjectTableVertexBufferEntryNVX {
public:
    using Otype = VkObjectTableVertexBufferEntryNVX;
public:
    S_ObjectTableVertexBufferEntryNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_ObjectTableVertexBufferEntryNVX(
        E_ObjectEntryTypeNVX type_= { },
        VkObjectEntryUsageFlagsNVX flags_= { },
        VkBuffer buffer_= { }
    ) : Otype{
        type_,
        flags_,
        buffer_
    } { }
    inL S_ObjectTableVertexBufferEntryNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ObjectTableVertexBufferEntryNVX*() { return this; }
    inL operator S_ObjectTableVertexBufferEntryNVX const* () const { return const_cast<S_ObjectTableVertexBufferEntryNVX const*>(this); }
};
template<> struct detail::names_map<VkObjectTableVertexBufferEntryNVX> { using T = S_ObjectTableVertexBufferEntryNVX; };
struct S_AllocationCallbacks : public VkAllocationCallbacks {
public:
    using Otype = VkAllocationCallbacks;
public:
    S_AllocationCallbacks(Otype& origin_obj_):Otype(origin_obj_){}
    S_AllocationCallbacks(
        Aptr<void> pUserData_= { },
        PFN_vkAllocationFunction pfnAllocation_= { },
        PFN_vkReallocationFunction pfnReallocation_= { },
        PFN_vkFreeFunction pfnFree_= { },
        PFN_vkInternalAllocationNotification pfnInternalAllocation_= { },
        PFN_vkInternalFreeNotification pfnInternalFree_= { }
    ) : Otype{
        pUserData_,
        pfnAllocation_,
        pfnReallocation_,
        pfnFree_,
        pfnInternalAllocation_,
        pfnInternalFree_
    } { }
    inL S_AllocationCallbacks& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AllocationCallbacks*() { return this; }
    inL operator S_AllocationCallbacks const* () const { return const_cast<S_AllocationCallbacks const*>(this); }
};
template<> struct detail::names_map<VkAllocationCallbacks> { using T = S_AllocationCallbacks; };
struct S_ConditionalRenderingBeginInfoEXT : public VkConditionalRenderingBeginInfoEXT {
public:
    using Otype = VkConditionalRenderingBeginInfoEXT;
public:
    S_ConditionalRenderingBeginInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_ConditionalRenderingBeginInfoEXT(
        VkBuffer buffer_= { },
        VkDeviceSize offset_= { },
        VkConditionalRenderingFlagsEXT flags_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
        nullptr,
        buffer_,
        offset_,
        flags_
    } { }
    inL S_ConditionalRenderingBeginInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ConditionalRenderingBeginInfoEXT*() { return this; }
    inL operator S_ConditionalRenderingBeginInfoEXT const* () const { return const_cast<S_ConditionalRenderingBeginInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkConditionalRenderingBeginInfoEXT> { using T = S_ConditionalRenderingBeginInfoEXT; };
struct S_ValidationCacheCreateInfoEXT : public VkValidationCacheCreateInfoEXT {
public:
    using Otype = VkValidationCacheCreateInfoEXT;
public:
    S_ValidationCacheCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_ValidationCacheCreateInfoEXT(
        VkValidationCacheCreateFlagsEXT flags_= { },
        Array_general<void> pInitialData_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT,
        nullptr,
        flags_,
        pInitialData_.size(),
        reinterpret_cast<void*>(pInitialData_.data())
    } { }
    inL S_ValidationCacheCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ValidationCacheCreateInfoEXT*() { return this; }
    inL operator S_ValidationCacheCreateInfoEXT const* () const { return const_cast<S_ValidationCacheCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkValidationCacheCreateInfoEXT> { using T = S_ValidationCacheCreateInfoEXT; };
struct S_DisplayPlanePropertiesKHR : public VkDisplayPlanePropertiesKHR {
public:
    using Otype = VkDisplayPlanePropertiesKHR;
public:
    S_DisplayPlanePropertiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayPlanePropertiesKHR(
        VkDisplayKHR currentDisplay_= { },
        uint32_t currentStackIndex_= { }
    ) : Otype{
        currentDisplay_,
        currentStackIndex_
    } { }
    inL S_DisplayPlanePropertiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayPlanePropertiesKHR*() { return this; }
    inL operator S_DisplayPlanePropertiesKHR const* () const { return const_cast<S_DisplayPlanePropertiesKHR const*>(this); }
};
template<> struct detail::names_map<VkDisplayPlanePropertiesKHR> { using T = S_DisplayPlanePropertiesKHR; };
struct S_DisplayPlaneProperties2KHR : public VkDisplayPlaneProperties2KHR {
public:
    using Otype = VkDisplayPlaneProperties2KHR;
public:
    S_DisplayPlaneProperties2KHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayPlaneProperties2KHR(
        S_DisplayPlanePropertiesKHR displayPlaneProperties_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR,
        nullptr,
        displayPlaneProperties_
    } { }
    inL S_DisplayPlaneProperties2KHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayPlaneProperties2KHR*() { return this; }
    inL operator S_DisplayPlaneProperties2KHR const* () const { return const_cast<S_DisplayPlaneProperties2KHR const*>(this); }
};
template<> struct detail::names_map<VkDisplayPlaneProperties2KHR> { using T = S_DisplayPlaneProperties2KHR; };
struct S_DescriptorBufferInfo : public VkDescriptorBufferInfo {
public:
    using Otype = VkDescriptorBufferInfo;
public:
    S_DescriptorBufferInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorBufferInfo(
        VkBuffer buffer_= { },
        VkDeviceSize offset_= { },
        VkDeviceSize range_= { }
    ) : Otype{
        buffer_,
        offset_,
        range_
    } { }
    inL S_DescriptorBufferInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorBufferInfo*() { return this; }
    inL operator S_DescriptorBufferInfo const* () const { return const_cast<S_DescriptorBufferInfo const*>(this); }
};
template<> struct detail::names_map<VkDescriptorBufferInfo> { using T = S_DescriptorBufferInfo; };
struct S_ImportMemoryHostPointerInfoEXT : public VkImportMemoryHostPointerInfoEXT {
public:
    using Otype = VkImportMemoryHostPointerInfoEXT;
public:
    S_ImportMemoryHostPointerInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImportMemoryHostPointerInfoEXT(
        F_ExternalMemoryHandleType handleType_= { },
        Aptr<void> pHostPointer_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
        nullptr,
        handleType_,
        pHostPointer_
    } { }
    inL S_ImportMemoryHostPointerInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImportMemoryHostPointerInfoEXT*() { return this; }
    inL operator S_ImportMemoryHostPointerInfoEXT const* () const { return const_cast<S_ImportMemoryHostPointerInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkImportMemoryHostPointerInfoEXT> { using T = S_ImportMemoryHostPointerInfoEXT; };
struct S_DescriptorSetVariableDescriptorCountAllocateInfoEXT : public VkDescriptorSetVariableDescriptorCountAllocateInfoEXT {
public:
    using Otype = VkDescriptorSetVariableDescriptorCountAllocateInfoEXT;
public:
    S_DescriptorSetVariableDescriptorCountAllocateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorSetVariableDescriptorCountAllocateInfoEXT(
        Array_general<uint32_t> pDescriptorCounts_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT,
        nullptr,
        pDescriptorCounts_.size(),
        reinterpret_cast<uint32_t*>(pDescriptorCounts_.data())
    } { }
    inL S_DescriptorSetVariableDescriptorCountAllocateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorSetVariableDescriptorCountAllocateInfoEXT*() { return this; }
    inL operator S_DescriptorSetVariableDescriptorCountAllocateInfoEXT const* () const { return const_cast<S_DescriptorSetVariableDescriptorCountAllocateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDescriptorSetVariableDescriptorCountAllocateInfoEXT> { using T = S_DescriptorSetVariableDescriptorCountAllocateInfoEXT; };
struct N_PipelineVertexInputStateCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_PipelineVertexInputStateCreateInfo& n_VkPipelineVertexInputDivisorStateCreateInfoEXT(Aref<S_PipelineVertexInputDivisorStateCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_PipelineVertexInputStateCreateInfo : public VkPipelineVertexInputStateCreateInfo {
public:
    using Otype = VkPipelineVertexInputStateCreateInfo;
public:
    S_PipelineVertexInputStateCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineVertexInputStateCreateInfo(
        VkPipelineVertexInputStateCreateFlags flags_= { },
        Array_general<S_VertexInputBindingDescription> pVertexBindingDescriptions_= { },
        Array_general<S_VertexInputAttributeDescription> pVertexAttributeDescriptions_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
        nullptr,
        flags_,
        pVertexBindingDescriptions_.size(),
        reinterpret_cast<VkVertexInputBindingDescription*>(pVertexBindingDescriptions_.data()),
        pVertexAttributeDescriptions_.size(),
        reinterpret_cast<VkVertexInputAttributeDescription*>(pVertexAttributeDescriptions_.data())
    } { }
    S_PipelineVertexInputStateCreateInfo& set_next(N_PipelineVertexInputStateCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_PipelineVertexInputStateCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineVertexInputStateCreateInfo*() { return this; }
    inL operator S_PipelineVertexInputStateCreateInfo const* () const { return const_cast<S_PipelineVertexInputStateCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkPipelineVertexInputStateCreateInfo> { using T = S_PipelineVertexInputStateCreateInfo; };
struct S_PhysicalDeviceShaderCoreProperties2AMD : public VkPhysicalDeviceShaderCoreProperties2AMD {
public:
    using Otype = VkPhysicalDeviceShaderCoreProperties2AMD;
public:
    S_PhysicalDeviceShaderCoreProperties2AMD(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceShaderCoreProperties2AMD(
        VkShaderCorePropertiesFlagsAMD shaderCoreFeatures_= { },
        uint32_t activeComputeUnitCount_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD,
        nullptr,
        shaderCoreFeatures_,
        activeComputeUnitCount_
    } { }
    inL S_PhysicalDeviceShaderCoreProperties2AMD& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceShaderCoreProperties2AMD*() { return this; }
    inL operator S_PhysicalDeviceShaderCoreProperties2AMD const* () const { return const_cast<S_PhysicalDeviceShaderCoreProperties2AMD const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceShaderCoreProperties2AMD> { using T = S_PhysicalDeviceShaderCoreProperties2AMD; };
struct S_ClearDepthStencilValue : public VkClearDepthStencilValue {
public:
    using Otype = VkClearDepthStencilValue;
public:
    S_ClearDepthStencilValue(Otype& origin_obj_):Otype(origin_obj_){}
    S_ClearDepthStencilValue(
        float depth_= { },
        uint32_t stencil_= { }
    ) : Otype{
        depth_,
        stencil_
    } { }
    inL S_ClearDepthStencilValue& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ClearDepthStencilValue*() { return this; }
    inL operator S_ClearDepthStencilValue const* () const { return const_cast<S_ClearDepthStencilValue const*>(this); }
};
template<> struct detail::names_map<VkClearDepthStencilValue> { using T = S_ClearDepthStencilValue; };

# if defined(VK_USE_PLATFORM_FUCHSIA)
struct S_ImagePipeSurfaceCreateInfoFUCHSIA : public VkImagePipeSurfaceCreateInfoFUCHSIA {
public:
    using Otype = VkImagePipeSurfaceCreateInfoFUCHSIA;
public:
    S_ImagePipeSurfaceCreateInfoFUCHSIA(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImagePipeSurfaceCreateInfoFUCHSIA(
        VkImagePipeSurfaceCreateFlagsFUCHSIA flags_= { },
        zx_handle_t imagePipeHandle_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA,
        nullptr,
        flags_,
        imagePipeHandle_
    } { }
    inL S_ImagePipeSurfaceCreateInfoFUCHSIA& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImagePipeSurfaceCreateInfoFUCHSIA*() { return this; }
    inL operator S_ImagePipeSurfaceCreateInfoFUCHSIA const* () const { return const_cast<S_ImagePipeSurfaceCreateInfoFUCHSIA const*>(this); }
};
template<> struct detail::names_map<VkImagePipeSurfaceCreateInfoFUCHSIA> { using T = S_ImagePipeSurfaceCreateInfoFUCHSIA; };

#endif
struct S_PhysicalDeviceMultiviewProperties : public VkPhysicalDeviceMultiviewProperties {
public:
    using Otype = VkPhysicalDeviceMultiviewProperties;
public:
    S_PhysicalDeviceMultiviewProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceMultiviewProperties(
        uint32_t maxMultiviewViewCount_= { },
        uint32_t maxMultiviewInstanceIndex_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
        nullptr,
        maxMultiviewViewCount_,
        maxMultiviewInstanceIndex_
    } { }
    inL S_PhysicalDeviceMultiviewProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceMultiviewProperties*() { return this; }
    inL operator S_PhysicalDeviceMultiviewProperties const* () const { return const_cast<S_PhysicalDeviceMultiviewProperties const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceMultiviewProperties> { using T = S_PhysicalDeviceMultiviewProperties; };
struct S_PhysicalDeviceSparseImageFormatInfo2 : public VkPhysicalDeviceSparseImageFormatInfo2 {
public:
    using Otype = VkPhysicalDeviceSparseImageFormatInfo2;
public:
    S_PhysicalDeviceSparseImageFormatInfo2(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceSparseImageFormatInfo2(
        E_Format format_= { },
        E_ImageType type_= { },
        F_SampleCount samples_= { },
        VkImageUsageFlags usage_= { },
        E_ImageTiling tiling_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
        nullptr,
        format_,
        type_,
        samples_,
        usage_,
        tiling_
    } { }
    inL S_PhysicalDeviceSparseImageFormatInfo2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceSparseImageFormatInfo2*() { return this; }
    inL operator S_PhysicalDeviceSparseImageFormatInfo2 const* () const { return const_cast<S_PhysicalDeviceSparseImageFormatInfo2 const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceSparseImageFormatInfo2> { using T = S_PhysicalDeviceSparseImageFormatInfo2; };
struct S_ShaderModuleValidationCacheCreateInfoEXT : public VkShaderModuleValidationCacheCreateInfoEXT {
public:
    using Otype = VkShaderModuleValidationCacheCreateInfoEXT;
public:
    S_ShaderModuleValidationCacheCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_ShaderModuleValidationCacheCreateInfoEXT(
        VkValidationCacheEXT validationCache_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
        nullptr,
        validationCache_
    } { }
    inL S_ShaderModuleValidationCacheCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ShaderModuleValidationCacheCreateInfoEXT*() { return this; }
    inL operator S_ShaderModuleValidationCacheCreateInfoEXT const* () const { return const_cast<S_ShaderModuleValidationCacheCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkShaderModuleValidationCacheCreateInfoEXT> { using T = S_ShaderModuleValidationCacheCreateInfoEXT; };
struct N_ShaderModuleCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_ShaderModuleCreateInfo& n_VkShaderModuleValidationCacheCreateInfoEXT(Aref<S_ShaderModuleValidationCacheCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_ShaderModuleCreateInfo : public VkShaderModuleCreateInfo {
public:
    using Otype = VkShaderModuleCreateInfo;
public:
    S_ShaderModuleCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_ShaderModuleCreateInfo(
        VkShaderModuleCreateFlags flags_= { },
        size_t codeSize_= { },
        Aptr<uint32_t> pCode_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        nullptr,
        flags_,
        codeSize_,
        pCode_
    } { }
    S_ShaderModuleCreateInfo& set_next(N_ShaderModuleCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_ShaderModuleCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ShaderModuleCreateInfo*() { return this; }
    inL operator S_ShaderModuleCreateInfo const* () const { return const_cast<S_ShaderModuleCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkShaderModuleCreateInfo> { using T = S_ShaderModuleCreateInfo; };
struct S_PipelineRasterizationStateStreamCreateInfoEXT : public VkPipelineRasterizationStateStreamCreateInfoEXT {
public:
    using Otype = VkPipelineRasterizationStateStreamCreateInfoEXT;
public:
    S_PipelineRasterizationStateStreamCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineRasterizationStateStreamCreateInfoEXT(
        VkPipelineRasterizationStateStreamCreateFlagsEXT flags_= { },
        uint32_t rasterizationStream_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
        nullptr,
        flags_,
        rasterizationStream_
    } { }
    inL S_PipelineRasterizationStateStreamCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineRasterizationStateStreamCreateInfoEXT*() { return this; }
    inL operator S_PipelineRasterizationStateStreamCreateInfoEXT const* () const { return const_cast<S_PipelineRasterizationStateStreamCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkPipelineRasterizationStateStreamCreateInfoEXT> { using T = S_PipelineRasterizationStateStreamCreateInfoEXT; };
struct S_PipelineRasterizationLineStateCreateInfoEXT : public VkPipelineRasterizationLineStateCreateInfoEXT {
public:
    using Otype = VkPipelineRasterizationLineStateCreateInfoEXT;
public:
    S_PipelineRasterizationLineStateCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineRasterizationLineStateCreateInfoEXT(
        E_LineRasterizationModeEXT lineRasterizationMode_= { },
        VkBool32 stippledLineEnable_= { },
        uint32_t lineStippleFactor_= { },
        uint16_t lineStipplePattern_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT,
        nullptr,
        lineRasterizationMode_,
        stippledLineEnable_,
        lineStippleFactor_,
        lineStipplePattern_
    } { }
    inL S_PipelineRasterizationLineStateCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineRasterizationLineStateCreateInfoEXT*() { return this; }
    inL operator S_PipelineRasterizationLineStateCreateInfoEXT const* () const { return const_cast<S_PipelineRasterizationLineStateCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkPipelineRasterizationLineStateCreateInfoEXT> { using T = S_PipelineRasterizationLineStateCreateInfoEXT; };
struct S_PipelineRasterizationConservativeStateCreateInfoEXT : public VkPipelineRasterizationConservativeStateCreateInfoEXT {
public:
    using Otype = VkPipelineRasterizationConservativeStateCreateInfoEXT;
public:
    S_PipelineRasterizationConservativeStateCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineRasterizationConservativeStateCreateInfoEXT(
        VkPipelineRasterizationConservativeStateCreateFlagsEXT flags_= { },
        E_ConservativeRasterizationModeEXT conservativeRasterizationMode_= { },
        float extraPrimitiveOverestimationSize_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
        nullptr,
        flags_,
        conservativeRasterizationMode_,
        extraPrimitiveOverestimationSize_
    } { }
    inL S_PipelineRasterizationConservativeStateCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineRasterizationConservativeStateCreateInfoEXT*() { return this; }
    inL operator S_PipelineRasterizationConservativeStateCreateInfoEXT const* () const { return const_cast<S_PipelineRasterizationConservativeStateCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkPipelineRasterizationConservativeStateCreateInfoEXT> { using T = S_PipelineRasterizationConservativeStateCreateInfoEXT; };
struct N_PipelineRasterizationStateCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_PipelineRasterizationStateCreateInfo& n_VkPipelineRasterizationStateRasterizationOrderAMD(Aref<S_PipelineRasterizationStateRasterizationOrderAMD> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PipelineRasterizationStateCreateInfo& n_VkPipelineRasterizationDepthClipStateCreateInfoEXT(Aref<S_PipelineRasterizationDepthClipStateCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PipelineRasterizationStateCreateInfo& n_VkPipelineRasterizationStateStreamCreateInfoEXT(Aref<S_PipelineRasterizationStateStreamCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PipelineRasterizationStateCreateInfo& n_VkPipelineRasterizationLineStateCreateInfoEXT(Aref<S_PipelineRasterizationLineStateCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PipelineRasterizationStateCreateInfo& n_VkPipelineRasterizationConservativeStateCreateInfoEXT(Aref<S_PipelineRasterizationConservativeStateCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_PipelineRasterizationStateCreateInfo : public VkPipelineRasterizationStateCreateInfo {
public:
    using Otype = VkPipelineRasterizationStateCreateInfo;
public:
    S_PipelineRasterizationStateCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineRasterizationStateCreateInfo(
        VkPipelineRasterizationStateCreateFlags flags_= { },
        VkBool32 depthClampEnable_= { },
        VkBool32 rasterizerDiscardEnable_= { },
        E_PolygonMode polygonMode_= { },
        VkCullModeFlags cullMode_= { },
        E_FrontFace frontFace_= { },
        VkBool32 depthBiasEnable_= { },
        float depthBiasConstantFactor_= { },
        float depthBiasClamp_= { },
        float depthBiasSlopeFactor_= { },
        float lineWidth_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
        nullptr,
        flags_,
        depthClampEnable_,
        rasterizerDiscardEnable_,
        polygonMode_,
        cullMode_,
        frontFace_,
        depthBiasEnable_,
        depthBiasConstantFactor_,
        depthBiasClamp_,
        depthBiasSlopeFactor_,
        lineWidth_
    } { }
    S_PipelineRasterizationStateCreateInfo& set_next(N_PipelineRasterizationStateCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_PipelineRasterizationStateCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineRasterizationStateCreateInfo*() { return this; }
    inL operator S_PipelineRasterizationStateCreateInfo const* () const { return const_cast<S_PipelineRasterizationStateCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkPipelineRasterizationStateCreateInfo> { using T = S_PipelineRasterizationStateCreateInfo; };
struct S_DeviceEventInfoEXT : public VkDeviceEventInfoEXT {
public:
    using Otype = VkDeviceEventInfoEXT;
public:
    S_DeviceEventInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceEventInfoEXT(
        E_DeviceEventTypeEXT deviceEvent_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT,
        nullptr,
        deviceEvent_
    } { }
    inL S_DeviceEventInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceEventInfoEXT*() { return this; }
    inL operator S_DeviceEventInfoEXT const* () const { return const_cast<S_DeviceEventInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDeviceEventInfoEXT> { using T = S_DeviceEventInfoEXT; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_ExportMemoryWin32HandleInfoNV : public VkExportMemoryWin32HandleInfoNV {
public:
    using Otype = VkExportMemoryWin32HandleInfoNV;
public:
    S_ExportMemoryWin32HandleInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExportMemoryWin32HandleInfoNV(
        Aptr<SECURITY_ATTRIBUTES> pAttributes_= { },
        DWORD dwAccess_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV,
        nullptr,
        pAttributes_,
        dwAccess_
    } { }
    inL S_ExportMemoryWin32HandleInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExportMemoryWin32HandleInfoNV*() { return this; }
    inL operator S_ExportMemoryWin32HandleInfoNV const* () const { return const_cast<S_ExportMemoryWin32HandleInfoNV const*>(this); }
};
template<> struct detail::names_map<VkExportMemoryWin32HandleInfoNV> { using T = S_ExportMemoryWin32HandleInfoNV; };

#endif
struct S_DisplayPropertiesKHR : public VkDisplayPropertiesKHR {
public:
    using Otype = VkDisplayPropertiesKHR;
public:
    S_DisplayPropertiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayPropertiesKHR(
        VkDisplayKHR display_= { },
        Aptr<char> displayName_= { },
        S_Extent2D physicalDimensions_= { },
        S_Extent2D physicalResolution_= { },
        VkSurfaceTransformFlagsKHR supportedTransforms_= { },
        VkBool32 planeReorderPossible_= { },
        VkBool32 persistentContent_= { }
    ) : Otype{
        display_,
        displayName_,
        physicalDimensions_,
        physicalResolution_,
        supportedTransforms_,
        planeReorderPossible_,
        persistentContent_
    } { }
    inL S_DisplayPropertiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayPropertiesKHR*() { return this; }
    inL operator S_DisplayPropertiesKHR const* () const { return const_cast<S_DisplayPropertiesKHR const*>(this); }
};
template<> struct detail::names_map<VkDisplayPropertiesKHR> { using T = S_DisplayPropertiesKHR; };
struct S_DisplayProperties2KHR : public VkDisplayProperties2KHR {
public:
    using Otype = VkDisplayProperties2KHR;
public:
    S_DisplayProperties2KHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayProperties2KHR(
        S_DisplayPropertiesKHR displayProperties_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR,
        nullptr,
        displayProperties_
    } { }
    inL S_DisplayProperties2KHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayProperties2KHR*() { return this; }
    inL operator S_DisplayProperties2KHR const* () const { return const_cast<S_DisplayProperties2KHR const*>(this); }
};
template<> struct detail::names_map<VkDisplayProperties2KHR> { using T = S_DisplayProperties2KHR; };

# if defined(VK_USE_PLATFORM_METAL_EXT)
struct S_MetalSurfaceCreateInfoEXT : public VkMetalSurfaceCreateInfoEXT {
public:
    using Otype = VkMetalSurfaceCreateInfoEXT;
public:
    S_MetalSurfaceCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_MetalSurfaceCreateInfoEXT(
        VkMetalSurfaceCreateFlagsEXT flags_= { },
        Aptr<CAMetalLayer> pLayer_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT,
        nullptr,
        flags_,
        pLayer_
    } { }
    inL S_MetalSurfaceCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MetalSurfaceCreateInfoEXT*() { return this; }
    inL operator S_MetalSurfaceCreateInfoEXT const* () const { return const_cast<S_MetalSurfaceCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkMetalSurfaceCreateInfoEXT> { using T = S_MetalSurfaceCreateInfoEXT; };

#endif
struct S_DebugUtilsObjectTagInfoEXT : public VkDebugUtilsObjectTagInfoEXT {
public:
    using Otype = VkDebugUtilsObjectTagInfoEXT;
public:
    S_DebugUtilsObjectTagInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DebugUtilsObjectTagInfoEXT(
        E_ObjectType objectType_= { },
        uint64_t objectHandle_= { },
        uint64_t tagName_= { },
        Array_general<void> pTag_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
        nullptr,
        objectType_,
        objectHandle_,
        tagName_,
        pTag_.size(),
        reinterpret_cast<void*>(pTag_.data())
    } { }
    inL S_DebugUtilsObjectTagInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DebugUtilsObjectTagInfoEXT*() { return this; }
    inL operator S_DebugUtilsObjectTagInfoEXT const* () const { return const_cast<S_DebugUtilsObjectTagInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDebugUtilsObjectTagInfoEXT> { using T = S_DebugUtilsObjectTagInfoEXT; };
struct S_IndirectCommandsLayoutTokenNVX : public VkIndirectCommandsLayoutTokenNVX {
public:
    using Otype = VkIndirectCommandsLayoutTokenNVX;
public:
    S_IndirectCommandsLayoutTokenNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_IndirectCommandsLayoutTokenNVX(
        E_IndirectCommandsTokenTypeNVX tokenType_= { },
        uint32_t bindingUnit_= { },
        uint32_t dynamicCount_= { },
        uint32_t divisor_= { }
    ) : Otype{
        tokenType_,
        bindingUnit_,
        dynamicCount_,
        divisor_
    } { }
    inL S_IndirectCommandsLayoutTokenNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_IndirectCommandsLayoutTokenNVX*() { return this; }
    inL operator S_IndirectCommandsLayoutTokenNVX const* () const { return const_cast<S_IndirectCommandsLayoutTokenNVX const*>(this); }
};
template<> struct detail::names_map<VkIndirectCommandsLayoutTokenNVX> { using T = S_IndirectCommandsLayoutTokenNVX; };
struct S_DescriptorSetLayoutBindingFlagsCreateInfoEXT : public VkDescriptorSetLayoutBindingFlagsCreateInfoEXT {
public:
    using Otype = VkDescriptorSetLayoutBindingFlagsCreateInfoEXT;
public:
    S_DescriptorSetLayoutBindingFlagsCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorSetLayoutBindingFlagsCreateInfoEXT(
        Array_general<VkDescriptorBindingFlagsEXT> pBindingFlags_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT,
        nullptr,
        pBindingFlags_.size(),
        reinterpret_cast<VkDescriptorBindingFlagsEXT*>(pBindingFlags_.data())
    } { }
    inL S_DescriptorSetLayoutBindingFlagsCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorSetLayoutBindingFlagsCreateInfoEXT*() { return this; }
    inL operator S_DescriptorSetLayoutBindingFlagsCreateInfoEXT const* () const { return const_cast<S_DescriptorSetLayoutBindingFlagsCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDescriptorSetLayoutBindingFlagsCreateInfoEXT> { using T = S_DescriptorSetLayoutBindingFlagsCreateInfoEXT; };
struct S_PhysicalDeviceLineRasterizationPropertiesEXT : public VkPhysicalDeviceLineRasterizationPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceLineRasterizationPropertiesEXT;
public:
    S_PhysicalDeviceLineRasterizationPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceLineRasterizationPropertiesEXT(
        uint32_t lineSubPixelPrecisionBits_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT,
        nullptr,
        lineSubPixelPrecisionBits_
    } { }
    inL S_PhysicalDeviceLineRasterizationPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceLineRasterizationPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceLineRasterizationPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceLineRasterizationPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceLineRasterizationPropertiesEXT> { using T = S_PhysicalDeviceLineRasterizationPropertiesEXT; };
struct S_PhysicalDeviceMeshShaderPropertiesNV : public VkPhysicalDeviceMeshShaderPropertiesNV {
public:
    using Otype = VkPhysicalDeviceMeshShaderPropertiesNV;
public:
    S_PhysicalDeviceMeshShaderPropertiesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceMeshShaderPropertiesNV(
        uint32_t maxDrawMeshTasksCount_= { },
        uint32_t maxTaskWorkGroupInvocations_= { },
        std::array<uint32_t,3> maxTaskWorkGroupSize_= { },
        uint32_t maxTaskTotalMemorySize_= { },
        uint32_t maxTaskOutputCount_= { },
        uint32_t maxMeshWorkGroupInvocations_= { },
        std::array<uint32_t,3> maxMeshWorkGroupSize_= { },
        uint32_t maxMeshTotalMemorySize_= { },
        uint32_t maxMeshOutputVertices_= { },
        uint32_t maxMeshOutputPrimitives_= { },
        uint32_t maxMeshMultiviewViewCount_= { },
        uint32_t meshOutputPerVertexGranularity_= { },
        uint32_t meshOutputPerPrimitiveGranularity_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
        nullptr,
        maxDrawMeshTasksCount_,
        maxTaskWorkGroupInvocations_,
        { },
        maxTaskTotalMemorySize_,
        maxTaskOutputCount_,
        maxMeshWorkGroupInvocations_,
        { },
        maxMeshTotalMemorySize_,
        maxMeshOutputVertices_,
        maxMeshOutputPrimitives_,
        maxMeshMultiviewViewCount_,
        meshOutputPerVertexGranularity_,
        meshOutputPerPrimitiveGranularity_
    } { 
        ::memcpy(&maxTaskWorkGroupSize[0], maxTaskWorkGroupSize_.data(), maxTaskWorkGroupSize_.size() );
        ::memcpy(&maxMeshWorkGroupSize[0], maxMeshWorkGroupSize_.data(), maxMeshWorkGroupSize_.size() );
    }
    inL S_PhysicalDeviceMeshShaderPropertiesNV& 
        set_maxTaskWorkGroupSize(std::array<uint32_t,3> maxTaskWorkGroupSize_)
        {  return *this; }
    inL S_PhysicalDeviceMeshShaderPropertiesNV& 
        set_maxMeshWorkGroupSize(std::array<uint32_t,3> maxMeshWorkGroupSize_)
        {  return *this; }
    inL S_PhysicalDeviceMeshShaderPropertiesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceMeshShaderPropertiesNV*() { return this; }
    inL operator S_PhysicalDeviceMeshShaderPropertiesNV const* () const { return const_cast<S_PhysicalDeviceMeshShaderPropertiesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceMeshShaderPropertiesNV> { using T = S_PhysicalDeviceMeshShaderPropertiesNV; };
struct S_PhysicalDeviceSparseProperties : public VkPhysicalDeviceSparseProperties {
public:
    using Otype = VkPhysicalDeviceSparseProperties;
public:
    S_PhysicalDeviceSparseProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceSparseProperties(
        VkBool32 residencyStandard2DBlockShape_= { },
        VkBool32 residencyStandard2DMultisampleBlockShape_= { },
        VkBool32 residencyStandard3DBlockShape_= { },
        VkBool32 residencyAlignedMipSize_= { },
        VkBool32 residencyNonResidentStrict_= { }
    ) : Otype{
        residencyStandard2DBlockShape_,
        residencyStandard2DMultisampleBlockShape_,
        residencyStandard3DBlockShape_,
        residencyAlignedMipSize_,
        residencyNonResidentStrict_
    } { }
    inL S_PhysicalDeviceSparseProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceSparseProperties*() { return this; }
    inL operator S_PhysicalDeviceSparseProperties const* () const { return const_cast<S_PhysicalDeviceSparseProperties const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceSparseProperties> { using T = S_PhysicalDeviceSparseProperties; };
struct S_PhysicalDeviceProperties : public VkPhysicalDeviceProperties {
public:
    using Otype = VkPhysicalDeviceProperties;
public:
    S_PhysicalDeviceProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceProperties(
        uint32_t apiVersion_= { },
        uint32_t driverVersion_= { },
        uint32_t vendorID_= { },
        uint32_t deviceID_= { },
        E_PhysicalDeviceType deviceType_= { },
        std::array<char,VK_MAX_PHYSICAL_DEVICE_NAME_SIZE> deviceName_= { },
        std::array<uint8_t,VK_UUID_SIZE> pipelineCacheUUID_= { },
        S_PhysicalDeviceLimits limits_= { },
        S_PhysicalDeviceSparseProperties sparseProperties_= { }
    ) : Otype{
        apiVersion_,
        driverVersion_,
        vendorID_,
        deviceID_,
        deviceType_,
        { },
        { },
        limits_,
        sparseProperties_
    } { 
        ::memcpy(&deviceName[0], deviceName_.data(), deviceName_.size() );
        ::memcpy(&pipelineCacheUUID[0], pipelineCacheUUID_.data(), pipelineCacheUUID_.size() );
    }
    inL S_PhysicalDeviceProperties& 
        set_deviceName(std::array<char,VK_MAX_PHYSICAL_DEVICE_NAME_SIZE> deviceName_)
        {  return *this; }
    inL S_PhysicalDeviceProperties& 
        set_pipelineCacheUUID(std::array<uint8_t,VK_UUID_SIZE> pipelineCacheUUID_)
        {  return *this; }
    inL S_PhysicalDeviceProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceProperties*() { return this; }
    inL operator S_PhysicalDeviceProperties const* () const { return const_cast<S_PhysicalDeviceProperties const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceProperties> { using T = S_PhysicalDeviceProperties; };
struct S_ExternalFenceProperties : public VkExternalFenceProperties {
public:
    using Otype = VkExternalFenceProperties;
public:
    S_ExternalFenceProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExternalFenceProperties(
        VkExternalFenceHandleTypeFlags exportFromImportedHandleTypes_= { },
        VkExternalFenceHandleTypeFlags compatibleHandleTypes_= { },
        VkExternalFenceFeatureFlags externalFenceFeatures_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
        nullptr,
        exportFromImportedHandleTypes_,
        compatibleHandleTypes_,
        externalFenceFeatures_
    } { }
    inL S_ExternalFenceProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExternalFenceProperties*() { return this; }
    inL operator S_ExternalFenceProperties const* () const { return const_cast<S_ExternalFenceProperties const*>(this); }
};
template<> struct detail::names_map<VkExternalFenceProperties> { using T = S_ExternalFenceProperties; };
struct S_IndirectCommandsLayoutCreateInfoNVX : public VkIndirectCommandsLayoutCreateInfoNVX {
public:
    using Otype = VkIndirectCommandsLayoutCreateInfoNVX;
public:
    S_IndirectCommandsLayoutCreateInfoNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_IndirectCommandsLayoutCreateInfoNVX(
        E_PipelineBindPoint pipelineBindPoint_= { },
        VkIndirectCommandsLayoutUsageFlagsNVX flags_= { },
        Array_general<S_IndirectCommandsLayoutTokenNVX> pTokens_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX,
        nullptr,
        pipelineBindPoint_,
        flags_,
        pTokens_.size(),
        reinterpret_cast<VkIndirectCommandsLayoutTokenNVX*>(pTokens_.data())
    } { }
    inL S_IndirectCommandsLayoutCreateInfoNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_IndirectCommandsLayoutCreateInfoNVX*() { return this; }
    inL operator S_IndirectCommandsLayoutCreateInfoNVX const* () const { return const_cast<S_IndirectCommandsLayoutCreateInfoNVX const*>(this); }
};
template<> struct detail::names_map<VkIndirectCommandsLayoutCreateInfoNVX> { using T = S_IndirectCommandsLayoutCreateInfoNVX; };
struct S_BufferViewCreateInfo : public VkBufferViewCreateInfo {
public:
    using Otype = VkBufferViewCreateInfo;
public:
    S_BufferViewCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_BufferViewCreateInfo(
        VkBufferViewCreateFlags flags_= { },
        VkBuffer buffer_= { },
        E_Format format_= { },
        VkDeviceSize offset_= { },
        VkDeviceSize range_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO,
        nullptr,
        flags_,
        buffer_,
        format_,
        offset_,
        range_
    } { }
    inL S_BufferViewCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BufferViewCreateInfo*() { return this; }
    inL operator S_BufferViewCreateInfo const* () const { return const_cast<S_BufferViewCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkBufferViewCreateInfo> { using T = S_BufferViewCreateInfo; };
struct S_SamplerReductionModeCreateInfoEXT : public VkSamplerReductionModeCreateInfoEXT {
public:
    using Otype = VkSamplerReductionModeCreateInfoEXT;
public:
    S_SamplerReductionModeCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_SamplerReductionModeCreateInfoEXT(
        E_SamplerReductionModeEXT reductionMode_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT,
        nullptr,
        reductionMode_
    } { }
    inL S_SamplerReductionModeCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SamplerReductionModeCreateInfoEXT*() { return this; }
    inL operator S_SamplerReductionModeCreateInfoEXT const* () const { return const_cast<S_SamplerReductionModeCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkSamplerReductionModeCreateInfoEXT> { using T = S_SamplerReductionModeCreateInfoEXT; };
struct S_ExternalImageFormatPropertiesNV : public VkExternalImageFormatPropertiesNV {
public:
    using Otype = VkExternalImageFormatPropertiesNV;
public:
    S_ExternalImageFormatPropertiesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExternalImageFormatPropertiesNV(
        S_ImageFormatProperties imageFormatProperties_= { },
        VkExternalMemoryFeatureFlagsNV externalMemoryFeatures_= { },
        VkExternalMemoryHandleTypeFlagsNV exportFromImportedHandleTypes_= { },
        VkExternalMemoryHandleTypeFlagsNV compatibleHandleTypes_= { }
    ) : Otype{
        imageFormatProperties_,
        externalMemoryFeatures_,
        exportFromImportedHandleTypes_,
        compatibleHandleTypes_
    } { }
    inL S_ExternalImageFormatPropertiesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExternalImageFormatPropertiesNV*() { return this; }
    inL operator S_ExternalImageFormatPropertiesNV const* () const { return const_cast<S_ExternalImageFormatPropertiesNV const*>(this); }
};
template<> struct detail::names_map<VkExternalImageFormatPropertiesNV> { using T = S_ExternalImageFormatPropertiesNV; };
struct S_PhysicalDeviceIDProperties : public VkPhysicalDeviceIDProperties {
public:
    using Otype = VkPhysicalDeviceIDProperties;
public:
    S_PhysicalDeviceIDProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceIDProperties(
        std::array<uint8_t,VK_UUID_SIZE> deviceUUID_= { },
        std::array<uint8_t,VK_UUID_SIZE> driverUUID_= { },
        std::array<uint8_t,VK_LUID_SIZE> deviceLUID_= { },
        uint32_t deviceNodeMask_= { },
        VkBool32 deviceLUIDValid_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
        nullptr,
        { },
        { },
        { },
        deviceNodeMask_,
        deviceLUIDValid_
    } { 
        ::memcpy(&deviceUUID[0], deviceUUID_.data(), deviceUUID_.size() );
        ::memcpy(&driverUUID[0], driverUUID_.data(), driverUUID_.size() );
        ::memcpy(&deviceLUID[0], deviceLUID_.data(), deviceLUID_.size() );
    }
    inL S_PhysicalDeviceIDProperties& 
        set_deviceUUID(std::array<uint8_t,VK_UUID_SIZE> deviceUUID_)
        {  return *this; }
    inL S_PhysicalDeviceIDProperties& 
        set_driverUUID(std::array<uint8_t,VK_UUID_SIZE> driverUUID_)
        {  return *this; }
    inL S_PhysicalDeviceIDProperties& 
        set_deviceLUID(std::array<uint8_t,VK_LUID_SIZE> deviceLUID_)
        {  return *this; }
    inL S_PhysicalDeviceIDProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceIDProperties*() { return this; }
    inL operator S_PhysicalDeviceIDProperties const* () const { return const_cast<S_PhysicalDeviceIDProperties const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceIDProperties> { using T = S_PhysicalDeviceIDProperties; };
struct S_QueryPoolCreateInfo : public VkQueryPoolCreateInfo {
public:
    using Otype = VkQueryPoolCreateInfo;
public:
    S_QueryPoolCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_QueryPoolCreateInfo(
        VkQueryPoolCreateFlags flags_= { },
        E_QueryType queryType_= { },
        uint32_t queryCount_= { },
        VkQueryPipelineStatisticFlags pipelineStatistics_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
        nullptr,
        flags_,
        queryType_,
        queryCount_,
        pipelineStatistics_
    } { }
    inL S_QueryPoolCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_QueryPoolCreateInfo*() { return this; }
    inL operator S_QueryPoolCreateInfo const* () const { return const_cast<S_QueryPoolCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkQueryPoolCreateInfo> { using T = S_QueryPoolCreateInfo; };
struct S_PipelineSampleLocationsStateCreateInfoEXT : public VkPipelineSampleLocationsStateCreateInfoEXT {
public:
    using Otype = VkPipelineSampleLocationsStateCreateInfoEXT;
public:
    S_PipelineSampleLocationsStateCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineSampleLocationsStateCreateInfoEXT(
        VkBool32 sampleLocationsEnable_= { },
        S_SampleLocationsInfoEXT sampleLocationsInfo_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
        nullptr,
        sampleLocationsEnable_,
        sampleLocationsInfo_
    } { }
    inL S_PipelineSampleLocationsStateCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineSampleLocationsStateCreateInfoEXT*() { return this; }
    inL operator S_PipelineSampleLocationsStateCreateInfoEXT const* () const { return const_cast<S_PipelineSampleLocationsStateCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkPipelineSampleLocationsStateCreateInfoEXT> { using T = S_PipelineSampleLocationsStateCreateInfoEXT; };
struct S_PipelineCoverageToColorStateCreateInfoNV : public VkPipelineCoverageToColorStateCreateInfoNV {
public:
    using Otype = VkPipelineCoverageToColorStateCreateInfoNV;
public:
    S_PipelineCoverageToColorStateCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineCoverageToColorStateCreateInfoNV(
        VkPipelineCoverageToColorStateCreateFlagsNV flags_= { },
        VkBool32 coverageToColorEnable_= { },
        uint32_t coverageToColorLocation_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
        nullptr,
        flags_,
        coverageToColorEnable_,
        coverageToColorLocation_
    } { }
    inL S_PipelineCoverageToColorStateCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineCoverageToColorStateCreateInfoNV*() { return this; }
    inL operator S_PipelineCoverageToColorStateCreateInfoNV const* () const { return const_cast<S_PipelineCoverageToColorStateCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkPipelineCoverageToColorStateCreateInfoNV> { using T = S_PipelineCoverageToColorStateCreateInfoNV; };
struct S_PipelineCoverageReductionStateCreateInfoNV : public VkPipelineCoverageReductionStateCreateInfoNV {
public:
    using Otype = VkPipelineCoverageReductionStateCreateInfoNV;
public:
    S_PipelineCoverageReductionStateCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineCoverageReductionStateCreateInfoNV(
        VkPipelineCoverageReductionStateCreateFlagsNV flags_= { },
        E_CoverageReductionModeNV coverageReductionMode_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV,
        nullptr,
        flags_,
        coverageReductionMode_
    } { }
    inL S_PipelineCoverageReductionStateCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineCoverageReductionStateCreateInfoNV*() { return this; }
    inL operator S_PipelineCoverageReductionStateCreateInfoNV const* () const { return const_cast<S_PipelineCoverageReductionStateCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkPipelineCoverageReductionStateCreateInfoNV> { using T = S_PipelineCoverageReductionStateCreateInfoNV; };
struct N_PipelineMultisampleStateCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_PipelineMultisampleStateCreateInfo& n_VkPipelineSampleLocationsStateCreateInfoEXT(Aref<S_PipelineSampleLocationsStateCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PipelineMultisampleStateCreateInfo& n_VkPipelineCoverageToColorStateCreateInfoNV(Aref<S_PipelineCoverageToColorStateCreateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PipelineMultisampleStateCreateInfo& n_VkPipelineCoverageModulationStateCreateInfoNV(Aref<S_PipelineCoverageModulationStateCreateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PipelineMultisampleStateCreateInfo& n_VkPipelineCoverageReductionStateCreateInfoNV(Aref<S_PipelineCoverageReductionStateCreateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_PipelineMultisampleStateCreateInfo : public VkPipelineMultisampleStateCreateInfo {
public:
    using Otype = VkPipelineMultisampleStateCreateInfo;
public:
    S_PipelineMultisampleStateCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineMultisampleStateCreateInfo(
        VkPipelineMultisampleStateCreateFlags flags_= { },
        F_SampleCount rasterizationSamples_= { },
        VkBool32 sampleShadingEnable_= { },
        float minSampleShading_= { },
        Aptr<VkSampleMask> pSampleMask_= { },
        VkBool32 alphaToCoverageEnable_= { },
        VkBool32 alphaToOneEnable_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
        nullptr,
        flags_,
        rasterizationSamples_,
        sampleShadingEnable_,
        minSampleShading_,
        pSampleMask_,
        alphaToCoverageEnable_,
        alphaToOneEnable_
    } { }
    S_PipelineMultisampleStateCreateInfo& set_next(N_PipelineMultisampleStateCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_PipelineMultisampleStateCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineMultisampleStateCreateInfo*() { return this; }
    inL operator S_PipelineMultisampleStateCreateInfo const* () const { return const_cast<S_PipelineMultisampleStateCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkPipelineMultisampleStateCreateInfo> { using T = S_PipelineMultisampleStateCreateInfo; };
struct S_PhysicalDeviceVertexAttributeDivisorPropertiesEXT : public VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT;
public:
    S_PhysicalDeviceVertexAttributeDivisorPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceVertexAttributeDivisorPropertiesEXT(
        uint32_t maxVertexAttribDivisor_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
        nullptr,
        maxVertexAttribDivisor_
    } { }
    inL S_PhysicalDeviceVertexAttributeDivisorPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceVertexAttributeDivisorPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceVertexAttributeDivisorPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceVertexAttributeDivisorPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT> { using T = S_PhysicalDeviceVertexAttributeDivisorPropertiesEXT; };
struct S_PastPresentationTimingGOOGLE : public VkPastPresentationTimingGOOGLE {
public:
    using Otype = VkPastPresentationTimingGOOGLE;
public:
    S_PastPresentationTimingGOOGLE(Otype& origin_obj_):Otype(origin_obj_){}
    S_PastPresentationTimingGOOGLE(
        uint32_t presentID_= { },
        uint64_t desiredPresentTime_= { },
        uint64_t actualPresentTime_= { },
        uint64_t earliestPresentTime_= { },
        uint64_t presentMargin_= { }
    ) : Otype{
        presentID_,
        desiredPresentTime_,
        actualPresentTime_,
        earliestPresentTime_,
        presentMargin_
    } { }
    inL S_PastPresentationTimingGOOGLE& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PastPresentationTimingGOOGLE*() { return this; }
    inL operator S_PastPresentationTimingGOOGLE const* () const { return const_cast<S_PastPresentationTimingGOOGLE const*>(this); }
};
template<> struct detail::names_map<VkPastPresentationTimingGOOGLE> { using T = S_PastPresentationTimingGOOGLE; };
struct S_PushConstantRange : public VkPushConstantRange {
public:
    using Otype = VkPushConstantRange;
public:
    S_PushConstantRange(Otype& origin_obj_):Otype(origin_obj_){}
    S_PushConstantRange(
        VkShaderStageFlags stageFlags_= { },
        uint32_t offset_= { },
        uint32_t size_= { }
    ) : Otype{
        stageFlags_,
        offset_,
        size_
    } { }
    inL S_PushConstantRange& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PushConstantRange*() { return this; }
    inL operator S_PushConstantRange const* () const { return const_cast<S_PushConstantRange const*>(this); }
};
template<> struct detail::names_map<VkPushConstantRange> { using T = S_PushConstantRange; };
struct S_PipelineLayoutCreateInfo : public VkPipelineLayoutCreateInfo {
public:
    using Otype = VkPipelineLayoutCreateInfo;
public:
    S_PipelineLayoutCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineLayoutCreateInfo(
        VkPipelineLayoutCreateFlags flags_= { },
        Array_general<VkDescriptorSetLayout> pSetLayouts_= { },
        Array_general<S_PushConstantRange> pPushConstantRanges_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
        nullptr,
        flags_,
        pSetLayouts_.size(),
        reinterpret_cast<VkDescriptorSetLayout*>(pSetLayouts_.data()),
        pPushConstantRanges_.size(),
        reinterpret_cast<VkPushConstantRange*>(pPushConstantRanges_.data())
    } { }
    inL S_PipelineLayoutCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineLayoutCreateInfo*() { return this; }
    inL operator S_PipelineLayoutCreateInfo const* () const { return const_cast<S_PipelineLayoutCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkPipelineLayoutCreateInfo> { using T = S_PipelineLayoutCreateInfo; };
struct S_SubpassBeginInfoKHR : public VkSubpassBeginInfoKHR {
public:
    using Otype = VkSubpassBeginInfoKHR;
public:
    S_SubpassBeginInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SubpassBeginInfoKHR(
        E_SubpassContents contents_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR,
        nullptr,
        contents_
    } { }
    inL S_SubpassBeginInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SubpassBeginInfoKHR*() { return this; }
    inL operator S_SubpassBeginInfoKHR const* () const { return const_cast<S_SubpassBeginInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkSubpassBeginInfoKHR> { using T = S_SubpassBeginInfoKHR; };
struct S_StencilOpState : public VkStencilOpState {
public:
    using Otype = VkStencilOpState;
public:
    S_StencilOpState(Otype& origin_obj_):Otype(origin_obj_){}
    S_StencilOpState(
        E_StencilOp failOp_         = { },
        E_StencilOp passOp_         = { },
        E_StencilOp depthFailOp_        = { },
        E_CompareOp compareOp_      = { },
        uint32_t    compareMask_         = { },
        uint32_t    writeMask_      = { },
        uint32_t    reference_      = { }
    ) : Otype{
        failOp_,
        passOp_,
        depthFailOp_,
        compareOp_,
        compareMask_,
        writeMask_,
        reference_
    } { }
    inL S_StencilOpState& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_StencilOpState*() { return this; }
    inL operator S_StencilOpState const* () const { return const_cast<S_StencilOpState const*>(this); }
};
template<> struct detail::names_map<VkStencilOpState> { using T = S_StencilOpState; };
struct S_PipelineDepthStencilStateCreateInfo : public VkPipelineDepthStencilStateCreateInfo {
public:
    using Otype = VkPipelineDepthStencilStateCreateInfo;
public:
    S_PipelineDepthStencilStateCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineDepthStencilStateCreateInfo(
        VkPipelineDepthStencilStateCreateFlags flags_= { },
        VkBool32 depthTestEnable_= { },
        VkBool32 depthWriteEnable_= { },
        E_CompareOp depthCompareOp_= { },
        VkBool32 depthBoundsTestEnable_= { },
        VkBool32 stencilTestEnable_= { },
        S_StencilOpState front_= { },
        S_StencilOpState back_= { },
        float minDepthBounds_= { },
        float maxDepthBounds_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
        nullptr,
        flags_,
        depthTestEnable_,
        depthWriteEnable_,
        depthCompareOp_,
        depthBoundsTestEnable_,
        stencilTestEnable_,
        front_,
        back_,
        minDepthBounds_,
        maxDepthBounds_
    } { }
    inL S_PipelineDepthStencilStateCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineDepthStencilStateCreateInfo*() { return this; }
    inL operator S_PipelineDepthStencilStateCreateInfo const* () const { return const_cast<S_PipelineDepthStencilStateCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkPipelineDepthStencilStateCreateInfo> { using T = S_PipelineDepthStencilStateCreateInfo; };
struct S_RenderPassFragmentDensityMapCreateInfoEXT : public VkRenderPassFragmentDensityMapCreateInfoEXT {
public:
    using Otype = VkRenderPassFragmentDensityMapCreateInfoEXT;
public:
    S_RenderPassFragmentDensityMapCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_RenderPassFragmentDensityMapCreateInfoEXT(
        S_AttachmentReference fragmentDensityMapAttachment_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
        nullptr,
        fragmentDensityMapAttachment_
    } { }
    inL S_RenderPassFragmentDensityMapCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_RenderPassFragmentDensityMapCreateInfoEXT*() { return this; }
    inL operator S_RenderPassFragmentDensityMapCreateInfoEXT const* () const { return const_cast<S_RenderPassFragmentDensityMapCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkRenderPassFragmentDensityMapCreateInfoEXT> { using T = S_RenderPassFragmentDensityMapCreateInfoEXT; };
struct S_ImageViewUsageCreateInfo : public VkImageViewUsageCreateInfo {
public:
    using Otype = VkImageViewUsageCreateInfo;
public:
    S_ImageViewUsageCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageViewUsageCreateInfo(
        VkImageUsageFlags usage_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
        nullptr,
        usage_
    } { }
    inL S_ImageViewUsageCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageViewUsageCreateInfo*() { return this; }
    inL operator S_ImageViewUsageCreateInfo const* () const { return const_cast<S_ImageViewUsageCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkImageViewUsageCreateInfo> { using T = S_ImageViewUsageCreateInfo; };
struct S_ImageViewASTCDecodeModeEXT : public VkImageViewASTCDecodeModeEXT {
public:
    using Otype = VkImageViewASTCDecodeModeEXT;
public:
    S_ImageViewASTCDecodeModeEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageViewASTCDecodeModeEXT(
        E_Format decodeMode_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
        nullptr,
        decodeMode_
    } { }
    inL S_ImageViewASTCDecodeModeEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageViewASTCDecodeModeEXT*() { return this; }
    inL operator S_ImageViewASTCDecodeModeEXT const* () const { return const_cast<S_ImageViewASTCDecodeModeEXT const*>(this); }
};
template<> struct detail::names_map<VkImageViewASTCDecodeModeEXT> { using T = S_ImageViewASTCDecodeModeEXT; };
struct N_ImageViewCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_ImageViewCreateInfo& n_VkSamplerYcbcrConversionInfo(Aref<S_SamplerYcbcrConversionInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_ImageViewCreateInfo& n_VkImageViewUsageCreateInfo(Aref<S_ImageViewUsageCreateInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_ImageViewCreateInfo& n_VkImageViewASTCDecodeModeEXT(Aref<S_ImageViewASTCDecodeModeEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_ImageViewCreateInfo : public VkImageViewCreateInfo {
public:
    using Otype = VkImageViewCreateInfo;
public:
    S_ImageViewCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageViewCreateInfo(
        VkImageViewCreateFlags flags_= { },
        VkImage image_= { },
        E_ImageViewType viewType_= { },
        E_Format format_= { },
        S_ComponentMapping components_= { },
        S_ImageSubresourceRange subresourceRange_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
        nullptr,
        flags_,
        image_,
        viewType_,
        format_,
        components_,
        subresourceRange_
    } { }
    S_ImageViewCreateInfo& set_next(N_ImageViewCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_ImageViewCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageViewCreateInfo*() { return this; }
    inL operator S_ImageViewCreateInfo const* () const { return const_cast<S_ImageViewCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkImageViewCreateInfo> { using T = S_ImageViewCreateInfo; };
struct S_PhysicalDeviceImageDrmFormatModifierInfoEXT : public VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
public:
    using Otype = VkPhysicalDeviceImageDrmFormatModifierInfoEXT;
public:
    S_PhysicalDeviceImageDrmFormatModifierInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceImageDrmFormatModifierInfoEXT(
        uint64_t drmFormatModifier_= { },
        E_SharingMode sharingMode_= { },
        Array_general<uint32_t> pQueueFamilyIndices_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
        nullptr,
        drmFormatModifier_,
        sharingMode_,
        pQueueFamilyIndices_.size(),
        reinterpret_cast<uint32_t*>(pQueueFamilyIndices_.data())
    } { }
    inL S_PhysicalDeviceImageDrmFormatModifierInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceImageDrmFormatModifierInfoEXT*() { return this; }
    inL operator S_PhysicalDeviceImageDrmFormatModifierInfoEXT const* () const { return const_cast<S_PhysicalDeviceImageDrmFormatModifierInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceImageDrmFormatModifierInfoEXT> { using T = S_PhysicalDeviceImageDrmFormatModifierInfoEXT; };
struct S_DebugUtilsLabelEXT : public VkDebugUtilsLabelEXT {
public:
    using Otype = VkDebugUtilsLabelEXT;
public:
    S_DebugUtilsLabelEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DebugUtilsLabelEXT(
        Aptr<char> pLabelName_= { },
        std::array<float,4> color_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
        nullptr,
        pLabelName_,
        { }
    } { 
        ::memcpy(&color[0], color_.data(), color_.size() );
    }
    inL S_DebugUtilsLabelEXT& 
        set_color(std::array<float,4> color_)
        {  return *this; }
    inL S_DebugUtilsLabelEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DebugUtilsLabelEXT*() { return this; }
    inL operator S_DebugUtilsLabelEXT const* () const { return const_cast<S_DebugUtilsLabelEXT const*>(this); }
};
template<> struct detail::names_map<VkDebugUtilsLabelEXT> { using T = S_DebugUtilsLabelEXT; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_Win32SurfaceCreateInfoKHR : public VkWin32SurfaceCreateInfoKHR {
public:
    using Otype = VkWin32SurfaceCreateInfoKHR;
public:
    S_Win32SurfaceCreateInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_Win32SurfaceCreateInfoKHR(
        VkWin32SurfaceCreateFlagsKHR flags_= { },
        HINSTANCE hinstance_= { },
        HWND hwnd_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR,
        nullptr,
        flags_,
        hinstance_,
        hwnd_
    } { }
    inL S_Win32SurfaceCreateInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_Win32SurfaceCreateInfoKHR*() { return this; }
    inL operator S_Win32SurfaceCreateInfoKHR const* () const { return const_cast<S_Win32SurfaceCreateInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkWin32SurfaceCreateInfoKHR> { using T = S_Win32SurfaceCreateInfoKHR; };

#endif
struct S_InitializePerformanceApiInfoINTEL : public VkInitializePerformanceApiInfoINTEL {
public:
    using Otype = VkInitializePerformanceApiInfoINTEL;
public:
    S_InitializePerformanceApiInfoINTEL(Otype& origin_obj_):Otype(origin_obj_){}
    S_InitializePerformanceApiInfoINTEL(
        Aptr<void> pUserData_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL,
        nullptr,
        pUserData_
    } { }
    inL S_InitializePerformanceApiInfoINTEL& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_InitializePerformanceApiInfoINTEL*() { return this; }
    inL operator S_InitializePerformanceApiInfoINTEL const* () const { return const_cast<S_InitializePerformanceApiInfoINTEL const*>(this); }
};
template<> struct detail::names_map<VkInitializePerformanceApiInfoINTEL> { using T = S_InitializePerformanceApiInfoINTEL; };
struct S_PipelineInfoKHR : public VkPipelineInfoKHR {
public:
    using Otype = VkPipelineInfoKHR;
public:
    S_PipelineInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineInfoKHR(
        VkPipeline pipeline_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR,
        nullptr,
        pipeline_
    } { }
    inL S_PipelineInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineInfoKHR*() { return this; }
    inL operator S_PipelineInfoKHR const* () const { return const_cast<S_PipelineInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkPipelineInfoKHR> { using T = S_PipelineInfoKHR; };
struct S_PipelineCacheCreateInfo : public VkPipelineCacheCreateInfo {
public:
    using Otype = VkPipelineCacheCreateInfo;
public:
    S_PipelineCacheCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineCacheCreateInfo(
        VkPipelineCacheCreateFlags flags_= { },
        Array_general<void> pInitialData_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO,
        nullptr,
        flags_,
        pInitialData_.size(),
        reinterpret_cast<void*>(pInitialData_.data())
    } { }
    inL S_PipelineCacheCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineCacheCreateInfo*() { return this; }
    inL operator S_PipelineCacheCreateInfo const* () const { return const_cast<S_PipelineCacheCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkPipelineCacheCreateInfo> { using T = S_PipelineCacheCreateInfo; };
struct S_ClearRect : public VkClearRect {
public:
    using Otype = VkClearRect;
public:
    S_ClearRect(Otype& origin_obj_):Otype(origin_obj_){}
    S_ClearRect(
        S_Rect2D rect_= { },
        uint32_t baseArrayLayer_= { },
        uint32_t layerCount_= { }
    ) : Otype{
        rect_,
        baseArrayLayer_,
        layerCount_
    } { }
    inL S_ClearRect& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ClearRect*() { return this; }
    inL operator S_ClearRect const* () const { return const_cast<S_ClearRect const*>(this); }
};
template<> struct detail::names_map<VkClearRect> { using T = S_ClearRect; };
struct S_DeviceGroupSwapchainCreateInfoKHR : public VkDeviceGroupSwapchainCreateInfoKHR {
public:
    using Otype = VkDeviceGroupSwapchainCreateInfoKHR;
public:
    S_DeviceGroupSwapchainCreateInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceGroupSwapchainCreateInfoKHR(
        VkDeviceGroupPresentModeFlagsKHR modes_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
        nullptr,
        modes_
    } { }
    inL S_DeviceGroupSwapchainCreateInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceGroupSwapchainCreateInfoKHR*() { return this; }
    inL operator S_DeviceGroupSwapchainCreateInfoKHR const* () const { return const_cast<S_DeviceGroupSwapchainCreateInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkDeviceGroupSwapchainCreateInfoKHR> { using T = S_DeviceGroupSwapchainCreateInfoKHR; };
struct S_AttachmentDescription2KHR : public VkAttachmentDescription2KHR {
public:
    using Otype = VkAttachmentDescription2KHR;
public:
    S_AttachmentDescription2KHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_AttachmentDescription2KHR(
        VkAttachmentDescriptionFlags flags_= { },
        E_Format format_= { },
        F_SampleCount samples_= { },
        E_AttachmentLoadOp loadOp_= { },
        E_AttachmentStoreOp storeOp_= { },
        E_AttachmentLoadOp stencilLoadOp_= { },
        E_AttachmentStoreOp stencilStoreOp_= { },
        E_ImageLayout initialLayout_= { },
        E_ImageLayout finalLayout_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR,
        nullptr,
        flags_,
        format_,
        samples_,
        loadOp_,
        storeOp_,
        stencilLoadOp_,
        stencilStoreOp_,
        initialLayout_,
        finalLayout_
    } { }
    inL S_AttachmentDescription2KHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AttachmentDescription2KHR*() { return this; }
    inL operator S_AttachmentDescription2KHR const* () const { return const_cast<S_AttachmentDescription2KHR const*>(this); }
};
template<> struct detail::names_map<VkAttachmentDescription2KHR> { using T = S_AttachmentDescription2KHR; };
struct S_DescriptorSetLayoutBinding : public VkDescriptorSetLayoutBinding {
public:
    using Otype = VkDescriptorSetLayoutBinding;
public:
    S_DescriptorSetLayoutBinding(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorSetLayoutBinding(
        uint32_t binding_= { },
        E_DescriptorType descriptorType_= { },
        VkShaderStageFlags stageFlags_= { },
        Array_general<VkSampler> pImmutableSamplers_= { }
    ) : Otype{
        binding_,
        descriptorType_,
        pImmutableSamplers_.size(),
        stageFlags_,
        reinterpret_cast<VkSampler*>(pImmutableSamplers_.data())
    } { }
    inL S_DescriptorSetLayoutBinding& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorSetLayoutBinding*() { return this; }
    inL operator S_DescriptorSetLayoutBinding const* () const { return const_cast<S_DescriptorSetLayoutBinding const*>(this); }
};
template<> struct detail::names_map<VkDescriptorSetLayoutBinding> { using T = S_DescriptorSetLayoutBinding; };
struct S_DisplayPlaneCapabilities2KHR : public VkDisplayPlaneCapabilities2KHR {
public:
    using Otype = VkDisplayPlaneCapabilities2KHR;
public:
    S_DisplayPlaneCapabilities2KHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayPlaneCapabilities2KHR(
        S_DisplayPlaneCapabilitiesKHR capabilities_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR,
        nullptr,
        capabilities_
    } { }
    inL S_DisplayPlaneCapabilities2KHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayPlaneCapabilities2KHR*() { return this; }
    inL operator S_DisplayPlaneCapabilities2KHR const* () const { return const_cast<S_DisplayPlaneCapabilities2KHR const*>(this); }
};
template<> struct detail::names_map<VkDisplayPlaneCapabilities2KHR> { using T = S_DisplayPlaneCapabilities2KHR; };
struct S_RenderPassSampleLocationsBeginInfoEXT : public VkRenderPassSampleLocationsBeginInfoEXT {
public:
    using Otype = VkRenderPassSampleLocationsBeginInfoEXT;
public:
    S_RenderPassSampleLocationsBeginInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_RenderPassSampleLocationsBeginInfoEXT(
        Array_general<S_AttachmentSampleLocationsEXT> pAttachmentInitialSampleLocations_= { },
        Array_general<S_SubpassSampleLocationsEXT> pPostSubpassSampleLocations_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
        nullptr,
        pAttachmentInitialSampleLocations_.size(),
        reinterpret_cast<VkAttachmentSampleLocationsEXT*>(pAttachmentInitialSampleLocations_.data()),
        pPostSubpassSampleLocations_.size(),
        reinterpret_cast<VkSubpassSampleLocationsEXT*>(pPostSubpassSampleLocations_.data())
    } { }
    inL S_RenderPassSampleLocationsBeginInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_RenderPassSampleLocationsBeginInfoEXT*() { return this; }
    inL operator S_RenderPassSampleLocationsBeginInfoEXT const* () const { return const_cast<S_RenderPassSampleLocationsBeginInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkRenderPassSampleLocationsBeginInfoEXT> { using T = S_RenderPassSampleLocationsBeginInfoEXT; };
struct S_SparseImageOpaqueMemoryBindInfo : public VkSparseImageOpaqueMemoryBindInfo {
public:
    using Otype = VkSparseImageOpaqueMemoryBindInfo;
public:
    S_SparseImageOpaqueMemoryBindInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_SparseImageOpaqueMemoryBindInfo(
        VkImage image_= { },
        Array_general<S_SparseMemoryBind> pBinds_= { }
    ) : Otype{
        image_,
        pBinds_.size(),
        reinterpret_cast<VkSparseMemoryBind*>(pBinds_.data())
    } { }
    inL S_SparseImageOpaqueMemoryBindInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SparseImageOpaqueMemoryBindInfo*() { return this; }
    inL operator S_SparseImageOpaqueMemoryBindInfo const* () const { return const_cast<S_SparseImageOpaqueMemoryBindInfo const*>(this); }
};
template<> struct detail::names_map<VkSparseImageOpaqueMemoryBindInfo> { using T = S_SparseImageOpaqueMemoryBindInfo; };
struct S_DisplayModePropertiesKHR : public VkDisplayModePropertiesKHR {
public:
    using Otype = VkDisplayModePropertiesKHR;
public:
    S_DisplayModePropertiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayModePropertiesKHR(
        VkDisplayModeKHR displayMode_= { },
        S_DisplayModeParametersKHR parameters_= { }
    ) : Otype{
        displayMode_,
        parameters_
    } { }
    inL S_DisplayModePropertiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayModePropertiesKHR*() { return this; }
    inL operator S_DisplayModePropertiesKHR const* () const { return const_cast<S_DisplayModePropertiesKHR const*>(this); }
};
template<> struct detail::names_map<VkDisplayModePropertiesKHR> { using T = S_DisplayModePropertiesKHR; };
struct S_PipelineRepresentativeFragmentTestStateCreateInfoNV : public VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
public:
    using Otype = VkPipelineRepresentativeFragmentTestStateCreateInfoNV;
public:
    S_PipelineRepresentativeFragmentTestStateCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineRepresentativeFragmentTestStateCreateInfoNV(
        VkBool32 representativeFragmentTestEnable_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
        nullptr,
        representativeFragmentTestEnable_
    } { }
    inL S_PipelineRepresentativeFragmentTestStateCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineRepresentativeFragmentTestStateCreateInfoNV*() { return this; }
    inL operator S_PipelineRepresentativeFragmentTestStateCreateInfoNV const* () const { return const_cast<S_PipelineRepresentativeFragmentTestStateCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkPipelineRepresentativeFragmentTestStateCreateInfoNV> { using T = S_PipelineRepresentativeFragmentTestStateCreateInfoNV; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_SurfaceFullScreenExclusiveWin32InfoEXT : public VkSurfaceFullScreenExclusiveWin32InfoEXT {
public:
    using Otype = VkSurfaceFullScreenExclusiveWin32InfoEXT;
public:
    S_SurfaceFullScreenExclusiveWin32InfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_SurfaceFullScreenExclusiveWin32InfoEXT(
        HMONITOR hmonitor_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT,
        nullptr,
        hmonitor_
    } { }
    inL S_SurfaceFullScreenExclusiveWin32InfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SurfaceFullScreenExclusiveWin32InfoEXT*() { return this; }
    inL operator S_SurfaceFullScreenExclusiveWin32InfoEXT const* () const { return const_cast<S_SurfaceFullScreenExclusiveWin32InfoEXT const*>(this); }
};
template<> struct detail::names_map<VkSurfaceFullScreenExclusiveWin32InfoEXT> { using T = S_SurfaceFullScreenExclusiveWin32InfoEXT; };

#endif

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_SurfaceFullScreenExclusiveInfoEXT : public VkSurfaceFullScreenExclusiveInfoEXT {
public:
    using Otype = VkSurfaceFullScreenExclusiveInfoEXT;
public:
    S_SurfaceFullScreenExclusiveInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_SurfaceFullScreenExclusiveInfoEXT(
        E_FullScreenExclusiveEXT fullScreenExclusive_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT,
        nullptr,
        fullScreenExclusive_
    } { }
    inL S_SurfaceFullScreenExclusiveInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SurfaceFullScreenExclusiveInfoEXT*() { return this; }
    inL operator S_SurfaceFullScreenExclusiveInfoEXT const* () const { return const_cast<S_SurfaceFullScreenExclusiveInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkSurfaceFullScreenExclusiveInfoEXT> { using T = S_SurfaceFullScreenExclusiveInfoEXT; };

#endif
struct N_SwapchainCreateInfoKHR{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_SwapchainCreateInfoKHR& n_VkImageFormatListCreateInfoKHR(Aref<S_ImageFormatListCreateInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_SwapchainCreateInfoKHR& n_VkDeviceGroupSwapchainCreateInfoKHR(Aref<S_DeviceGroupSwapchainCreateInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_SwapchainCreateInfoKHR& n_VkSwapchainDisplayNativeHdrCreateInfoAMD(Aref<S_SwapchainDisplayNativeHdrCreateInfoAMD> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_SwapchainCreateInfoKHR& n_VkSurfaceFullScreenExclusiveWin32InfoEXT(Aref<S_SurfaceFullScreenExclusiveWin32InfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    inL N_SwapchainCreateInfoKHR& n_VkSwapchainCounterCreateInfoEXT(Aref<S_SwapchainCounterCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_SwapchainCreateInfoKHR& n_VkSurfaceFullScreenExclusiveInfoEXT(Aref<S_SurfaceFullScreenExclusiveInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
};
struct S_SwapchainCreateInfoKHR : public VkSwapchainCreateInfoKHR {
public:
    using Otype = VkSwapchainCreateInfoKHR;
public:
    S_SwapchainCreateInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SwapchainCreateInfoKHR(
        VkSwapchainCreateFlagsKHR flags_= { },
        VkSurfaceKHR surface_= { },
        uint32_t minImageCount_= { },
        E_Format imageFormat_= { },
        E_ColorSpaceKHR imageColorSpace_= { },
        S_Extent2D imageExtent_= { },
        uint32_t imageArrayLayers_= { },
        VkImageUsageFlags imageUsage_= { },
        E_SharingMode imageSharingMode_= { },
        Array_general<uint32_t> pQueueFamilyIndices_= { },
        F_SurfaceTransformKHR preTransform_= { },
        F_CompositeAlphaKHR compositeAlpha_= { },
        E_PresentModeKHR presentMode_= { },
        VkBool32 clipped_= { },
        VkSwapchainKHR oldSwapchain_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
        nullptr,
        flags_,
        surface_,
        minImageCount_,
        imageFormat_,
        imageColorSpace_,
        imageExtent_,
        imageArrayLayers_,
        imageUsage_,
        imageSharingMode_,
        pQueueFamilyIndices_.size(),
        reinterpret_cast<uint32_t*>(pQueueFamilyIndices_.data()),
        preTransform_,
        compositeAlpha_,
        presentMode_,
        clipped_,
        oldSwapchain_
    } { }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_SwapchainCreateInfoKHR& n_VkSurfaceFullScreenExclusiveWin32InfoEXT(Aref<S_SurfaceFullScreenExclusiveWin32InfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_SwapchainCreateInfoKHR& n_VkSurfaceFullScreenExclusiveInfoEXT(Aref<S_SurfaceFullScreenExclusiveInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    S_SwapchainCreateInfoKHR& set_next(N_SwapchainCreateInfoKHR& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_SwapchainCreateInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SwapchainCreateInfoKHR*() { return this; }
    inL operator S_SwapchainCreateInfoKHR const* () const { return const_cast<S_SwapchainCreateInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkSwapchainCreateInfoKHR> { using T = S_SwapchainCreateInfoKHR; };
struct S_ObjectTableCreateInfoNVX : public VkObjectTableCreateInfoNVX {
public:
    using Otype = VkObjectTableCreateInfoNVX;
public:
    S_ObjectTableCreateInfoNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_ObjectTableCreateInfoNVX(
        Array_general<E_ObjectEntryTypeNVX> pObjectEntryTypes_= { },
        Array_general<uint32_t> pObjectEntryCounts_= { },
        Array_general<VkObjectEntryUsageFlagsNVX> pObjectEntryUsageFlags_= { },
        uint32_t maxUniformBuffersPerDescriptor_= { },
        uint32_t maxStorageBuffersPerDescriptor_= { },
        uint32_t maxStorageImagesPerDescriptor_= { },
        uint32_t maxSampledImagesPerDescriptor_= { },
        uint32_t maxPipelineLayouts_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX,
        nullptr,
        pObjectEntryTypes_.size(),
        reinterpret_cast<VkObjectEntryTypeNVX*>(pObjectEntryTypes_.data()),
        reinterpret_cast<uint32_t*>(pObjectEntryCounts_.data()),
        reinterpret_cast<VkObjectEntryUsageFlagsNVX*>(pObjectEntryUsageFlags_.data()),
        maxUniformBuffersPerDescriptor_,
        maxStorageBuffersPerDescriptor_,
        maxStorageImagesPerDescriptor_,
        maxSampledImagesPerDescriptor_,
        maxPipelineLayouts_
    } { }
    inL S_ObjectTableCreateInfoNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ObjectTableCreateInfoNVX*() { return this; }
    inL operator S_ObjectTableCreateInfoNVX const* () const { return const_cast<S_ObjectTableCreateInfoNVX const*>(this); }
};
template<> struct detail::names_map<VkObjectTableCreateInfoNVX> { using T = S_ObjectTableCreateInfoNVX; };
struct S_SubpassDependency : public VkSubpassDependency {
public:
    using Otype = VkSubpassDependency;
public:
    S_SubpassDependency(Otype& origin_obj_):Otype(origin_obj_){}
    S_SubpassDependency(
        uint32_t srcSubpass_= { },
        uint32_t dstSubpass_= { },
        VkPipelineStageFlags srcStageMask_= { },
        VkPipelineStageFlags dstStageMask_= { },
        VkAccessFlags srcAccessMask_= { },
        VkAccessFlags dstAccessMask_= { },
        VkDependencyFlags dependencyFlags_= { }
    ) : Otype{
        srcSubpass_,
        dstSubpass_,
        srcStageMask_,
        dstStageMask_,
        srcAccessMask_,
        dstAccessMask_,
        dependencyFlags_
    } { }
    inL S_SubpassDependency& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SubpassDependency*() { return this; }
    inL operator S_SubpassDependency const* () const { return const_cast<S_SubpassDependency const*>(this); }
};
template<> struct detail::names_map<VkSubpassDependency> { using T = S_SubpassDependency; };
struct S_RenderPassMultiviewCreateInfo : public VkRenderPassMultiviewCreateInfo {
public:
    using Otype = VkRenderPassMultiviewCreateInfo;
public:
    S_RenderPassMultiviewCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_RenderPassMultiviewCreateInfo(
        Array_general<uint32_t> pViewMasks_= { },
        Array_general<int32_t> pViewOffsets_= { },
        Array_general<uint32_t> pCorrelationMasks_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
        nullptr,
        pViewMasks_.size(),
        reinterpret_cast<uint32_t*>(pViewMasks_.data()),
        pViewOffsets_.size(),
        reinterpret_cast<int32_t*>(pViewOffsets_.data()),
        pCorrelationMasks_.size(),
        reinterpret_cast<uint32_t*>(pCorrelationMasks_.data())
    } { }
    inL S_RenderPassMultiviewCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_RenderPassMultiviewCreateInfo*() { return this; }
    inL operator S_RenderPassMultiviewCreateInfo const* () const { return const_cast<S_RenderPassMultiviewCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkRenderPassMultiviewCreateInfo> { using T = S_RenderPassMultiviewCreateInfo; };
struct S_AcquireNextImageInfoKHR : public VkAcquireNextImageInfoKHR {
public:
    using Otype = VkAcquireNextImageInfoKHR;
public:
    S_AcquireNextImageInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_AcquireNextImageInfoKHR(
        VkSwapchainKHR swapchain_= { },
        uint64_t timeout_= { },
        VkSemaphore semaphore_= { },
        VkFence fence_= { },
        uint32_t deviceMask_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR,
        nullptr,
        swapchain_,
        timeout_,
        semaphore_,
        fence_,
        deviceMask_
    } { }
    inL S_AcquireNextImageInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AcquireNextImageInfoKHR*() { return this; }
    inL operator S_AcquireNextImageInfoKHR const* () const { return const_cast<S_AcquireNextImageInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkAcquireNextImageInfoKHR> { using T = S_AcquireNextImageInfoKHR; };
struct S_QueryPoolCreateInfoINTEL : public VkQueryPoolCreateInfoINTEL {
public:
    using Otype = VkQueryPoolCreateInfoINTEL;
public:
    S_QueryPoolCreateInfoINTEL(Otype& origin_obj_):Otype(origin_obj_){}
    S_QueryPoolCreateInfoINTEL(
        E_QueryPoolSamplingModeINTEL performanceCountersSampling_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL,
        nullptr,
        performanceCountersSampling_
    } { }
    inL S_QueryPoolCreateInfoINTEL& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_QueryPoolCreateInfoINTEL*() { return this; }
    inL operator S_QueryPoolCreateInfoINTEL const* () const { return const_cast<S_QueryPoolCreateInfoINTEL const*>(this); }
};
template<> struct detail::names_map<VkQueryPoolCreateInfoINTEL> { using T = S_QueryPoolCreateInfoINTEL; };
struct S_XYColorEXT : public VkXYColorEXT {
public:
    using Otype = VkXYColorEXT;
public:
    S_XYColorEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_XYColorEXT(
        float x_= { },
        float y_= { }
    ) : Otype{
        x_,
        y_
    } { }
    inL S_XYColorEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_XYColorEXT*() { return this; }
    inL operator S_XYColorEXT const* () const { return const_cast<S_XYColorEXT const*>(this); }
};
template<> struct detail::names_map<VkXYColorEXT> { using T = S_XYColorEXT; };
struct S_HdrMetadataEXT : public VkHdrMetadataEXT {
public:
    using Otype = VkHdrMetadataEXT;
public:
    S_HdrMetadataEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_HdrMetadataEXT(
        S_XYColorEXT displayPrimaryRed_= { },
        S_XYColorEXT displayPrimaryGreen_= { },
        S_XYColorEXT displayPrimaryBlue_= { },
        S_XYColorEXT whitePoint_= { },
        float maxLuminance_= { },
        float minLuminance_= { },
        float maxContentLightLevel_= { },
        float maxFrameAverageLightLevel_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_HDR_METADATA_EXT,
        nullptr,
        displayPrimaryRed_,
        displayPrimaryGreen_,
        displayPrimaryBlue_,
        whitePoint_,
        maxLuminance_,
        minLuminance_,
        maxContentLightLevel_,
        maxFrameAverageLightLevel_
    } { }
    inL S_HdrMetadataEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_HdrMetadataEXT*() { return this; }
    inL operator S_HdrMetadataEXT const* () const { return const_cast<S_HdrMetadataEXT const*>(this); }
};
template<> struct detail::names_map<VkHdrMetadataEXT> { using T = S_HdrMetadataEXT; };
struct S_DescriptorSetVariableDescriptorCountLayoutSupportEXT : public VkDescriptorSetVariableDescriptorCountLayoutSupportEXT {
public:
    using Otype = VkDescriptorSetVariableDescriptorCountLayoutSupportEXT;
public:
    S_DescriptorSetVariableDescriptorCountLayoutSupportEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorSetVariableDescriptorCountLayoutSupportEXT(
        uint32_t maxVariableDescriptorCount_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT,
        nullptr,
        maxVariableDescriptorCount_
    } { }
    inL S_DescriptorSetVariableDescriptorCountLayoutSupportEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorSetVariableDescriptorCountLayoutSupportEXT*() { return this; }
    inL operator S_DescriptorSetVariableDescriptorCountLayoutSupportEXT const* () const { return const_cast<S_DescriptorSetVariableDescriptorCountLayoutSupportEXT const*>(this); }
};
template<> struct detail::names_map<VkDescriptorSetVariableDescriptorCountLayoutSupportEXT> { using T = S_DescriptorSetVariableDescriptorCountLayoutSupportEXT; };
struct N_DescriptorSetLayoutSupport{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_DescriptorSetLayoutSupport& n_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(Aref<S_DescriptorSetVariableDescriptorCountLayoutSupportEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_DescriptorSetLayoutSupport : public VkDescriptorSetLayoutSupport {
public:
    using Otype = VkDescriptorSetLayoutSupport;
public:
    S_DescriptorSetLayoutSupport(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorSetLayoutSupport(
        VkBool32 supported_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
        nullptr,
        supported_
    } { }
    S_DescriptorSetLayoutSupport& set_next(N_DescriptorSetLayoutSupport& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_DescriptorSetLayoutSupport& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorSetLayoutSupport*() { return this; }
    inL operator S_DescriptorSetLayoutSupport const* () const { return const_cast<S_DescriptorSetLayoutSupport const*>(this); }
};
template<> struct detail::names_map<VkDescriptorSetLayoutSupport> { using T = S_DescriptorSetLayoutSupport; };
struct S_PhysicalDeviceInlineUniformBlockPropertiesEXT : public VkPhysicalDeviceInlineUniformBlockPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceInlineUniformBlockPropertiesEXT;
public:
    S_PhysicalDeviceInlineUniformBlockPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceInlineUniformBlockPropertiesEXT(
        uint32_t maxInlineUniformBlockSize_= { },
        uint32_t maxPerStageDescriptorInlineUniformBlocks_= { },
        uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_= { },
        uint32_t maxDescriptorSetInlineUniformBlocks_= { },
        uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT,
        nullptr,
        maxInlineUniformBlockSize_,
        maxPerStageDescriptorInlineUniformBlocks_,
        maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks_,
        maxDescriptorSetInlineUniformBlocks_,
        maxDescriptorSetUpdateAfterBindInlineUniformBlocks_
    } { }
    inL S_PhysicalDeviceInlineUniformBlockPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceInlineUniformBlockPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceInlineUniformBlockPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceInlineUniformBlockPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceInlineUniformBlockPropertiesEXT> { using T = S_PhysicalDeviceInlineUniformBlockPropertiesEXT; };
struct S_DrawIndexedIndirectCommand : public VkDrawIndexedIndirectCommand {
public:
    using Otype = VkDrawIndexedIndirectCommand;
public:
    S_DrawIndexedIndirectCommand(Otype& origin_obj_):Otype(origin_obj_){}
    S_DrawIndexedIndirectCommand(
        uint32_t indexCount_= { },
        uint32_t instanceCount_= { },
        uint32_t firstIndex_= { },
        int32_t vertexOffset_= { },
        uint32_t firstInstance_= { }
    ) : Otype{
        indexCount_,
        instanceCount_,
        firstIndex_,
        vertexOffset_,
        firstInstance_
    } { }
    inL S_DrawIndexedIndirectCommand& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DrawIndexedIndirectCommand*() { return this; }
    inL operator S_DrawIndexedIndirectCommand const* () const { return const_cast<S_DrawIndexedIndirectCommand const*>(this); }
};
template<> struct detail::names_map<VkDrawIndexedIndirectCommand> { using T = S_DrawIndexedIndirectCommand; };
struct S_FenceGetFdInfoKHR : public VkFenceGetFdInfoKHR {
public:
    using Otype = VkFenceGetFdInfoKHR;
public:
    S_FenceGetFdInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_FenceGetFdInfoKHR(
        VkFence fence_= { },
        F_ExternalFenceHandleType handleType_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR,
        nullptr,
        fence_,
        handleType_
    } { }
    inL S_FenceGetFdInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_FenceGetFdInfoKHR*() { return this; }
    inL operator S_FenceGetFdInfoKHR const* () const { return const_cast<S_FenceGetFdInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkFenceGetFdInfoKHR> { using T = S_FenceGetFdInfoKHR; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_ExportFenceWin32HandleInfoKHR : public VkExportFenceWin32HandleInfoKHR {
public:
    using Otype = VkExportFenceWin32HandleInfoKHR;
public:
    S_ExportFenceWin32HandleInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExportFenceWin32HandleInfoKHR(
        Aptr<SECURITY_ATTRIBUTES> pAttributes_= { },
        DWORD dwAccess_= { },
        LPCWSTR name_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR,
        nullptr,
        pAttributes_,
        dwAccess_,
        name_
    } { }
    inL S_ExportFenceWin32HandleInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExportFenceWin32HandleInfoKHR*() { return this; }
    inL operator S_ExportFenceWin32HandleInfoKHR const* () const { return const_cast<S_ExportFenceWin32HandleInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkExportFenceWin32HandleInfoKHR> { using T = S_ExportFenceWin32HandleInfoKHR; };

#endif
struct S_PipelineExecutableInternalRepresentationKHR : public VkPipelineExecutableInternalRepresentationKHR {
public:
    using Otype = VkPipelineExecutableInternalRepresentationKHR;
public:
    S_PipelineExecutableInternalRepresentationKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineExecutableInternalRepresentationKHR(
        std::array<char,VK_MAX_DESCRIPTION_SIZE> name_= { },
        std::array<char,VK_MAX_DESCRIPTION_SIZE> description_= { },
        VkBool32 isText_= { },
        Array_general<void> pData_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR,
        nullptr,
        { },
        { },
        isText_,
        pData_.size(),
        reinterpret_cast<void*>(pData_.data())
    } { 
        ::memcpy(&name[0], name_.data(), name_.size() );
        ::memcpy(&description[0], description_.data(), description_.size() );
    }
    inL S_PipelineExecutableInternalRepresentationKHR& 
        set_name(std::array<char,VK_MAX_DESCRIPTION_SIZE> name_)
        {  return *this; }
    inL S_PipelineExecutableInternalRepresentationKHR& 
        set_description(std::array<char,VK_MAX_DESCRIPTION_SIZE> description_)
        {  return *this; }
    inL S_PipelineExecutableInternalRepresentationKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineExecutableInternalRepresentationKHR*() { return this; }
    inL operator S_PipelineExecutableInternalRepresentationKHR const* () const { return const_cast<S_PipelineExecutableInternalRepresentationKHR const*>(this); }
};
template<> struct detail::names_map<VkPipelineExecutableInternalRepresentationKHR> { using T = S_PipelineExecutableInternalRepresentationKHR; };
struct S_RenderPassAttachmentBeginInfoKHR : public VkRenderPassAttachmentBeginInfoKHR {
public:
    using Otype = VkRenderPassAttachmentBeginInfoKHR;
public:
    S_RenderPassAttachmentBeginInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_RenderPassAttachmentBeginInfoKHR(
        Array_general<VkImageView> pAttachments_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR,
        nullptr,
        pAttachments_.size(),
        reinterpret_cast<VkImageView*>(pAttachments_.data())
    } { }
    inL S_RenderPassAttachmentBeginInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_RenderPassAttachmentBeginInfoKHR*() { return this; }
    inL operator S_RenderPassAttachmentBeginInfoKHR const* () const { return const_cast<S_RenderPassAttachmentBeginInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkRenderPassAttachmentBeginInfoKHR> { using T = S_RenderPassAttachmentBeginInfoKHR; };
struct S_PhysicalDeviceMaintenance3Properties : public VkPhysicalDeviceMaintenance3Properties {
public:
    using Otype = VkPhysicalDeviceMaintenance3Properties;
public:
    S_PhysicalDeviceMaintenance3Properties(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceMaintenance3Properties(
        uint32_t maxPerSetDescriptors_= { },
        VkDeviceSize maxMemoryAllocationSize_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
        nullptr,
        maxPerSetDescriptors_,
        maxMemoryAllocationSize_
    } { }
    inL S_PhysicalDeviceMaintenance3Properties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceMaintenance3Properties*() { return this; }
    inL operator S_PhysicalDeviceMaintenance3Properties const* () const { return const_cast<S_PhysicalDeviceMaintenance3Properties const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceMaintenance3Properties> { using T = S_PhysicalDeviceMaintenance3Properties; };

# if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct S_SwapchainImageCreateInfoANDROID : public VkSwapchainImageCreateInfoANDROID {
public:
    using Otype = VkSwapchainImageCreateInfoANDROID;
public:
    S_SwapchainImageCreateInfoANDROID(Otype& origin_obj_):Otype(origin_obj_){}
    S_SwapchainImageCreateInfoANDROID(
        VkSwapchainImageUsageFlagsANDROID usage_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID,
        nullptr,
        usage_
    } { }
    inL S_SwapchainImageCreateInfoANDROID& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SwapchainImageCreateInfoANDROID*() { return this; }
    inL operator S_SwapchainImageCreateInfoANDROID const* () const { return const_cast<S_SwapchainImageCreateInfoANDROID const*>(this); }
};
template<> struct detail::names_map<VkSwapchainImageCreateInfoANDROID> { using T = S_SwapchainImageCreateInfoANDROID; };

#endif
struct S_ClearAttachment : public VkClearAttachment {
public:
    using Otype = VkClearAttachment;
public:
    S_ClearAttachment(Otype& origin_obj_):Otype(origin_obj_){}
    S_ClearAttachment(
        VkImageAspectFlags aspectMask_= { },
        uint32_t colorAttachment_= { },
        VkClearValue clearValue_= { }
    ) : Otype{
        aspectMask_,
        colorAttachment_,
        clearValue_
    } { }
    inL S_ClearAttachment& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ClearAttachment*() { return this; }
    inL operator S_ClearAttachment const* () const { return const_cast<S_ClearAttachment const*>(this); }
};
template<> struct detail::names_map<VkClearAttachment> { using T = S_ClearAttachment; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_ImportMemoryWin32HandleInfoNV : public VkImportMemoryWin32HandleInfoNV {
public:
    using Otype = VkImportMemoryWin32HandleInfoNV;
public:
    S_ImportMemoryWin32HandleInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImportMemoryWin32HandleInfoNV(
        VkExternalMemoryHandleTypeFlagsNV handleType_= { },
        HANDLE handle_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV,
        nullptr,
        handleType_,
        handle_
    } { }
    inL S_ImportMemoryWin32HandleInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImportMemoryWin32HandleInfoNV*() { return this; }
    inL operator S_ImportMemoryWin32HandleInfoNV const* () const { return const_cast<S_ImportMemoryWin32HandleInfoNV const*>(this); }
};
template<> struct detail::names_map<VkImportMemoryWin32HandleInfoNV> { using T = S_ImportMemoryWin32HandleInfoNV; };

#endif
struct N_PhysicalDeviceImageFormatInfo2{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_PhysicalDeviceImageFormatInfo2& n_VkImageFormatListCreateInfoKHR(Aref<S_ImageFormatListCreateInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceImageFormatInfo2& n_VkPhysicalDeviceExternalImageFormatInfo(Aref<S_PhysicalDeviceExternalImageFormatInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceImageFormatInfo2& n_VkPhysicalDeviceImageViewImageFormatInfoEXT(Aref<S_PhysicalDeviceImageViewImageFormatInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceImageFormatInfo2& n_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(Aref<S_PhysicalDeviceImageDrmFormatModifierInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceImageFormatInfo2& n_VkImageStencilUsageCreateInfoEXT(Aref<S_ImageStencilUsageCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_PhysicalDeviceImageFormatInfo2 : public VkPhysicalDeviceImageFormatInfo2 {
public:
    using Otype = VkPhysicalDeviceImageFormatInfo2;
public:
    S_PhysicalDeviceImageFormatInfo2(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceImageFormatInfo2(
        E_Format format_= { },
        E_ImageType type_= { },
        E_ImageTiling tiling_= { },
        VkImageUsageFlags usage_= { },
        VkImageCreateFlags flags_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
        nullptr,
        format_,
        type_,
        tiling_,
        usage_,
        flags_
    } { }
    S_PhysicalDeviceImageFormatInfo2& set_next(N_PhysicalDeviceImageFormatInfo2& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_PhysicalDeviceImageFormatInfo2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceImageFormatInfo2*() { return this; }
    inL operator S_PhysicalDeviceImageFormatInfo2 const* () const { return const_cast<S_PhysicalDeviceImageFormatInfo2 const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceImageFormatInfo2> { using T = S_PhysicalDeviceImageFormatInfo2; };

# if defined(VK_USE_PLATFORM_WIN32_KHR)
struct S_ImportFenceWin32HandleInfoKHR : public VkImportFenceWin32HandleInfoKHR {
public:
    using Otype = VkImportFenceWin32HandleInfoKHR;
public:
    S_ImportFenceWin32HandleInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImportFenceWin32HandleInfoKHR(
        VkFence fence_= { },
        VkFenceImportFlags flags_= { },
        F_ExternalFenceHandleType handleType_= { },
        HANDLE handle_= { },
        LPCWSTR name_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR,
        nullptr,
        fence_,
        flags_,
        handleType_,
        handle_,
        name_
    } { }
    inL S_ImportFenceWin32HandleInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImportFenceWin32HandleInfoKHR*() { return this; }
    inL operator S_ImportFenceWin32HandleInfoKHR const* () const { return const_cast<S_ImportFenceWin32HandleInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkImportFenceWin32HandleInfoKHR> { using T = S_ImportFenceWin32HandleInfoKHR; };

#endif

# if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct S_NativeBufferUsage2ANDROID : public VkNativeBufferUsage2ANDROID {
public:
    using Otype = VkNativeBufferUsage2ANDROID;
public:
    S_NativeBufferUsage2ANDROID(Otype& origin_obj_):Otype(origin_obj_){}
    S_NativeBufferUsage2ANDROID(
        uint64_t consumer_= { },
        uint64_t producer_= { }
    ) : Otype{
        consumer_,
        producer_
    } { }
    inL S_NativeBufferUsage2ANDROID& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_NativeBufferUsage2ANDROID*() { return this; }
    inL operator S_NativeBufferUsage2ANDROID const* () const { return const_cast<S_NativeBufferUsage2ANDROID const*>(this); }
};
template<> struct detail::names_map<VkNativeBufferUsage2ANDROID> { using T = S_NativeBufferUsage2ANDROID; };

#endif

# if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct S_NativeBufferANDROID : public VkNativeBufferANDROID {
public:
    using Otype = VkNativeBufferANDROID;
public:
    S_NativeBufferANDROID(Otype& origin_obj_):Otype(origin_obj_){}
    S_NativeBufferANDROID(
        Aptr<void> handle_= { },
        int stride_= { },
        int format_= { },
        int usage_= { },
        S_NativeBufferUsage2ANDROID usage2_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID,
        nullptr,
        handle_,
        stride_,
        format_,
        usage_,
        usage2_
    } { }
    inL S_NativeBufferANDROID& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_NativeBufferANDROID*() { return this; }
    inL operator S_NativeBufferANDROID const* () const { return const_cast<S_NativeBufferANDROID const*>(this); }
};
template<> struct detail::names_map<VkNativeBufferANDROID> { using T = S_NativeBufferANDROID; };

#endif
struct S_ExportFenceCreateInfo : public VkExportFenceCreateInfo {
public:
    using Otype = VkExportFenceCreateInfo;
public:
    S_ExportFenceCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExportFenceCreateInfo(
        VkExternalFenceHandleTypeFlags handleTypes_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
        nullptr,
        handleTypes_
    } { }
    inL S_ExportFenceCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExportFenceCreateInfo*() { return this; }
    inL operator S_ExportFenceCreateInfo const* () const { return const_cast<S_ExportFenceCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkExportFenceCreateInfo> { using T = S_ExportFenceCreateInfo; };
struct S_PhysicalDevicePointClippingProperties : public VkPhysicalDevicePointClippingProperties {
public:
    using Otype = VkPhysicalDevicePointClippingProperties;
public:
    S_PhysicalDevicePointClippingProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDevicePointClippingProperties(
        E_PointClippingBehavior pointClippingBehavior_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
        nullptr,
        pointClippingBehavior_
    } { }
    inL S_PhysicalDevicePointClippingProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDevicePointClippingProperties*() { return this; }
    inL operator S_PhysicalDevicePointClippingProperties const* () const { return const_cast<S_PhysicalDevicePointClippingProperties const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDevicePointClippingProperties> { using T = S_PhysicalDevicePointClippingProperties; };
struct S_PhysicalDeviceShaderSMBuiltinsPropertiesNV : public VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
public:
    using Otype = VkPhysicalDeviceShaderSMBuiltinsPropertiesNV;
public:
    S_PhysicalDeviceShaderSMBuiltinsPropertiesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceShaderSMBuiltinsPropertiesNV(
        uint32_t shaderSMCount_= { },
        uint32_t shaderWarpsPerSM_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV,
        nullptr,
        shaderSMCount_,
        shaderWarpsPerSM_
    } { }
    inL S_PhysicalDeviceShaderSMBuiltinsPropertiesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceShaderSMBuiltinsPropertiesNV*() { return this; }
    inL operator S_PhysicalDeviceShaderSMBuiltinsPropertiesNV const* () const { return const_cast<S_PhysicalDeviceShaderSMBuiltinsPropertiesNV const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV> { using T = S_PhysicalDeviceShaderSMBuiltinsPropertiesNV; };
struct S_PhysicalDeviceExternalMemoryHostPropertiesEXT : public VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceExternalMemoryHostPropertiesEXT;
public:
    S_PhysicalDeviceExternalMemoryHostPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceExternalMemoryHostPropertiesEXT(
        VkDeviceSize minImportedHostPointerAlignment_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
        nullptr,
        minImportedHostPointerAlignment_
    } { }
    inL S_PhysicalDeviceExternalMemoryHostPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceExternalMemoryHostPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceExternalMemoryHostPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceExternalMemoryHostPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceExternalMemoryHostPropertiesEXT> { using T = S_PhysicalDeviceExternalMemoryHostPropertiesEXT; };
struct S_PhysicalDeviceDepthStencilResolvePropertiesKHR : public VkPhysicalDeviceDepthStencilResolvePropertiesKHR {
public:
    using Otype = VkPhysicalDeviceDepthStencilResolvePropertiesKHR;
public:
    S_PhysicalDeviceDepthStencilResolvePropertiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceDepthStencilResolvePropertiesKHR(
        VkResolveModeFlagsKHR supportedDepthResolveModes_= { },
        VkResolveModeFlagsKHR supportedStencilResolveModes_= { },
        VkBool32 independentResolveNone_= { },
        VkBool32 independentResolve_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR,
        nullptr,
        supportedDepthResolveModes_,
        supportedStencilResolveModes_,
        independentResolveNone_,
        independentResolve_
    } { }
    inL S_PhysicalDeviceDepthStencilResolvePropertiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceDepthStencilResolvePropertiesKHR*() { return this; }
    inL operator S_PhysicalDeviceDepthStencilResolvePropertiesKHR const* () const { return const_cast<S_PhysicalDeviceDepthStencilResolvePropertiesKHR const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceDepthStencilResolvePropertiesKHR> { using T = S_PhysicalDeviceDepthStencilResolvePropertiesKHR; };
struct S_PhysicalDeviceTransformFeedbackPropertiesEXT : public VkPhysicalDeviceTransformFeedbackPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceTransformFeedbackPropertiesEXT;
public:
    S_PhysicalDeviceTransformFeedbackPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceTransformFeedbackPropertiesEXT(
        uint32_t maxTransformFeedbackStreams_= { },
        uint32_t maxTransformFeedbackBuffers_= { },
        VkDeviceSize maxTransformFeedbackBufferSize_= { },
        uint32_t maxTransformFeedbackStreamDataSize_= { },
        uint32_t maxTransformFeedbackBufferDataSize_= { },
        uint32_t maxTransformFeedbackBufferDataStride_= { },
        VkBool32 transformFeedbackQueries_= { },
        VkBool32 transformFeedbackStreamsLinesTriangles_= { },
        VkBool32 transformFeedbackRasterizationStreamSelect_= { },
        VkBool32 transformFeedbackDraw_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
        nullptr,
        maxTransformFeedbackStreams_,
        maxTransformFeedbackBuffers_,
        maxTransformFeedbackBufferSize_,
        maxTransformFeedbackStreamDataSize_,
        maxTransformFeedbackBufferDataSize_,
        maxTransformFeedbackBufferDataStride_,
        transformFeedbackQueries_,
        transformFeedbackStreamsLinesTriangles_,
        transformFeedbackRasterizationStreamSelect_,
        transformFeedbackDraw_
    } { }
    inL S_PhysicalDeviceTransformFeedbackPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceTransformFeedbackPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceTransformFeedbackPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceTransformFeedbackPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceTransformFeedbackPropertiesEXT> { using T = S_PhysicalDeviceTransformFeedbackPropertiesEXT; };
struct S_PhysicalDeviceProtectedMemoryProperties : public VkPhysicalDeviceProtectedMemoryProperties {
public:
    using Otype = VkPhysicalDeviceProtectedMemoryProperties;
public:
    S_PhysicalDeviceProtectedMemoryProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceProtectedMemoryProperties(
        VkBool32 protectedNoFault_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
        nullptr,
        protectedNoFault_
    } { }
    inL S_PhysicalDeviceProtectedMemoryProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceProtectedMemoryProperties*() { return this; }
    inL operator S_PhysicalDeviceProtectedMemoryProperties const* () const { return const_cast<S_PhysicalDeviceProtectedMemoryProperties const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceProtectedMemoryProperties> { using T = S_PhysicalDeviceProtectedMemoryProperties; };
struct S_PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX : public VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
public:
    using Otype = VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX;
public:
    S_PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(
        VkBool32 perViewPositionAllComponents_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
        nullptr,
        perViewPositionAllComponents_
    } { }
    inL S_PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*() { return this; }
    inL operator S_PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const* () const { return const_cast<S_PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX> { using T = S_PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX; };
struct S_PhysicalDeviceConservativeRasterizationPropertiesEXT : public VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceConservativeRasterizationPropertiesEXT;
public:
    S_PhysicalDeviceConservativeRasterizationPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceConservativeRasterizationPropertiesEXT(
        float primitiveOverestimationSize_= { },
        float maxExtraPrimitiveOverestimationSize_= { },
        float extraPrimitiveOverestimationSizeGranularity_= { },
        VkBool32 primitiveUnderestimation_= { },
        VkBool32 conservativePointAndLineRasterization_= { },
        VkBool32 degenerateTrianglesRasterized_= { },
        VkBool32 degenerateLinesRasterized_= { },
        VkBool32 fullyCoveredFragmentShaderInputVariable_= { },
        VkBool32 conservativeRasterizationPostDepthCoverage_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
        nullptr,
        primitiveOverestimationSize_,
        maxExtraPrimitiveOverestimationSize_,
        extraPrimitiveOverestimationSizeGranularity_,
        primitiveUnderestimation_,
        conservativePointAndLineRasterization_,
        degenerateTrianglesRasterized_,
        degenerateLinesRasterized_,
        fullyCoveredFragmentShaderInputVariable_,
        conservativeRasterizationPostDepthCoverage_
    } { }
    inL S_PhysicalDeviceConservativeRasterizationPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceConservativeRasterizationPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceConservativeRasterizationPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceConservativeRasterizationPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceConservativeRasterizationPropertiesEXT> { using T = S_PhysicalDeviceConservativeRasterizationPropertiesEXT; };
struct S_PhysicalDeviceTexelBufferAlignmentPropertiesEXT : public VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT;
public:
    S_PhysicalDeviceTexelBufferAlignmentPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceTexelBufferAlignmentPropertiesEXT(
        VkDeviceSize storageTexelBufferOffsetAlignmentBytes_= { },
        VkBool32 storageTexelBufferOffsetSingleTexelAlignment_= { },
        VkDeviceSize uniformTexelBufferOffsetAlignmentBytes_= { },
        VkBool32 uniformTexelBufferOffsetSingleTexelAlignment_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT,
        nullptr,
        storageTexelBufferOffsetAlignmentBytes_,
        storageTexelBufferOffsetSingleTexelAlignment_,
        uniformTexelBufferOffsetAlignmentBytes_,
        uniformTexelBufferOffsetSingleTexelAlignment_
    } { }
    inL S_PhysicalDeviceTexelBufferAlignmentPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceTexelBufferAlignmentPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceTexelBufferAlignmentPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceTexelBufferAlignmentPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT> { using T = S_PhysicalDeviceTexelBufferAlignmentPropertiesEXT; };
struct S_PhysicalDevicePushDescriptorPropertiesKHR : public VkPhysicalDevicePushDescriptorPropertiesKHR {
public:
    using Otype = VkPhysicalDevicePushDescriptorPropertiesKHR;
public:
    S_PhysicalDevicePushDescriptorPropertiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDevicePushDescriptorPropertiesKHR(
        uint32_t maxPushDescriptors_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR,
        nullptr,
        maxPushDescriptors_
    } { }
    inL S_PhysicalDevicePushDescriptorPropertiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDevicePushDescriptorPropertiesKHR*() { return this; }
    inL operator S_PhysicalDevicePushDescriptorPropertiesKHR const* () const { return const_cast<S_PhysicalDevicePushDescriptorPropertiesKHR const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDevicePushDescriptorPropertiesKHR> { using T = S_PhysicalDevicePushDescriptorPropertiesKHR; };
struct S_PhysicalDeviceFloatControlsPropertiesKHR : public VkPhysicalDeviceFloatControlsPropertiesKHR {
public:
    using Otype = VkPhysicalDeviceFloatControlsPropertiesKHR;
public:
    S_PhysicalDeviceFloatControlsPropertiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceFloatControlsPropertiesKHR(
        E_ShaderFloatControlsIndependenceKHR denormBehaviorIndependence_= { },
        E_ShaderFloatControlsIndependenceKHR roundingModeIndependence_= { },
        VkBool32 shaderSignedZeroInfNanPreserveFloat16_= { },
        VkBool32 shaderSignedZeroInfNanPreserveFloat32_= { },
        VkBool32 shaderSignedZeroInfNanPreserveFloat64_= { },
        VkBool32 shaderDenormPreserveFloat16_= { },
        VkBool32 shaderDenormPreserveFloat32_= { },
        VkBool32 shaderDenormPreserveFloat64_= { },
        VkBool32 shaderDenormFlushToZeroFloat16_= { },
        VkBool32 shaderDenormFlushToZeroFloat32_= { },
        VkBool32 shaderDenormFlushToZeroFloat64_= { },
        VkBool32 shaderRoundingModeRTEFloat16_= { },
        VkBool32 shaderRoundingModeRTEFloat32_= { },
        VkBool32 shaderRoundingModeRTEFloat64_= { },
        VkBool32 shaderRoundingModeRTZFloat16_= { },
        VkBool32 shaderRoundingModeRTZFloat32_= { },
        VkBool32 shaderRoundingModeRTZFloat64_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR,
        nullptr,
        denormBehaviorIndependence_,
        roundingModeIndependence_,
        shaderSignedZeroInfNanPreserveFloat16_,
        shaderSignedZeroInfNanPreserveFloat32_,
        shaderSignedZeroInfNanPreserveFloat64_,
        shaderDenormPreserveFloat16_,
        shaderDenormPreserveFloat32_,
        shaderDenormPreserveFloat64_,
        shaderDenormFlushToZeroFloat16_,
        shaderDenormFlushToZeroFloat32_,
        shaderDenormFlushToZeroFloat64_,
        shaderRoundingModeRTEFloat16_,
        shaderRoundingModeRTEFloat32_,
        shaderRoundingModeRTEFloat64_,
        shaderRoundingModeRTZFloat16_,
        shaderRoundingModeRTZFloat32_,
        shaderRoundingModeRTZFloat64_
    } { }
    inL S_PhysicalDeviceFloatControlsPropertiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceFloatControlsPropertiesKHR*() { return this; }
    inL operator S_PhysicalDeviceFloatControlsPropertiesKHR const* () const { return const_cast<S_PhysicalDeviceFloatControlsPropertiesKHR const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceFloatControlsPropertiesKHR> { using T = S_PhysicalDeviceFloatControlsPropertiesKHR; };
struct S_PhysicalDeviceFragmentDensityMapPropertiesEXT : public VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
public:
    using Otype = VkPhysicalDeviceFragmentDensityMapPropertiesEXT;
public:
    S_PhysicalDeviceFragmentDensityMapPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceFragmentDensityMapPropertiesEXT(
        S_Extent2D minFragmentDensityTexelSize_= { },
        S_Extent2D maxFragmentDensityTexelSize_= { },
        VkBool32 fragmentDensityInvocations_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
        nullptr,
        minFragmentDensityTexelSize_,
        maxFragmentDensityTexelSize_,
        fragmentDensityInvocations_
    } { }
    inL S_PhysicalDeviceFragmentDensityMapPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceFragmentDensityMapPropertiesEXT*() { return this; }
    inL operator S_PhysicalDeviceFragmentDensityMapPropertiesEXT const* () const { return const_cast<S_PhysicalDeviceFragmentDensityMapPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceFragmentDensityMapPropertiesEXT> { using T = S_PhysicalDeviceFragmentDensityMapPropertiesEXT; };
struct N_PhysicalDeviceProperties2{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceShaderCorePropertiesAMD(Aref<S_PhysicalDeviceShaderCorePropertiesAMD> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDevicePCIBusInfoPropertiesEXT(Aref<S_PhysicalDevicePCIBusInfoPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceRayTracingPropertiesNV(Aref<S_PhysicalDeviceRayTracingPropertiesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceSubgroupProperties(Aref<S_PhysicalDeviceSubgroupProperties> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceDriverPropertiesKHR(Aref<S_PhysicalDeviceDriverPropertiesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceCooperativeMatrixPropertiesNV(Aref<S_PhysicalDeviceCooperativeMatrixPropertiesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceSampleLocationsPropertiesEXT(Aref<S_PhysicalDeviceSampleLocationsPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(Aref<S_PhysicalDeviceSubgroupSizeControlPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceDiscardRectanglePropertiesEXT(Aref<S_PhysicalDeviceDiscardRectanglePropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceMaintenance3Properties(Aref<S_PhysicalDeviceMaintenance3Properties> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(Aref<S_PhysicalDeviceDescriptorIndexingPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceShadingRateImagePropertiesNV(Aref<S_PhysicalDeviceShadingRateImagePropertiesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceShaderCoreProperties2AMD(Aref<S_PhysicalDeviceShaderCoreProperties2AMD> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(Aref<S_PhysicalDeviceBlendOperationAdvancedPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceMultiviewProperties(Aref<S_PhysicalDeviceMultiviewProperties> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceMeshShaderPropertiesNV(Aref<S_PhysicalDeviceMeshShaderPropertiesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceIDProperties(Aref<S_PhysicalDeviceIDProperties> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDevicePointClippingProperties(Aref<S_PhysicalDevicePointClippingProperties> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(Aref<S_PhysicalDeviceVertexAttributeDivisorPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(Aref<S_PhysicalDeviceInlineUniformBlockPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceLineRasterizationPropertiesEXT(Aref<S_PhysicalDeviceLineRasterizationPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(Aref<S_PhysicalDeviceShaderSMBuiltinsPropertiesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(Aref<S_PhysicalDeviceExternalMemoryHostPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceDepthStencilResolvePropertiesKHR(Aref<S_PhysicalDeviceDepthStencilResolvePropertiesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(Aref<S_PhysicalDeviceSamplerFilterMinmaxPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceTransformFeedbackPropertiesEXT(Aref<S_PhysicalDeviceTransformFeedbackPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceProtectedMemoryProperties(Aref<S_PhysicalDeviceProtectedMemoryProperties> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(Aref<S_PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(Aref<S_PhysicalDeviceConservativeRasterizationPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(Aref<S_PhysicalDeviceTexelBufferAlignmentPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDevicePushDescriptorPropertiesKHR(Aref<S_PhysicalDevicePushDescriptorPropertiesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceFloatControlsPropertiesKHR(Aref<S_PhysicalDeviceFloatControlsPropertiesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_PhysicalDeviceProperties2& n_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(Aref<S_PhysicalDeviceFragmentDensityMapPropertiesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_PhysicalDeviceProperties2 : public VkPhysicalDeviceProperties2 {
public:
    using Otype = VkPhysicalDeviceProperties2;
public:
    S_PhysicalDeviceProperties2(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceProperties2(
        S_PhysicalDeviceProperties properties_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
        nullptr,
        properties_
    } { }
    S_PhysicalDeviceProperties2& set_next(N_PhysicalDeviceProperties2& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_PhysicalDeviceProperties2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceProperties2*() { return this; }
    inL operator S_PhysicalDeviceProperties2 const* () const { return const_cast<S_PhysicalDeviceProperties2 const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceProperties2> { using T = S_PhysicalDeviceProperties2; };
struct S_SubpassDependency2KHR : public VkSubpassDependency2KHR {
public:
    using Otype = VkSubpassDependency2KHR;
public:
    S_SubpassDependency2KHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SubpassDependency2KHR(
        uint32_t srcSubpass_= { },
        uint32_t dstSubpass_= { },
        VkPipelineStageFlags srcStageMask_= { },
        VkPipelineStageFlags dstStageMask_= { },
        VkAccessFlags srcAccessMask_= { },
        VkAccessFlags dstAccessMask_= { },
        VkDependencyFlags dependencyFlags_= { },
        int32_t viewOffset_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR,
        nullptr,
        srcSubpass_,
        dstSubpass_,
        srcStageMask_,
        dstStageMask_,
        srcAccessMask_,
        dstAccessMask_,
        dependencyFlags_,
        viewOffset_
    } { }
    inL S_SubpassDependency2KHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SubpassDependency2KHR*() { return this; }
    inL operator S_SubpassDependency2KHR const* () const { return const_cast<S_SubpassDependency2KHR const*>(this); }
};
template<> struct detail::names_map<VkSubpassDependency2KHR> { using T = S_SubpassDependency2KHR; };
struct S_RenderPassCreateInfo2KHR : public VkRenderPassCreateInfo2KHR {
public:
    using Otype = VkRenderPassCreateInfo2KHR;
public:
    S_RenderPassCreateInfo2KHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_RenderPassCreateInfo2KHR(
        VkRenderPassCreateFlags flags_= { },
        Array_general<S_AttachmentDescription2KHR> pAttachments_= { },
        Array_general<S_SubpassDescription2KHR> pSubpasses_= { },
        Array_general<S_SubpassDependency2KHR> pDependencies_= { },
        Array_general<uint32_t> pCorrelatedViewMasks_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR,
        nullptr,
        flags_,
        pAttachments_.size(),
        reinterpret_cast<VkAttachmentDescription2KHR*>(pAttachments_.data()),
        pSubpasses_.size(),
        reinterpret_cast<VkSubpassDescription2KHR*>(pSubpasses_.data()),
        pDependencies_.size(),
        reinterpret_cast<VkSubpassDependency2KHR*>(pDependencies_.data()),
        pCorrelatedViewMasks_.size(),
        reinterpret_cast<uint32_t*>(pCorrelatedViewMasks_.data())
    } { }
    inL S_RenderPassCreateInfo2KHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_RenderPassCreateInfo2KHR*() { return this; }
    inL operator S_RenderPassCreateInfo2KHR const* () const { return const_cast<S_RenderPassCreateInfo2KHR const*>(this); }
};
template<> struct detail::names_map<VkRenderPassCreateInfo2KHR> { using T = S_RenderPassCreateInfo2KHR; };
struct S_PipelineCompilerControlCreateInfoAMD : public VkPipelineCompilerControlCreateInfoAMD {
public:
    using Otype = VkPipelineCompilerControlCreateInfoAMD;
public:
    S_PipelineCompilerControlCreateInfoAMD(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineCompilerControlCreateInfoAMD(
        VkPipelineCompilerControlFlagsAMD compilerControlFlags_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
        nullptr,
        compilerControlFlags_
    } { }
    inL S_PipelineCompilerControlCreateInfoAMD& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineCompilerControlCreateInfoAMD*() { return this; }
    inL operator S_PipelineCompilerControlCreateInfoAMD const* () const { return const_cast<S_PipelineCompilerControlCreateInfoAMD const*>(this); }
};
template<> struct detail::names_map<VkPipelineCompilerControlCreateInfoAMD> { using T = S_PipelineCompilerControlCreateInfoAMD; };
struct S_QueueFamilyProperties : public VkQueueFamilyProperties {
public:
    using Otype = VkQueueFamilyProperties;
public:
    S_QueueFamilyProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_QueueFamilyProperties(
        VkQueueFlags queueFlags_= { },
        uint32_t queueCount_= { },
        uint32_t timestampValidBits_= { },
        S_Extent3D minImageTransferGranularity_= { }
    ) : Otype{
        queueFlags_,
        queueCount_,
        timestampValidBits_,
        minImageTransferGranularity_
    } { }
    inL S_QueueFamilyProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_QueueFamilyProperties*() { return this; }
    inL operator S_QueueFamilyProperties const* () const { return const_cast<S_QueueFamilyProperties const*>(this); }
};
template<> struct detail::names_map<VkQueueFamilyProperties> { using T = S_QueueFamilyProperties; };
struct S_QueueFamilyCheckpointPropertiesNV : public VkQueueFamilyCheckpointPropertiesNV {
public:
    using Otype = VkQueueFamilyCheckpointPropertiesNV;
public:
    S_QueueFamilyCheckpointPropertiesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_QueueFamilyCheckpointPropertiesNV(
        VkPipelineStageFlags checkpointExecutionStageMask_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
        nullptr,
        checkpointExecutionStageMask_
    } { }
    inL S_QueueFamilyCheckpointPropertiesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_QueueFamilyCheckpointPropertiesNV*() { return this; }
    inL operator S_QueueFamilyCheckpointPropertiesNV const* () const { return const_cast<S_QueueFamilyCheckpointPropertiesNV const*>(this); }
};
template<> struct detail::names_map<VkQueueFamilyCheckpointPropertiesNV> { using T = S_QueueFamilyCheckpointPropertiesNV; };
struct N_QueueFamilyProperties2{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_QueueFamilyProperties2& n_VkQueueFamilyCheckpointPropertiesNV(Aref<S_QueueFamilyCheckpointPropertiesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_QueueFamilyProperties2 : public VkQueueFamilyProperties2 {
public:
    using Otype = VkQueueFamilyProperties2;
public:
    S_QueueFamilyProperties2(Otype& origin_obj_):Otype(origin_obj_){}
    S_QueueFamilyProperties2(
        S_QueueFamilyProperties queueFamilyProperties_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
        nullptr,
        queueFamilyProperties_
    } { }
    S_QueueFamilyProperties2& set_next(N_QueueFamilyProperties2& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_QueueFamilyProperties2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_QueueFamilyProperties2*() { return this; }
    inL operator S_QueueFamilyProperties2 const* () const { return const_cast<S_QueueFamilyProperties2 const*>(this); }
};
template<> struct detail::names_map<VkQueueFamilyProperties2> { using T = S_QueueFamilyProperties2; };
struct N_SamplerYcbcrConversionCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
# if defined(VK_USE_PLATFORM_ANDROID_KHR)
    inL N_SamplerYcbcrConversionCreateInfo& n_VkExternalFormatANDROID(Aref<S_ExternalFormatANDROID> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
};
struct S_SamplerYcbcrConversionCreateInfo : public VkSamplerYcbcrConversionCreateInfo {
public:
    using Otype = VkSamplerYcbcrConversionCreateInfo;
public:
    S_SamplerYcbcrConversionCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_SamplerYcbcrConversionCreateInfo(
        E_Format format_= { },
        E_SamplerYcbcrModelConversion ycbcrModel_= { },
        E_SamplerYcbcrRange ycbcrRange_= { },
        S_ComponentMapping components_= { },
        E_ChromaLocation xChromaOffset_= { },
        E_ChromaLocation yChromaOffset_= { },
        E_Filter chromaFilter_= { },
        VkBool32 forceExplicitReconstruction_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
        nullptr,
        format_,
        ycbcrModel_,
        ycbcrRange_,
        components_,
        xChromaOffset_,
        yChromaOffset_,
        chromaFilter_,
        forceExplicitReconstruction_
    } { }
# if defined(VK_USE_PLATFORM_ANDROID_KHR)
    inL S_SamplerYcbcrConversionCreateInfo& n_VkExternalFormatANDROID(Aref<S_ExternalFormatANDROID> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    S_SamplerYcbcrConversionCreateInfo& set_next(N_SamplerYcbcrConversionCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_SamplerYcbcrConversionCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SamplerYcbcrConversionCreateInfo*() { return this; }
    inL operator S_SamplerYcbcrConversionCreateInfo const* () const { return const_cast<S_SamplerYcbcrConversionCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkSamplerYcbcrConversionCreateInfo> { using T = S_SamplerYcbcrConversionCreateInfo; };
struct S_SparseImageMemoryRequirements : public VkSparseImageMemoryRequirements {
public:
    using Otype = VkSparseImageMemoryRequirements;
public:
    S_SparseImageMemoryRequirements(Otype& origin_obj_):Otype(origin_obj_){}
    S_SparseImageMemoryRequirements(
        S_SparseImageFormatProperties formatProperties_= { },
        uint32_t imageMipTailFirstLod_= { },
        VkDeviceSize imageMipTailSize_= { },
        VkDeviceSize imageMipTailOffset_= { },
        VkDeviceSize imageMipTailStride_= { }
    ) : Otype{
        formatProperties_,
        imageMipTailFirstLod_,
        imageMipTailSize_,
        imageMipTailOffset_,
        imageMipTailStride_
    } { }
    inL S_SparseImageMemoryRequirements& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SparseImageMemoryRequirements*() { return this; }
    inL operator S_SparseImageMemoryRequirements const* () const { return const_cast<S_SparseImageMemoryRequirements const*>(this); }
};
template<> struct detail::names_map<VkSparseImageMemoryRequirements> { using T = S_SparseImageMemoryRequirements; };
struct S_WriteDescriptorSetInlineUniformBlockEXT : public VkWriteDescriptorSetInlineUniformBlockEXT {
public:
    using Otype = VkWriteDescriptorSetInlineUniformBlockEXT;
public:
    S_WriteDescriptorSetInlineUniformBlockEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_WriteDescriptorSetInlineUniformBlockEXT(
        Array_general<void> pData_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT,
        nullptr,
        pData_.size(),
        reinterpret_cast<void*>(pData_.data())
    } { }
    inL S_WriteDescriptorSetInlineUniformBlockEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_WriteDescriptorSetInlineUniformBlockEXT*() { return this; }
    inL operator S_WriteDescriptorSetInlineUniformBlockEXT const* () const { return const_cast<S_WriteDescriptorSetInlineUniformBlockEXT const*>(this); }
};
template<> struct detail::names_map<VkWriteDescriptorSetInlineUniformBlockEXT> { using T = S_WriteDescriptorSetInlineUniformBlockEXT; };
struct S_ExportMemoryAllocateInfo : public VkExportMemoryAllocateInfo {
public:
    using Otype = VkExportMemoryAllocateInfo;
public:
    S_ExportMemoryAllocateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExportMemoryAllocateInfo(
        VkExternalMemoryHandleTypeFlags handleTypes_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
        nullptr,
        handleTypes_
    } { }
    inL S_ExportMemoryAllocateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExportMemoryAllocateInfo*() { return this; }
    inL operator S_ExportMemoryAllocateInfo const* () const { return const_cast<S_ExportMemoryAllocateInfo const*>(this); }
};
template<> struct detail::names_map<VkExportMemoryAllocateInfo> { using T = S_ExportMemoryAllocateInfo; };
struct S_PipelineInputAssemblyStateCreateInfo : public VkPipelineInputAssemblyStateCreateInfo {
public:
    using Otype = VkPipelineInputAssemblyStateCreateInfo;
public:
    S_PipelineInputAssemblyStateCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineInputAssemblyStateCreateInfo(
        VkPipelineInputAssemblyStateCreateFlags flags_= { },
        E_PrimitiveTopology topology_= { },
        VkBool32 primitiveRestartEnable_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
        nullptr,
        flags_,
        topology_,
        primitiveRestartEnable_
    } { }
    inL S_PipelineInputAssemblyStateCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineInputAssemblyStateCreateInfo*() { return this; }
    inL operator S_PipelineInputAssemblyStateCreateInfo const* () const { return const_cast<S_PipelineInputAssemblyStateCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkPipelineInputAssemblyStateCreateInfo> { using T = S_PipelineInputAssemblyStateCreateInfo; };
struct N_GraphicsPipelineCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_GraphicsPipelineCreateInfo& n_VkPipelineDiscardRectangleStateCreateInfoEXT(Aref<S_PipelineDiscardRectangleStateCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_GraphicsPipelineCreateInfo& n_VkPipelineCreationFeedbackCreateInfoEXT(Aref<S_PipelineCreationFeedbackCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_GraphicsPipelineCreateInfo& n_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(Aref<S_PipelineRepresentativeFragmentTestStateCreateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_GraphicsPipelineCreateInfo& n_VkPipelineCompilerControlCreateInfoAMD(Aref<S_PipelineCompilerControlCreateInfoAMD> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_GraphicsPipelineCreateInfo : public VkGraphicsPipelineCreateInfo {
public:
    using Otype = VkGraphicsPipelineCreateInfo;
public:
    S_GraphicsPipelineCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_GraphicsPipelineCreateInfo(
        VkPipelineCreateFlags                           flags_              = { },
        Array_general<S_PipelineShaderStageCreateInfo>  pStages_            = { },
        Aptr<S_PipelineVertexInputStateCreateInfo>      pVertexInputState_  = { },
        Aptr<S_PipelineInputAssemblyStateCreateInfo>    pInputAssemblyState_= { },
        Aptr<S_PipelineTessellationStateCreateInfo>     pTessellationState_ = { },
        Aptr<S_PipelineViewportStateCreateInfo>         pViewportState_     = { },
        Aptr<S_PipelineRasterizationStateCreateInfo>    pRasterizationState_= { },
        Aptr<S_PipelineMultisampleStateCreateInfo>      pMultisampleState_  = { },
        Aptr<S_PipelineDepthStencilStateCreateInfo>     pDepthStencilState_ = { },
        Aptr<S_PipelineColorBlendStateCreateInfo>       pColorBlendState_   = { },
        Aptr<S_PipelineDynamicStateCreateInfo>          pDynamicState_      = { },
        VkPipelineLayout                                layout_             = { },
        VkRenderPass                                    renderPass_         = { },
        uint32_t                                        subpass_            = { },
        VkPipeline                                      basePipelineHandle_ = { },
        int32_t                                         basePipelineIndex_  = { }
    ) : Otype{
        VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
        nullptr,
        flags_,
        pStages_.size(),
        reinterpret_cast<VkPipelineShaderStageCreateInfo*>(pStages_.data()),
        pVertexInputState_,
        pInputAssemblyState_,
        pTessellationState_,
        pViewportState_,
        pRasterizationState_,
        pMultisampleState_,
        pDepthStencilState_,
        pColorBlendState_,
        pDynamicState_,
        layout_,
        renderPass_,
        subpass_,
        basePipelineHandle_,
        basePipelineIndex_
    } { }
    S_GraphicsPipelineCreateInfo& set_next(N_GraphicsPipelineCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_GraphicsPipelineCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_GraphicsPipelineCreateInfo*() { return this; }
    inL operator S_GraphicsPipelineCreateInfo const* () const { return const_cast<S_GraphicsPipelineCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkGraphicsPipelineCreateInfo> { using T = S_GraphicsPipelineCreateInfo; };
struct S_SemaphoreGetFdInfoKHR : public VkSemaphoreGetFdInfoKHR {
public:
    using Otype = VkSemaphoreGetFdInfoKHR;
public:
    S_SemaphoreGetFdInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_SemaphoreGetFdInfoKHR(
        VkSemaphore semaphore_= { },
        F_ExternalSemaphoreHandleType handleType_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR,
        nullptr,
        semaphore_,
        handleType_
    } { }
    inL S_SemaphoreGetFdInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SemaphoreGetFdInfoKHR*() { return this; }
    inL operator S_SemaphoreGetFdInfoKHR const* () const { return const_cast<S_SemaphoreGetFdInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkSemaphoreGetFdInfoKHR> { using T = S_SemaphoreGetFdInfoKHR; };
struct S_ExportMemoryAllocateInfoNV : public VkExportMemoryAllocateInfoNV {
public:
    using Otype = VkExportMemoryAllocateInfoNV;
public:
    S_ExportMemoryAllocateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExportMemoryAllocateInfoNV(
        VkExternalMemoryHandleTypeFlagsNV handleTypes_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV,
        nullptr,
        handleTypes_
    } { }
    inL S_ExportMemoryAllocateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExportMemoryAllocateInfoNV*() { return this; }
    inL operator S_ExportMemoryAllocateInfoNV const* () const { return const_cast<S_ExportMemoryAllocateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkExportMemoryAllocateInfoNV> { using T = S_ExportMemoryAllocateInfoNV; };
struct S_ExternalBufferProperties : public VkExternalBufferProperties {
public:
    using Otype = VkExternalBufferProperties;
public:
    S_ExternalBufferProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExternalBufferProperties(
        S_ExternalMemoryProperties externalMemoryProperties_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
        nullptr,
        externalMemoryProperties_
    } { }
    inL S_ExternalBufferProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExternalBufferProperties*() { return this; }
    inL operator S_ExternalBufferProperties const* () const { return const_cast<S_ExternalBufferProperties const*>(this); }
};
template<> struct detail::names_map<VkExternalBufferProperties> { using T = S_ExternalBufferProperties; };
struct S_ObjectTableDescriptorSetEntryNVX : public VkObjectTableDescriptorSetEntryNVX {
public:
    using Otype = VkObjectTableDescriptorSetEntryNVX;
public:
    S_ObjectTableDescriptorSetEntryNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_ObjectTableDescriptorSetEntryNVX(
        E_ObjectEntryTypeNVX type_= { },
        VkObjectEntryUsageFlagsNVX flags_= { },
        VkPipelineLayout pipelineLayout_= { },
        VkDescriptorSet descriptorSet_= { }
    ) : Otype{
        type_,
        flags_,
        pipelineLayout_,
        descriptorSet_
    } { }
    inL S_ObjectTableDescriptorSetEntryNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ObjectTableDescriptorSetEntryNVX*() { return this; }
    inL operator S_ObjectTableDescriptorSetEntryNVX const* () const { return const_cast<S_ObjectTableDescriptorSetEntryNVX const*>(this); }
};
template<> struct detail::names_map<VkObjectTableDescriptorSetEntryNVX> { using T = S_ObjectTableDescriptorSetEntryNVX; };
struct S_PhysicalDeviceExternalBufferInfo : public VkPhysicalDeviceExternalBufferInfo {
public:
    using Otype = VkPhysicalDeviceExternalBufferInfo;
public:
    S_PhysicalDeviceExternalBufferInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceExternalBufferInfo(
        VkBufferCreateFlags flags_= { },
        VkBufferUsageFlags usage_= { },
        F_ExternalMemoryHandleType handleType_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
        nullptr,
        flags_,
        usage_,
        handleType_
    } { }
    inL S_PhysicalDeviceExternalBufferInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceExternalBufferInfo*() { return this; }
    inL operator S_PhysicalDeviceExternalBufferInfo const* () const { return const_cast<S_PhysicalDeviceExternalBufferInfo const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceExternalBufferInfo> { using T = S_PhysicalDeviceExternalBufferInfo; };
struct N_SamplerCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_SamplerCreateInfo& n_VkSamplerYcbcrConversionInfo(Aref<S_SamplerYcbcrConversionInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_SamplerCreateInfo& n_VkSamplerReductionModeCreateInfoEXT(Aref<S_SamplerReductionModeCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_SamplerCreateInfo : public VkSamplerCreateInfo {
public:
    using Otype = VkSamplerCreateInfo;
public:
    S_SamplerCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_SamplerCreateInfo(
        VkSamplerCreateFlags    flags_                      = { },
        E_Filter                magFilter_                  = { },
        E_Filter                minFilter_                  = { },
        E_SamplerMipmapMode     mipmapMode_                 = { },
        E_SamplerAddressMode    addressModeU_               = { },
        E_SamplerAddressMode    addressModeV_               = { },
        E_SamplerAddressMode    addressModeW_               = { },
        float                   mipLodBias_                 = { },
        VkBool32                anisotropyEnable_           = { },
        float                   maxAnisotropy_              = { },
        VkBool32                compareEnable_              = { },
        E_CompareOp             compareOp_                  = { },
        float                   minLod_                     = { },
        float                   maxLod_                     = { },
        E_BorderColor           borderColor_                = { },
        VkBool32                unnormalizedCoordinates_    = { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
        nullptr,
        flags_,
        magFilter_,
        minFilter_,
        mipmapMode_,
        addressModeU_,
        addressModeV_,
        addressModeW_,
        mipLodBias_,
        anisotropyEnable_,
        maxAnisotropy_,
        compareEnable_,
        compareOp_,
        minLod_,
        maxLod_,
        borderColor_,
        unnormalizedCoordinates_
    } { }
    S_SamplerCreateInfo& set_next(N_SamplerCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_SamplerCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SamplerCreateInfo*() { return this; }
    inL operator S_SamplerCreateInfo const* () const { return const_cast<S_SamplerCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkSamplerCreateInfo> { using T = S_SamplerCreateInfo; };
struct S_ImageCopy : public VkImageCopy {
public:
    using Otype = VkImageCopy;
public:
    S_ImageCopy(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageCopy(
        S_ImageSubresourceLayers srcSubresource_= { },
        S_Offset3D srcOffset_= { },
        S_ImageSubresourceLayers dstSubresource_= { },
        S_Offset3D dstOffset_= { },
        S_Extent3D extent_= { }
    ) : Otype{
        srcSubresource_,
        srcOffset_,
        dstSubresource_,
        dstOffset_,
        extent_
    } { }
    inL S_ImageCopy& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageCopy*() { return this; }
    inL operator S_ImageCopy const* () const { return const_cast<S_ImageCopy const*>(this); }
};
template<> struct detail::names_map<VkImageCopy> { using T = S_ImageCopy; };
struct S_DebugMarkerObjectNameInfoEXT : public VkDebugMarkerObjectNameInfoEXT {
public:
    using Otype = VkDebugMarkerObjectNameInfoEXT;
public:
    S_DebugMarkerObjectNameInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DebugMarkerObjectNameInfoEXT(
        E_DebugReportObjectTypeEXT objectType_= { },
        uint64_t object_= { },
        Aptr<char> pObjectName_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
        nullptr,
        objectType_,
        object_,
        pObjectName_
    } { }
    inL S_DebugMarkerObjectNameInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DebugMarkerObjectNameInfoEXT*() { return this; }
    inL operator S_DebugMarkerObjectNameInfoEXT const* () const { return const_cast<S_DebugMarkerObjectNameInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDebugMarkerObjectNameInfoEXT> { using T = S_DebugMarkerObjectNameInfoEXT; };
struct S_ObjectTableEntryNVX : public VkObjectTableEntryNVX {
public:
    using Otype = VkObjectTableEntryNVX;
public:
    S_ObjectTableEntryNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_ObjectTableEntryNVX(
        E_ObjectEntryTypeNVX type_= { },
        VkObjectEntryUsageFlagsNVX flags_= { }
    ) : Otype{
        type_,
        flags_
    } { }
    inL S_ObjectTableEntryNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ObjectTableEntryNVX*() { return this; }
    inL operator S_ObjectTableEntryNVX const* () const { return const_cast<S_ObjectTableEntryNVX const*>(this); }
};
template<> struct detail::names_map<VkObjectTableEntryNVX> { using T = S_ObjectTableEntryNVX; };
struct S_DedicatedAllocationBufferCreateInfoNV : public VkDedicatedAllocationBufferCreateInfoNV {
public:
    using Otype = VkDedicatedAllocationBufferCreateInfoNV;
public:
    S_DedicatedAllocationBufferCreateInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_DedicatedAllocationBufferCreateInfoNV(
        VkBool32 dedicatedAllocation_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
        nullptr,
        dedicatedAllocation_
    } { }
    inL S_DedicatedAllocationBufferCreateInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DedicatedAllocationBufferCreateInfoNV*() { return this; }
    inL operator S_DedicatedAllocationBufferCreateInfoNV const* () const { return const_cast<S_DedicatedAllocationBufferCreateInfoNV const*>(this); }
};
template<> struct detail::names_map<VkDedicatedAllocationBufferCreateInfoNV> { using T = S_DedicatedAllocationBufferCreateInfoNV; };
struct N_BufferCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_BufferCreateInfo& n_VkBufferDeviceAddressCreateInfoEXT(Aref<S_BufferDeviceAddressCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_BufferCreateInfo& n_VkExternalMemoryBufferCreateInfo(Aref<S_ExternalMemoryBufferCreateInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_BufferCreateInfo& n_VkDedicatedAllocationBufferCreateInfoNV(Aref<S_DedicatedAllocationBufferCreateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_BufferCreateInfo : public VkBufferCreateInfo {
public:
    using Otype = VkBufferCreateInfo;
public:
    S_BufferCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_BufferCreateInfo(
        VkBufferCreateFlags flags_= { },
        VkDeviceSize size_= { },
        VkBufferUsageFlags usage_= { },
        E_SharingMode sharingMode_= { },
        Array_general<uint32_t> pQueueFamilyIndices_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
        nullptr,
        flags_,
        size_,
        usage_,
        sharingMode_,
        pQueueFamilyIndices_.size(),
        reinterpret_cast<uint32_t*>(pQueueFamilyIndices_.data())
    } { }
    S_BufferCreateInfo& set_next(N_BufferCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_BufferCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BufferCreateInfo*() { return this; }
    inL operator S_BufferCreateInfo const* () const { return const_cast<S_BufferCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkBufferCreateInfo> { using T = S_BufferCreateInfo; };
struct S_MemoryFdPropertiesKHR : public VkMemoryFdPropertiesKHR {
public:
    using Otype = VkMemoryFdPropertiesKHR;
public:
    S_MemoryFdPropertiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryFdPropertiesKHR(
        uint32_t memoryTypeBits_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR,
        nullptr,
        memoryTypeBits_
    } { }
    inL S_MemoryFdPropertiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryFdPropertiesKHR*() { return this; }
    inL operator S_MemoryFdPropertiesKHR const* () const { return const_cast<S_MemoryFdPropertiesKHR const*>(this); }
};
template<> struct detail::names_map<VkMemoryFdPropertiesKHR> { using T = S_MemoryFdPropertiesKHR; };
struct S_DeviceGroupRenderPassBeginInfo : public VkDeviceGroupRenderPassBeginInfo {
public:
    using Otype = VkDeviceGroupRenderPassBeginInfo;
public:
    S_DeviceGroupRenderPassBeginInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceGroupRenderPassBeginInfo(
        uint32_t deviceMask_= { },
        Array_general<S_Rect2D> pDeviceRenderAreas_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
        nullptr,
        deviceMask_,
        pDeviceRenderAreas_.size(),
        reinterpret_cast<VkRect2D*>(pDeviceRenderAreas_.data())
    } { }
    inL S_DeviceGroupRenderPassBeginInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceGroupRenderPassBeginInfo*() { return this; }
    inL operator S_DeviceGroupRenderPassBeginInfo const* () const { return const_cast<S_DeviceGroupRenderPassBeginInfo const*>(this); }
};
template<> struct detail::names_map<VkDeviceGroupRenderPassBeginInfo> { using T = S_DeviceGroupRenderPassBeginInfo; };
struct S_DeviceGeneratedCommandsFeaturesNVX : public VkDeviceGeneratedCommandsFeaturesNVX {
public:
    using Otype = VkDeviceGeneratedCommandsFeaturesNVX;
public:
    S_DeviceGeneratedCommandsFeaturesNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceGeneratedCommandsFeaturesNVX(
        VkBool32 computeBindingPointSupport_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX,
        nullptr,
        computeBindingPointSupport_
    } { }
    inL S_DeviceGeneratedCommandsFeaturesNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceGeneratedCommandsFeaturesNVX*() { return this; }
    inL operator S_DeviceGeneratedCommandsFeaturesNVX const* () const { return const_cast<S_DeviceGeneratedCommandsFeaturesNVX const*>(this); }
};
template<> struct detail::names_map<VkDeviceGeneratedCommandsFeaturesNVX> { using T = S_DeviceGeneratedCommandsFeaturesNVX; };
struct S_BufferDeviceAddressInfoEXT : public VkBufferDeviceAddressInfoEXT {
public:
    using Otype = VkBufferDeviceAddressInfoEXT;
public:
    S_BufferDeviceAddressInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_BufferDeviceAddressInfoEXT(
        VkBuffer buffer_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT,
        nullptr,
        buffer_
    } { }
    inL S_BufferDeviceAddressInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BufferDeviceAddressInfoEXT*() { return this; }
    inL operator S_BufferDeviceAddressInfoEXT const* () const { return const_cast<S_BufferDeviceAddressInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkBufferDeviceAddressInfoEXT> { using T = S_BufferDeviceAddressInfoEXT; };
struct S_ImageSubresource : public VkImageSubresource {
public:
    using Otype = VkImageSubresource;
public:
    S_ImageSubresource(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageSubresource(
        VkImageAspectFlags aspectMask_= { },
        uint32_t mipLevel_= { },
        uint32_t arrayLayer_= { }
    ) : Otype{
        aspectMask_,
        mipLevel_,
        arrayLayer_
    } { }
    inL S_ImageSubresource& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageSubresource*() { return this; }
    inL operator S_ImageSubresource const* () const { return const_cast<S_ImageSubresource const*>(this); }
};
template<> struct detail::names_map<VkImageSubresource> { using T = S_ImageSubresource; };
struct S_SparseImageMemoryBind : public VkSparseImageMemoryBind {
public:
    using Otype = VkSparseImageMemoryBind;
public:
    S_SparseImageMemoryBind(Otype& origin_obj_):Otype(origin_obj_){}
    S_SparseImageMemoryBind(
        S_ImageSubresource subresource_= { },
        S_Offset3D offset_= { },
        S_Extent3D extent_= { },
        VkDeviceMemory memory_= { },
        VkDeviceSize memoryOffset_= { },
        VkSparseMemoryBindFlags flags_= { }
    ) : Otype{
        subresource_,
        offset_,
        extent_,
        memory_,
        memoryOffset_,
        flags_
    } { }
    inL S_SparseImageMemoryBind& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SparseImageMemoryBind*() { return this; }
    inL operator S_SparseImageMemoryBind const* () const { return const_cast<S_SparseImageMemoryBind const*>(this); }
};
template<> struct detail::names_map<VkSparseImageMemoryBind> { using T = S_SparseImageMemoryBind; };
struct S_SparseImageMemoryBindInfo : public VkSparseImageMemoryBindInfo {
public:
    using Otype = VkSparseImageMemoryBindInfo;
public:
    S_SparseImageMemoryBindInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_SparseImageMemoryBindInfo(
        VkImage image_= { },
        Array_general<S_SparseImageMemoryBind> pBinds_= { }
    ) : Otype{
        image_,
        pBinds_.size(),
        reinterpret_cast<VkSparseImageMemoryBind*>(pBinds_.data())
    } { }
    inL S_SparseImageMemoryBindInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SparseImageMemoryBindInfo*() { return this; }
    inL operator S_SparseImageMemoryBindInfo const* () const { return const_cast<S_SparseImageMemoryBindInfo const*>(this); }
};
template<> struct detail::names_map<VkSparseImageMemoryBindInfo> { using T = S_SparseImageMemoryBindInfo; };
struct N_FenceCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_FenceCreateInfo& n_VkExportFenceWin32HandleInfoKHR(Aref<S_ExportFenceWin32HandleInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    inL N_FenceCreateInfo& n_VkExportFenceCreateInfo(Aref<S_ExportFenceCreateInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_FenceCreateInfo : public VkFenceCreateInfo {
public:
    using Otype = VkFenceCreateInfo;
public:
    S_FenceCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_FenceCreateInfo(
        VkFenceCreateFlags flags_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
        nullptr,
        flags_
    } { }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_FenceCreateInfo& n_VkExportFenceWin32HandleInfoKHR(Aref<S_ExportFenceWin32HandleInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    S_FenceCreateInfo& set_next(N_FenceCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_FenceCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_FenceCreateInfo*() { return this; }
    inL operator S_FenceCreateInfo const* () const { return const_cast<S_FenceCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkFenceCreateInfo> { using T = S_FenceCreateInfo; };
struct S_MemoryAllocateFlagsInfo : public VkMemoryAllocateFlagsInfo {
public:
    using Otype = VkMemoryAllocateFlagsInfo;
public:
    S_MemoryAllocateFlagsInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryAllocateFlagsInfo(
        VkMemoryAllocateFlags flags_= { },
        uint32_t deviceMask_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
        nullptr,
        flags_,
        deviceMask_
    } { }
    inL S_MemoryAllocateFlagsInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryAllocateFlagsInfo*() { return this; }
    inL operator S_MemoryAllocateFlagsInfo const* () const { return const_cast<S_MemoryAllocateFlagsInfo const*>(this); }
};
template<> struct detail::names_map<VkMemoryAllocateFlagsInfo> { using T = S_MemoryAllocateFlagsInfo; };
struct S_PipelineExecutableInfoKHR : public VkPipelineExecutableInfoKHR {
public:
    using Otype = VkPipelineExecutableInfoKHR;
public:
    S_PipelineExecutableInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineExecutableInfoKHR(
        VkPipeline pipeline_= { },
        uint32_t executableIndex_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR,
        nullptr,
        pipeline_,
        executableIndex_
    } { }
    inL S_PipelineExecutableInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineExecutableInfoKHR*() { return this; }
    inL operator S_PipelineExecutableInfoKHR const* () const { return const_cast<S_PipelineExecutableInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkPipelineExecutableInfoKHR> { using T = S_PipelineExecutableInfoKHR; };
struct S_CopyDescriptorSet : public VkCopyDescriptorSet {
public:
    using Otype = VkCopyDescriptorSet;
public:
    S_CopyDescriptorSet(Otype& origin_obj_):Otype(origin_obj_){}
    S_CopyDescriptorSet(
        VkDescriptorSet srcSet_= { },
        uint32_t srcBinding_= { },
        uint32_t srcArrayElement_= { },
        VkDescriptorSet dstSet_= { },
        uint32_t dstBinding_= { },
        uint32_t dstArrayElement_= { },
        uint32_t descriptorCount_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET,
        nullptr,
        srcSet_,
        srcBinding_,
        srcArrayElement_,
        dstSet_,
        dstBinding_,
        dstArrayElement_,
        descriptorCount_
    } { }
    inL S_CopyDescriptorSet& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_CopyDescriptorSet*() { return this; }
    inL operator S_CopyDescriptorSet const* () const { return const_cast<S_CopyDescriptorSet const*>(this); }
};
template<> struct detail::names_map<VkCopyDescriptorSet> { using T = S_CopyDescriptorSet; };
struct S_MemoryDedicatedAllocateInfo : public VkMemoryDedicatedAllocateInfo {
public:
    using Otype = VkMemoryDedicatedAllocateInfo;
public:
    S_MemoryDedicatedAllocateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryDedicatedAllocateInfo(
        VkImage image_= { },
        VkBuffer buffer_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
        nullptr,
        image_,
        buffer_
    } { }
    inL S_MemoryDedicatedAllocateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryDedicatedAllocateInfo*() { return this; }
    inL operator S_MemoryDedicatedAllocateInfo const* () const { return const_cast<S_MemoryDedicatedAllocateInfo const*>(this); }
};
template<> struct detail::names_map<VkMemoryDedicatedAllocateInfo> { using T = S_MemoryDedicatedAllocateInfo; };
struct N_RenderPassBeginInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_RenderPassBeginInfo& n_VkRenderPassSampleLocationsBeginInfoEXT(Aref<S_RenderPassSampleLocationsBeginInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_RenderPassBeginInfo& n_VkRenderPassAttachmentBeginInfoKHR(Aref<S_RenderPassAttachmentBeginInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_RenderPassBeginInfo& n_VkDeviceGroupRenderPassBeginInfo(Aref<S_DeviceGroupRenderPassBeginInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_RenderPassBeginInfo : public VkRenderPassBeginInfo {
public:
    using Otype = VkRenderPassBeginInfo;
public:
    S_RenderPassBeginInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_RenderPassBeginInfo(
        VkRenderPass renderPass_= { },
        VkFramebuffer framebuffer_= { },
        S_Rect2D renderArea_= { },
        Array_general<VkClearValue> pClearValues_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
        nullptr,
        renderPass_,
        framebuffer_,
        renderArea_,
        pClearValues_.size(),
        reinterpret_cast<VkClearValue*>(pClearValues_.data())
    } { }
    S_RenderPassBeginInfo& set_next(N_RenderPassBeginInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_RenderPassBeginInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_RenderPassBeginInfo*() { return this; }
    inL operator S_RenderPassBeginInfo const* () const { return const_cast<S_RenderPassBeginInfo const*>(this); }
};
template<> struct detail::names_map<VkRenderPassBeginInfo> { using T = S_RenderPassBeginInfo; };

# if defined(VK_USE_PLATFORM_VI_NN)
struct S_ViSurfaceCreateInfoNN : public VkViSurfaceCreateInfoNN {
public:
    using Otype = VkViSurfaceCreateInfoNN;
public:
    S_ViSurfaceCreateInfoNN(Otype& origin_obj_):Otype(origin_obj_){}
    S_ViSurfaceCreateInfoNN(
        VkViSurfaceCreateFlagsNN flags_= { },
        Aptr<void> window_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN,
        nullptr,
        flags_,
        window_
    } { }
    inL S_ViSurfaceCreateInfoNN& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ViSurfaceCreateInfoNN*() { return this; }
    inL operator S_ViSurfaceCreateInfoNN const* () const { return const_cast<S_ViSurfaceCreateInfoNN const*>(this); }
};
template<> struct detail::names_map<VkViSurfaceCreateInfoNN> { using T = S_ViSurfaceCreateInfoNN; };

#endif

# if defined(VK_USE_PLATFORM_XCB_KHR)
struct S_XcbSurfaceCreateInfoKHR : public VkXcbSurfaceCreateInfoKHR {
public:
    using Otype = VkXcbSurfaceCreateInfoKHR;
public:
    S_XcbSurfaceCreateInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_XcbSurfaceCreateInfoKHR(
        VkXcbSurfaceCreateFlagsKHR flags_= { },
        Aptr<xcb_connection_t> connection_= { },
        xcb_window_t window_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR,
        nullptr,
        flags_,
        connection_,
        window_
    } { }
    inL S_XcbSurfaceCreateInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_XcbSurfaceCreateInfoKHR*() { return this; }
    inL operator S_XcbSurfaceCreateInfoKHR const* () const { return const_cast<S_XcbSurfaceCreateInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkXcbSurfaceCreateInfoKHR> { using T = S_XcbSurfaceCreateInfoKHR; };

#endif
struct N_FramebufferCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_FramebufferCreateInfo& n_VkFramebufferAttachmentsCreateInfoKHR(Aref<S_FramebufferAttachmentsCreateInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_FramebufferCreateInfo : public VkFramebufferCreateInfo {
public:
    using Otype = VkFramebufferCreateInfo;
public:
    S_FramebufferCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_FramebufferCreateInfo(
        VkFramebufferCreateFlags flags_= { },
        VkRenderPass renderPass_= { },
        Array_general<VkImageView> pAttachments_= { },
        uint32_t width_= { },
        uint32_t height_= { },
        uint32_t layers_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO,
        nullptr,
        flags_,
        renderPass_,
        pAttachments_.size(),
        reinterpret_cast<VkImageView*>(pAttachments_.data()),
        width_,
        height_,
        layers_
    } { }
    S_FramebufferCreateInfo& set_next(N_FramebufferCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_FramebufferCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_FramebufferCreateInfo*() { return this; }
    inL operator S_FramebufferCreateInfo const* () const { return const_cast<S_FramebufferCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkFramebufferCreateInfo> { using T = S_FramebufferCreateInfo; };
struct N_DescriptorSetLayoutCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_DescriptorSetLayoutCreateInfo& n_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(Aref<S_DescriptorSetLayoutBindingFlagsCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_DescriptorSetLayoutCreateInfo : public VkDescriptorSetLayoutCreateInfo {
public:
    using Otype = VkDescriptorSetLayoutCreateInfo;
public:
    S_DescriptorSetLayoutCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorSetLayoutCreateInfo(
        VkDescriptorSetLayoutCreateFlags flags_= { },
        Array_general<S_DescriptorSetLayoutBinding> pBindings_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        nullptr,
        flags_,
        pBindings_.size(),
        reinterpret_cast<VkDescriptorSetLayoutBinding*>(pBindings_.data())
    } { }
    S_DescriptorSetLayoutCreateInfo& set_next(N_DescriptorSetLayoutCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_DescriptorSetLayoutCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorSetLayoutCreateInfo*() { return this; }
    inL operator S_DescriptorSetLayoutCreateInfo const* () const { return const_cast<S_DescriptorSetLayoutCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkDescriptorSetLayoutCreateInfo> { using T = S_DescriptorSetLayoutCreateInfo; };
struct S_SparseImageFormatProperties2 : public VkSparseImageFormatProperties2 {
public:
    using Otype = VkSparseImageFormatProperties2;
public:
    S_SparseImageFormatProperties2(Otype& origin_obj_):Otype(origin_obj_){}
    S_SparseImageFormatProperties2(
        S_SparseImageFormatProperties properties_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
        nullptr,
        properties_
    } { }
    inL S_SparseImageFormatProperties2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SparseImageFormatProperties2*() { return this; }
    inL operator S_SparseImageFormatProperties2 const* () const { return const_cast<S_SparseImageFormatProperties2 const*>(this); }
};
template<> struct detail::names_map<VkSparseImageFormatProperties2> { using T = S_SparseImageFormatProperties2; };
struct S_DeviceQueueGlobalPriorityCreateInfoEXT : public VkDeviceQueueGlobalPriorityCreateInfoEXT {
public:
    using Otype = VkDeviceQueueGlobalPriorityCreateInfoEXT;
public:
    S_DeviceQueueGlobalPriorityCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceQueueGlobalPriorityCreateInfoEXT(
        E_QueueGlobalPriorityEXT globalPriority_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT,
        nullptr,
        globalPriority_
    } { }
    inL S_DeviceQueueGlobalPriorityCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceQueueGlobalPriorityCreateInfoEXT*() { return this; }
    inL operator S_DeviceQueueGlobalPriorityCreateInfoEXT const* () const { return const_cast<S_DeviceQueueGlobalPriorityCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDeviceQueueGlobalPriorityCreateInfoEXT> { using T = S_DeviceQueueGlobalPriorityCreateInfoEXT; };
struct N_ComputePipelineCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_ComputePipelineCreateInfo& n_VkPipelineCreationFeedbackCreateInfoEXT(Aref<S_PipelineCreationFeedbackCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_ComputePipelineCreateInfo& n_VkPipelineCompilerControlCreateInfoAMD(Aref<S_PipelineCompilerControlCreateInfoAMD> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_ComputePipelineCreateInfo : public VkComputePipelineCreateInfo {
public:
    using Otype = VkComputePipelineCreateInfo;
public:
    S_ComputePipelineCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_ComputePipelineCreateInfo(
        VkPipelineCreateFlags flags_= { },
        S_PipelineShaderStageCreateInfo stage_= { },
        VkPipelineLayout layout_= { },
        VkPipeline basePipelineHandle_= { },
        int32_t basePipelineIndex_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
        nullptr,
        flags_,
        stage_,
        layout_,
        basePipelineHandle_,
        basePipelineIndex_
    } { }
    S_ComputePipelineCreateInfo& set_next(N_ComputePipelineCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_ComputePipelineCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ComputePipelineCreateInfo*() { return this; }
    inL operator S_ComputePipelineCreateInfo const* () const { return const_cast<S_ComputePipelineCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkComputePipelineCreateInfo> { using T = S_ComputePipelineCreateInfo; };

# if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct S_MemoryGetAndroidHardwareBufferInfoANDROID : public VkMemoryGetAndroidHardwareBufferInfoANDROID {
public:
    using Otype = VkMemoryGetAndroidHardwareBufferInfoANDROID;
public:
    S_MemoryGetAndroidHardwareBufferInfoANDROID(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryGetAndroidHardwareBufferInfoANDROID(
        VkDeviceMemory memory_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID,
        nullptr,
        memory_
    } { }
    inL S_MemoryGetAndroidHardwareBufferInfoANDROID& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryGetAndroidHardwareBufferInfoANDROID*() { return this; }
    inL operator S_MemoryGetAndroidHardwareBufferInfoANDROID const* () const { return const_cast<S_MemoryGetAndroidHardwareBufferInfoANDROID const*>(this); }
};
template<> struct detail::names_map<VkMemoryGetAndroidHardwareBufferInfoANDROID> { using T = S_MemoryGetAndroidHardwareBufferInfoANDROID; };

#endif
struct N_PhysicalDeviceSurfaceInfo2KHR{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_PhysicalDeviceSurfaceInfo2KHR& n_VkSurfaceFullScreenExclusiveWin32InfoEXT(Aref<S_SurfaceFullScreenExclusiveWin32InfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_PhysicalDeviceSurfaceInfo2KHR& n_VkSurfaceFullScreenExclusiveInfoEXT(Aref<S_SurfaceFullScreenExclusiveInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
};
struct S_PhysicalDeviceSurfaceInfo2KHR : public VkPhysicalDeviceSurfaceInfo2KHR {
public:
    using Otype = VkPhysicalDeviceSurfaceInfo2KHR;
public:
    S_PhysicalDeviceSurfaceInfo2KHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDeviceSurfaceInfo2KHR(
        VkSurfaceKHR surface_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR,
        nullptr,
        surface_
    } { }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_PhysicalDeviceSurfaceInfo2KHR& n_VkSurfaceFullScreenExclusiveWin32InfoEXT(Aref<S_SurfaceFullScreenExclusiveWin32InfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_PhysicalDeviceSurfaceInfo2KHR& n_VkSurfaceFullScreenExclusiveInfoEXT(Aref<S_SurfaceFullScreenExclusiveInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    S_PhysicalDeviceSurfaceInfo2KHR& set_next(N_PhysicalDeviceSurfaceInfo2KHR& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_PhysicalDeviceSurfaceInfo2KHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDeviceSurfaceInfo2KHR*() { return this; }
    inL operator S_PhysicalDeviceSurfaceInfo2KHR const* () const { return const_cast<S_PhysicalDeviceSurfaceInfo2KHR const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDeviceSurfaceInfo2KHR> { using T = S_PhysicalDeviceSurfaceInfo2KHR; };
struct S_CmdReserveSpaceForCommandsInfoNVX : public VkCmdReserveSpaceForCommandsInfoNVX {
public:
    using Otype = VkCmdReserveSpaceForCommandsInfoNVX;
public:
    S_CmdReserveSpaceForCommandsInfoNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_CmdReserveSpaceForCommandsInfoNVX(
        VkObjectTableNVX objectTable_= { },
        VkIndirectCommandsLayoutNVX indirectCommandsLayout_= { },
        uint32_t maxSequencesCount_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX,
        nullptr,
        objectTable_,
        indirectCommandsLayout_,
        maxSequencesCount_
    } { }
    inL S_CmdReserveSpaceForCommandsInfoNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_CmdReserveSpaceForCommandsInfoNVX*() { return this; }
    inL operator S_CmdReserveSpaceForCommandsInfoNVX const* () const { return const_cast<S_CmdReserveSpaceForCommandsInfoNVX const*>(this); }
};
template<> struct detail::names_map<VkCmdReserveSpaceForCommandsInfoNVX> { using T = S_CmdReserveSpaceForCommandsInfoNVX; };
struct S_DisplayModeProperties2KHR : public VkDisplayModeProperties2KHR {
public:
    using Otype = VkDisplayModeProperties2KHR;
public:
    S_DisplayModeProperties2KHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayModeProperties2KHR(
        S_DisplayModePropertiesKHR displayModeProperties_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR,
        nullptr,
        displayModeProperties_
    } { }
    inL S_DisplayModeProperties2KHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayModeProperties2KHR*() { return this; }
    inL operator S_DisplayModeProperties2KHR const* () const { return const_cast<S_DisplayModeProperties2KHR const*>(this); }
};
template<> struct detail::names_map<VkDisplayModeProperties2KHR> { using T = S_DisplayModeProperties2KHR; };
struct S_DescriptorImageInfo : public VkDescriptorImageInfo {
public:
    using Otype = VkDescriptorImageInfo;
public:
    S_DescriptorImageInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorImageInfo(
        VkSampler sampler_= { },
        VkImageView imageView_= { },
        E_ImageLayout imageLayout_= { }
    ) : Otype{
        sampler_,
        imageView_,
        imageLayout_
    } { }
    inL S_DescriptorImageInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorImageInfo*() { return this; }
    inL operator S_DescriptorImageInfo const* () const { return const_cast<S_DescriptorImageInfo const*>(this); }
};
template<> struct detail::names_map<VkDescriptorImageInfo> { using T = S_DescriptorImageInfo; };
struct S_SparseBufferMemoryBindInfo : public VkSparseBufferMemoryBindInfo {
public:
    using Otype = VkSparseBufferMemoryBindInfo;
public:
    S_SparseBufferMemoryBindInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_SparseBufferMemoryBindInfo(
        VkBuffer buffer_= { },
        Array_general<S_SparseMemoryBind> pBinds_= { }
    ) : Otype{
        buffer_,
        pBinds_.size(),
        reinterpret_cast<VkSparseMemoryBind*>(pBinds_.data())
    } { }
    inL S_SparseBufferMemoryBindInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SparseBufferMemoryBindInfo*() { return this; }
    inL operator S_SparseBufferMemoryBindInfo const* () const { return const_cast<S_SparseBufferMemoryBindInfo const*>(this); }
};
template<> struct detail::names_map<VkSparseBufferMemoryBindInfo> { using T = S_SparseBufferMemoryBindInfo; };
struct N_RenderPassCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_RenderPassCreateInfo& n_VkRenderPassInputAttachmentAspectCreateInfo(Aref<S_RenderPassInputAttachmentAspectCreateInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_RenderPassCreateInfo& n_VkRenderPassFragmentDensityMapCreateInfoEXT(Aref<S_RenderPassFragmentDensityMapCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_RenderPassCreateInfo& n_VkRenderPassMultiviewCreateInfo(Aref<S_RenderPassMultiviewCreateInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_RenderPassCreateInfo : public VkRenderPassCreateInfo {
public:
    using Otype = VkRenderPassCreateInfo;
public:
    S_RenderPassCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_RenderPassCreateInfo(
        VkRenderPassCreateFlags flags_= { },
        Array_general<S_AttachmentDescription> pAttachments_= { },
        Array_general<S_SubpassDescription> pSubpasses_= { },
        Array_general<S_SubpassDependency> pDependencies_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,
        nullptr,
        flags_,
        pAttachments_.size(),
        reinterpret_cast<VkAttachmentDescription*>(pAttachments_.data()),
        pSubpasses_.size(),
        reinterpret_cast<VkSubpassDescription*>(pSubpasses_.data()),
        pDependencies_.size(),
        reinterpret_cast<VkSubpassDependency*>(pDependencies_.data())
    } { }
    S_RenderPassCreateInfo& set_next(N_RenderPassCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_RenderPassCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_RenderPassCreateInfo*() { return this; }
    inL operator S_RenderPassCreateInfo const* () const { return const_cast<S_RenderPassCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkRenderPassCreateInfo> { using T = S_RenderPassCreateInfo; };
struct S_ExportSemaphoreCreateInfo : public VkExportSemaphoreCreateInfo {
public:
    using Otype = VkExportSemaphoreCreateInfo;
public:
    S_ExportSemaphoreCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_ExportSemaphoreCreateInfo(
        VkExternalSemaphoreHandleTypeFlags handleTypes_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
        nullptr,
        handleTypes_
    } { }
    inL S_ExportSemaphoreCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ExportSemaphoreCreateInfo*() { return this; }
    inL operator S_ExportSemaphoreCreateInfo const* () const { return const_cast<S_ExportSemaphoreCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkExportSemaphoreCreateInfo> { using T = S_ExportSemaphoreCreateInfo; };
struct N_SemaphoreCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_SemaphoreCreateInfo& n_VkExportSemaphoreWin32HandleInfoKHR(Aref<S_ExportSemaphoreWin32HandleInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    inL N_SemaphoreCreateInfo& n_VkExportSemaphoreCreateInfo(Aref<S_ExportSemaphoreCreateInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_SemaphoreCreateInfo : public VkSemaphoreCreateInfo {
public:
    using Otype = VkSemaphoreCreateInfo;
public:
    S_SemaphoreCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_SemaphoreCreateInfo(
        VkSemaphoreCreateFlags flags_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
        nullptr,
        flags_
    } { }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_SemaphoreCreateInfo& n_VkExportSemaphoreWin32HandleInfoKHR(Aref<S_ExportSemaphoreWin32HandleInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    S_SemaphoreCreateInfo& set_next(N_SemaphoreCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_SemaphoreCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SemaphoreCreateInfo*() { return this; }
    inL operator S_SemaphoreCreateInfo const* () const { return const_cast<S_SemaphoreCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkSemaphoreCreateInfo> { using T = S_SemaphoreCreateInfo; };
struct S_PerformanceOverrideInfoINTEL : public VkPerformanceOverrideInfoINTEL {
public:
    using Otype = VkPerformanceOverrideInfoINTEL;
public:
    S_PerformanceOverrideInfoINTEL(Otype& origin_obj_):Otype(origin_obj_){}
    S_PerformanceOverrideInfoINTEL(
        E_PerformanceOverrideTypeINTEL type_= { },
        VkBool32 enable_= { },
        uint64_t parameter_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL,
        nullptr,
        type_,
        enable_,
        parameter_
    } { }
    inL S_PerformanceOverrideInfoINTEL& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PerformanceOverrideInfoINTEL*() { return this; }
    inL operator S_PerformanceOverrideInfoINTEL const* () const { return const_cast<S_PerformanceOverrideInfoINTEL const*>(this); }
};
template<> struct detail::names_map<VkPerformanceOverrideInfoINTEL> { using T = S_PerformanceOverrideInfoINTEL; };
struct S_CheckpointDataNV : public VkCheckpointDataNV {
public:
    using Otype = VkCheckpointDataNV;
public:
    S_CheckpointDataNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_CheckpointDataNV(
        F_PipelineStage stage_= { },
        Aptr<void> pCheckpointMarker_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV,
        nullptr,
        stage_,
        pCheckpointMarker_
    } { }
    inL S_CheckpointDataNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_CheckpointDataNV*() { return this; }
    inL operator S_CheckpointDataNV const* () const { return const_cast<S_CheckpointDataNV const*>(this); }
};
template<> struct detail::names_map<VkCheckpointDataNV> { using T = S_CheckpointDataNV; };

# if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct S_AndroidSurfaceCreateInfoKHR : public VkAndroidSurfaceCreateInfoKHR {
public:
    using Otype = VkAndroidSurfaceCreateInfoKHR;
public:
    S_AndroidSurfaceCreateInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_AndroidSurfaceCreateInfoKHR(
        VkAndroidSurfaceCreateFlagsKHR flags_= { },
        Aptr<ANativeWindow> window_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR,
        nullptr,
        flags_,
        window_
    } { }
    inL S_AndroidSurfaceCreateInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_AndroidSurfaceCreateInfoKHR*() { return this; }
    inL operator S_AndroidSurfaceCreateInfoKHR const* () const { return const_cast<S_AndroidSurfaceCreateInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkAndroidSurfaceCreateInfoKHR> { using T = S_AndroidSurfaceCreateInfoKHR; };

#endif
struct S_DrmFormatModifierPropertiesListEXT : public VkDrmFormatModifierPropertiesListEXT {
public:
    using Otype = VkDrmFormatModifierPropertiesListEXT;
public:
    S_DrmFormatModifierPropertiesListEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DrmFormatModifierPropertiesListEXT(
        Array_general<S_DrmFormatModifierPropertiesEXT> pDrmFormatModifierProperties_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
        nullptr,
        pDrmFormatModifierProperties_.size(),
        reinterpret_cast<VkDrmFormatModifierPropertiesEXT*>(pDrmFormatModifierProperties_.data())
    } { }
    inL S_DrmFormatModifierPropertiesListEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DrmFormatModifierPropertiesListEXT*() { return this; }
    inL operator S_DrmFormatModifierPropertiesListEXT const* () const { return const_cast<S_DrmFormatModifierPropertiesListEXT const*>(this); }
};
template<> struct detail::names_map<VkDrmFormatModifierPropertiesListEXT> { using T = S_DrmFormatModifierPropertiesListEXT; };
struct S_DisplayPowerInfoEXT : public VkDisplayPowerInfoEXT {
public:
    using Otype = VkDisplayPowerInfoEXT;
public:
    S_DisplayPowerInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DisplayPowerInfoEXT(
        E_DisplayPowerStateEXT powerState_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT,
        nullptr,
        powerState_
    } { }
    inL S_DisplayPowerInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DisplayPowerInfoEXT*() { return this; }
    inL operator S_DisplayPowerInfoEXT const* () const { return const_cast<S_DisplayPowerInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDisplayPowerInfoEXT> { using T = S_DisplayPowerInfoEXT; };
struct S_ShaderStatisticsInfoAMD : public VkShaderStatisticsInfoAMD {
public:
    using Otype = VkShaderStatisticsInfoAMD;
public:
    S_ShaderStatisticsInfoAMD(Otype& origin_obj_):Otype(origin_obj_){}
    S_ShaderStatisticsInfoAMD(
        VkShaderStageFlags shaderStageMask_= { },
        S_ShaderResourceUsageAMD resourceUsage_= { },
        uint32_t numPhysicalVgprs_= { },
        uint32_t numPhysicalSgprs_= { },
        uint32_t numAvailableVgprs_= { },
        uint32_t numAvailableSgprs_= { },
        std::array<uint32_t,3> computeWorkGroupSize_= { }
    ) : Otype{
        shaderStageMask_,
        resourceUsage_,
        numPhysicalVgprs_,
        numPhysicalSgprs_,
        numAvailableVgprs_,
        numAvailableSgprs_,
        { }
    } { 
        ::memcpy(&computeWorkGroupSize[0], computeWorkGroupSize_.data(), computeWorkGroupSize_.size() );
    }
    inL S_ShaderStatisticsInfoAMD& 
        set_computeWorkGroupSize(std::array<uint32_t,3> computeWorkGroupSize_)
        {  return *this; }
    inL S_ShaderStatisticsInfoAMD& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ShaderStatisticsInfoAMD*() { return this; }
    inL operator S_ShaderStatisticsInfoAMD const* () const { return const_cast<S_ShaderStatisticsInfoAMD const*>(this); }
};
template<> struct detail::names_map<VkShaderStatisticsInfoAMD> { using T = S_ShaderStatisticsInfoAMD; };

# if defined(VK_USE_PLATFORM_GGP)
struct S_StreamDescriptorSurfaceCreateInfoGGP : public VkStreamDescriptorSurfaceCreateInfoGGP {
public:
    using Otype = VkStreamDescriptorSurfaceCreateInfoGGP;
public:
    S_StreamDescriptorSurfaceCreateInfoGGP(Otype& origin_obj_):Otype(origin_obj_){}
    S_StreamDescriptorSurfaceCreateInfoGGP(
        VkStreamDescriptorSurfaceCreateFlagsGGP flags_= { },
        GgpStreamDescriptor streamDescriptor_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP,
        nullptr,
        flags_,
        streamDescriptor_
    } { }
    inL S_StreamDescriptorSurfaceCreateInfoGGP& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_StreamDescriptorSurfaceCreateInfoGGP*() { return this; }
    inL operator S_StreamDescriptorSurfaceCreateInfoGGP const* () const { return const_cast<S_StreamDescriptorSurfaceCreateInfoGGP const*>(this); }
};
template<> struct detail::names_map<VkStreamDescriptorSurfaceCreateInfoGGP> { using T = S_StreamDescriptorSurfaceCreateInfoGGP; };

#endif
struct S_BufferCopy : public VkBufferCopy {
public:
    using Otype = VkBufferCopy;
public:
    S_BufferCopy(Otype& origin_obj_):Otype(origin_obj_){}
    S_BufferCopy(
        VkDeviceSize srcOffset_= { },
        VkDeviceSize dstOffset_= { },
        VkDeviceSize size_= { }
    ) : Otype{
        srcOffset_,
        dstOffset_,
        size_
    } { }
    inL S_BufferCopy& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BufferCopy*() { return this; }
    inL operator S_BufferCopy const* () const { return const_cast<S_BufferCopy const*>(this); }
};
template<> struct detail::names_map<VkBufferCopy> { using T = S_BufferCopy; };
struct S_SurfaceCapabilities2EXT : public VkSurfaceCapabilities2EXT {
public:
    using Otype = VkSurfaceCapabilities2EXT;
public:
    S_SurfaceCapabilities2EXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_SurfaceCapabilities2EXT(
        uint32_t minImageCount_= { },
        uint32_t maxImageCount_= { },
        S_Extent2D currentExtent_= { },
        S_Extent2D minImageExtent_= { },
        S_Extent2D maxImageExtent_= { },
        uint32_t maxImageArrayLayers_= { },
        VkSurfaceTransformFlagsKHR supportedTransforms_= { },
        F_SurfaceTransformKHR currentTransform_= { },
        VkCompositeAlphaFlagsKHR supportedCompositeAlpha_= { },
        VkImageUsageFlags supportedUsageFlags_= { },
        VkSurfaceCounterFlagsEXT supportedSurfaceCounters_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
        nullptr,
        minImageCount_,
        maxImageCount_,
        currentExtent_,
        minImageExtent_,
        maxImageExtent_,
        maxImageArrayLayers_,
        supportedTransforms_,
        currentTransform_,
        supportedCompositeAlpha_,
        supportedUsageFlags_,
        supportedSurfaceCounters_
    } { }
    inL S_SurfaceCapabilities2EXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SurfaceCapabilities2EXT*() { return this; }
    inL operator S_SurfaceCapabilities2EXT const* () const { return const_cast<S_SurfaceCapabilities2EXT const*>(this); }
};
template<> struct detail::names_map<VkSurfaceCapabilities2EXT> { using T = S_SurfaceCapabilities2EXT; };
struct S_CommandPoolCreateInfo : public VkCommandPoolCreateInfo {
public:
    using Otype = VkCommandPoolCreateInfo;
public:
    S_CommandPoolCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_CommandPoolCreateInfo(
        VkCommandPoolCreateFlags flags_= { },
        uint32_t queueFamilyIndex_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
        nullptr,
        flags_,
        queueFamilyIndex_
    } { }
    inL S_CommandPoolCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_CommandPoolCreateInfo*() { return this; }
    inL operator S_CommandPoolCreateInfo const* () const { return const_cast<S_CommandPoolCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkCommandPoolCreateInfo> { using T = S_CommandPoolCreateInfo; };
struct N_DeviceQueueCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_DeviceQueueCreateInfo& n_VkDeviceQueueGlobalPriorityCreateInfoEXT(Aref<S_DeviceQueueGlobalPriorityCreateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_DeviceQueueCreateInfo : public VkDeviceQueueCreateInfo {
public:
    using Otype = VkDeviceQueueCreateInfo;
public:
    S_DeviceQueueCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceQueueCreateInfo(
        VkDeviceQueueCreateFlags flags_= { },
        uint32_t queueFamilyIndex_= { },
        Array_general<float> pQueuePriorities_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        nullptr,
        flags_,
        queueFamilyIndex_,
        pQueuePriorities_.size(),
        reinterpret_cast<float*>(pQueuePriorities_.data())
    } { }
    S_DeviceQueueCreateInfo& set_next(N_DeviceQueueCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_DeviceQueueCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceQueueCreateInfo*() { return this; }
    inL operator S_DeviceQueueCreateInfo const* () const { return const_cast<S_DeviceQueueCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkDeviceQueueCreateInfo> { using T = S_DeviceQueueCreateInfo; };
struct N_DeviceCreateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_DeviceCreateInfo& n_VkDeviceGroupDeviceCreateInfo(Aref<S_DeviceGroupDeviceCreateInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceCooperativeMatrixFeaturesNV(Aref<S_PhysicalDeviceCooperativeMatrixFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(Aref<S_PhysicalDeviceBlendOperationAdvancedFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(Aref<S_PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(Aref<S_PhysicalDeviceRepresentativeFragmentTestFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(Aref<S_PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDevice8BitStorageFeaturesKHR(Aref<S_PhysicalDevice8BitStorageFeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR(Aref<S_PhysicalDeviceShaderAtomicInt64FeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(Aref<S_PhysicalDeviceSubgroupSizeControlFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(Aref<S_PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceShadingRateImageFeaturesNV(Aref<S_PhysicalDeviceShadingRateImageFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceHostQueryResetFeaturesEXT(Aref<S_PhysicalDeviceHostQueryResetFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceMeshShaderFeaturesNV(Aref<S_PhysicalDeviceMeshShaderFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceCornerSampledImageFeaturesNV(Aref<S_PhysicalDeviceCornerSampledImageFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceMultiviewFeatures(Aref<S_PhysicalDeviceMultiviewFeatures> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceProtectedMemoryFeatures(Aref<S_PhysicalDeviceProtectedMemoryFeatures> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDevice16BitStorageFeatures(Aref<S_PhysicalDevice16BitStorageFeatures> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceImagelessFramebufferFeaturesKHR(Aref<S_PhysicalDeviceImagelessFramebufferFeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceExclusiveScissorFeaturesNV(Aref<S_PhysicalDeviceExclusiveScissorFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR(Aref<S_PhysicalDeviceUniformBufferStandardLayoutFeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(Aref<S_PhysicalDeviceYcbcrImageArraysFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(Aref<S_PhysicalDeviceIndexTypeUint8FeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceDepthClipEnableFeaturesEXT(Aref<S_PhysicalDeviceDepthClipEnableFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(Aref<S_PhysicalDeviceTexelBufferAlignmentFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(Aref<S_PhysicalDeviceDescriptorIndexingFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT(Aref<S_PhysicalDeviceScalarBlockLayoutFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceShaderDrawParametersFeatures(Aref<S_PhysicalDeviceShaderDrawParametersFeatures> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceVariablePointersFeatures(Aref<S_PhysicalDeviceVariablePointersFeatures> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(Aref<S_PhysicalDeviceShaderSMBuiltinsFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceConditionalRenderingFeaturesEXT(Aref<S_PhysicalDeviceConditionalRenderingFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkDeviceMemoryOverallocationCreateInfoAMD(Aref<S_DeviceMemoryOverallocationCreateInfoAMD> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceShaderImageFootprintFeaturesNV(Aref<S_PhysicalDeviceShaderImageFootprintFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR(Aref<S_PhysicalDeviceShaderFloat16Int8FeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(Aref<S_PhysicalDeviceInlineUniformBlockFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(Aref<S_PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceFeatures2(Aref<S_PhysicalDeviceFeatures2> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceASTCDecodeFeaturesEXT(Aref<S_PhysicalDeviceASTCDecodeFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(Aref<S_PhysicalDeviceBufferDeviceAddressFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceLineRasterizationFeaturesEXT(Aref<S_PhysicalDeviceLineRasterizationFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(Aref<S_PhysicalDevicePipelineExecutablePropertiesFeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceSamplerYcbcrConversionFeatures(Aref<S_PhysicalDeviceSamplerYcbcrConversionFeatures> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(Aref<S_PhysicalDeviceFragmentShaderBarycentricFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceCoverageReductionModeFeaturesNV(Aref<S_PhysicalDeviceCoverageReductionModeFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(Aref<S_PhysicalDeviceComputeShaderDerivativesFeaturesNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceTransformFeedbackFeaturesEXT(Aref<S_PhysicalDeviceTransformFeedbackFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR(Aref<S_PhysicalDeviceVulkanMemoryModelFeaturesKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceCoherentMemoryFeaturesAMD(Aref<S_PhysicalDeviceCoherentMemoryFeaturesAMD> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(Aref<S_PhysicalDeviceFragmentDensityMapFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(Aref<S_PhysicalDeviceVertexAttributeDivisorFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(Aref<S_PhysicalDeviceFragmentShaderInterlockFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_DeviceCreateInfo& n_VkPhysicalDeviceMemoryPriorityFeaturesEXT(Aref<S_PhysicalDeviceMemoryPriorityFeaturesEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_DeviceCreateInfo : public VkDeviceCreateInfo {
public:
    using Otype = VkDeviceCreateInfo;
public:
    S_DeviceCreateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_DeviceCreateInfo(
        VkDeviceCreateFlags flags_= { },
        Array_general<S_DeviceQueueCreateInfo> pQueueCreateInfos_= { },
        Array_general<char*> ppEnabledLayerNames_= { },
        Array_general<char*> ppEnabledExtensionNames_= { },
        Aptr<S_PhysicalDeviceFeatures> pEnabledFeatures_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        nullptr,
        flags_,
        pQueueCreateInfos_.size(),
        reinterpret_cast<VkDeviceQueueCreateInfo*>(pQueueCreateInfos_.data()),
        ppEnabledLayerNames_.size(),
        reinterpret_cast<char**>(ppEnabledLayerNames_.data()),
        ppEnabledExtensionNames_.size(),
        reinterpret_cast<char**>(ppEnabledExtensionNames_.data()),
        pEnabledFeatures_
    } { }
    S_DeviceCreateInfo& set_next(N_DeviceCreateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_DeviceCreateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DeviceCreateInfo*() { return this; }
    inL operator S_DeviceCreateInfo const* () const { return const_cast<S_DeviceCreateInfo const*>(this); }
};
template<> struct detail::names_map<VkDeviceCreateInfo> { using T = S_DeviceCreateInfo; };

# if defined(VK_USE_PLATFORM_ANDROID_KHR)
struct S_PhysicalDevicePresentationPropertiesANDROID : public VkPhysicalDevicePresentationPropertiesANDROID {
public:
    using Otype = VkPhysicalDevicePresentationPropertiesANDROID;
public:
    S_PhysicalDevicePresentationPropertiesANDROID(Otype& origin_obj_):Otype(origin_obj_){}
    S_PhysicalDevicePresentationPropertiesANDROID(
        VkBool32 sharedImage_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID,
        nullptr,
        sharedImage_
    } { }
    inL S_PhysicalDevicePresentationPropertiesANDROID& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PhysicalDevicePresentationPropertiesANDROID*() { return this; }
    inL operator S_PhysicalDevicePresentationPropertiesANDROID const* () const { return const_cast<S_PhysicalDevicePresentationPropertiesANDROID const*>(this); }
};
template<> struct detail::names_map<VkPhysicalDevicePresentationPropertiesANDROID> { using T = S_PhysicalDevicePresentationPropertiesANDROID; };

#endif
struct S_CooperativeMatrixPropertiesNV : public VkCooperativeMatrixPropertiesNV {
public:
    using Otype = VkCooperativeMatrixPropertiesNV;
public:
    S_CooperativeMatrixPropertiesNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_CooperativeMatrixPropertiesNV(
        uint32_t MSize_= { },
        uint32_t NSize_= { },
        uint32_t KSize_= { },
        E_ComponentTypeNV AType_= { },
        E_ComponentTypeNV BType_= { },
        E_ComponentTypeNV CType_= { },
        E_ComponentTypeNV DType_= { },
        E_ScopeNV scope_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV,
        nullptr,
        MSize_,
        NSize_,
        KSize_,
        AType_,
        BType_,
        CType_,
        DType_,
        scope_
    } { }
    inL S_CooperativeMatrixPropertiesNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_CooperativeMatrixPropertiesNV*() { return this; }
    inL operator S_CooperativeMatrixPropertiesNV const* () const { return const_cast<S_CooperativeMatrixPropertiesNV const*>(this); }
};
template<> struct detail::names_map<VkCooperativeMatrixPropertiesNV> { using T = S_CooperativeMatrixPropertiesNV; };
struct S_ImageDrmFormatModifierPropertiesEXT : public VkImageDrmFormatModifierPropertiesEXT {
public:
    using Otype = VkImageDrmFormatModifierPropertiesEXT;
public:
    S_ImageDrmFormatModifierPropertiesEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageDrmFormatModifierPropertiesEXT(
        uint64_t drmFormatModifier_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
        nullptr,
        drmFormatModifier_
    } { }
    inL S_ImageDrmFormatModifierPropertiesEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageDrmFormatModifierPropertiesEXT*() { return this; }
    inL operator S_ImageDrmFormatModifierPropertiesEXT const* () const { return const_cast<S_ImageDrmFormatModifierPropertiesEXT const*>(this); }
};
template<> struct detail::names_map<VkImageDrmFormatModifierPropertiesEXT> { using T = S_ImageDrmFormatModifierPropertiesEXT; };
struct N_DescriptorSetAllocateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_DescriptorSetAllocateInfo& n_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(Aref<S_DescriptorSetVariableDescriptorCountAllocateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_DescriptorSetAllocateInfo : public VkDescriptorSetAllocateInfo {
public:
    using Otype = VkDescriptorSetAllocateInfo;
public:
    S_DescriptorSetAllocateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_DescriptorSetAllocateInfo(
        VkDescriptorPool descriptorPool_= { },
        Array_general<VkDescriptorSetLayout> pSetLayouts_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
        nullptr,
        descriptorPool_,
        pSetLayouts_.size(),
        reinterpret_cast<VkDescriptorSetLayout*>(pSetLayouts_.data())
    } { }
    S_DescriptorSetAllocateInfo& set_next(N_DescriptorSetAllocateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_DescriptorSetAllocateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DescriptorSetAllocateInfo*() { return this; }
    inL operator S_DescriptorSetAllocateInfo const* () const { return const_cast<S_DescriptorSetAllocateInfo const*>(this); }
};
template<> struct detail::names_map<VkDescriptorSetAllocateInfo> { using T = S_DescriptorSetAllocateInfo; };
struct S_FormatProperties : public VkFormatProperties {
public:
    using Otype = VkFormatProperties;
public:
    S_FormatProperties(Otype& origin_obj_):Otype(origin_obj_){}
    S_FormatProperties(
        VkFormatFeatureFlags linearTilingFeatures_= { },
        VkFormatFeatureFlags optimalTilingFeatures_= { },
        VkFormatFeatureFlags bufferFeatures_= { }
    ) : Otype{
        linearTilingFeatures_,
        optimalTilingFeatures_,
        bufferFeatures_
    } { }
    inL S_FormatProperties& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_FormatProperties*() { return this; }
    inL operator S_FormatProperties const* () const { return const_cast<S_FormatProperties const*>(this); }
};
template<> struct detail::names_map<VkFormatProperties> { using T = S_FormatProperties; };
struct N_FormatProperties2{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_FormatProperties2& n_VkDrmFormatModifierPropertiesListEXT(Aref<S_DrmFormatModifierPropertiesListEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_FormatProperties2 : public VkFormatProperties2 {
public:
    using Otype = VkFormatProperties2;
public:
    S_FormatProperties2(Otype& origin_obj_):Otype(origin_obj_){}
    S_FormatProperties2(
        S_FormatProperties formatProperties_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
        nullptr,
        formatProperties_
    } { }
    S_FormatProperties2& set_next(N_FormatProperties2& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_FormatProperties2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_FormatProperties2*() { return this; }
    inL operator S_FormatProperties2 const* () const { return const_cast<S_FormatProperties2 const*>(this); }
};
template<> struct detail::names_map<VkFormatProperties2> { using T = S_FormatProperties2; };
struct S_IndirectCommandsTokenNVX : public VkIndirectCommandsTokenNVX {
public:
    using Otype = VkIndirectCommandsTokenNVX;
public:
    S_IndirectCommandsTokenNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_IndirectCommandsTokenNVX(
        E_IndirectCommandsTokenTypeNVX tokenType_= { },
        VkBuffer buffer_= { },
        VkDeviceSize offset_= { }
    ) : Otype{
        tokenType_,
        buffer_,
        offset_
    } { }
    inL S_IndirectCommandsTokenNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_IndirectCommandsTokenNVX*() { return this; }
    inL operator S_IndirectCommandsTokenNVX const* () const { return const_cast<S_IndirectCommandsTokenNVX const*>(this); }
};
template<> struct detail::names_map<VkIndirectCommandsTokenNVX> { using T = S_IndirectCommandsTokenNVX; };
struct S_CmdProcessCommandsInfoNVX : public VkCmdProcessCommandsInfoNVX {
public:
    using Otype = VkCmdProcessCommandsInfoNVX;
public:
    S_CmdProcessCommandsInfoNVX(Otype& origin_obj_):Otype(origin_obj_){}
    S_CmdProcessCommandsInfoNVX(
        VkObjectTableNVX objectTable_= { },
        VkIndirectCommandsLayoutNVX indirectCommandsLayout_= { },
        Array_general<S_IndirectCommandsTokenNVX> pIndirectCommandsTokens_= { },
        uint32_t maxSequencesCount_= { },
        VkCommandBuffer targetCommandBuffer_= { },
        VkBuffer sequencesCountBuffer_= { },
        VkDeviceSize sequencesCountOffset_= { },
        VkBuffer sequencesIndexBuffer_= { },
        VkDeviceSize sequencesIndexOffset_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX,
        nullptr,
        objectTable_,
        indirectCommandsLayout_,
        pIndirectCommandsTokens_.size(),
        reinterpret_cast<VkIndirectCommandsTokenNVX*>(pIndirectCommandsTokens_.data()),
        maxSequencesCount_,
        targetCommandBuffer_,
        sequencesCountBuffer_,
        sequencesCountOffset_,
        sequencesIndexBuffer_,
        sequencesIndexOffset_
    } { }
    inL S_CmdProcessCommandsInfoNVX& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_CmdProcessCommandsInfoNVX*() { return this; }
    inL operator S_CmdProcessCommandsInfoNVX const* () const { return const_cast<S_CmdProcessCommandsInfoNVX const*>(this); }
};
template<> struct detail::names_map<VkCmdProcessCommandsInfoNVX> { using T = S_CmdProcessCommandsInfoNVX; };
struct N_MemoryAllocateInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_MemoryAllocateInfo& n_VkMemoryPriorityAllocateInfoEXT(Aref<S_MemoryPriorityAllocateInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# if defined(VK_USE_PLATFORM_ANDROID_KHR)
    inL N_MemoryAllocateInfo& n_VkImportAndroidHardwareBufferInfoANDROID(Aref<S_ImportAndroidHardwareBufferInfoANDROID> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_MemoryAllocateInfo& n_VkImportMemoryWin32HandleInfoKHR(Aref<S_ImportMemoryWin32HandleInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    inL N_MemoryAllocateInfo& n_VkImportMemoryFdInfoKHR(Aref<S_ImportMemoryFdInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_MemoryAllocateInfo& n_VkExportMemoryWin32HandleInfoKHR(Aref<S_ExportMemoryWin32HandleInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    inL N_MemoryAllocateInfo& n_VkDedicatedAllocationMemoryAllocateInfoNV(Aref<S_DedicatedAllocationMemoryAllocateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_MemoryAllocateInfo& n_VkImportMemoryHostPointerInfoEXT(Aref<S_ImportMemoryHostPointerInfoEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_MemoryAllocateInfo& n_VkExportMemoryWin32HandleInfoNV(Aref<S_ExportMemoryWin32HandleInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL N_MemoryAllocateInfo& n_VkImportMemoryWin32HandleInfoNV(Aref<S_ImportMemoryWin32HandleInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    inL N_MemoryAllocateInfo& n_VkExportMemoryAllocateInfo(Aref<S_ExportMemoryAllocateInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_MemoryAllocateInfo& n_VkMemoryAllocateFlagsInfo(Aref<S_MemoryAllocateFlagsInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_MemoryAllocateInfo& n_VkMemoryDedicatedAllocateInfo(Aref<S_MemoryDedicatedAllocateInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_MemoryAllocateInfo& n_VkExportMemoryAllocateInfoNV(Aref<S_ExportMemoryAllocateInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_MemoryAllocateInfo : public VkMemoryAllocateInfo {
public:
    using Otype = VkMemoryAllocateInfo;
public:
    S_MemoryAllocateInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_MemoryAllocateInfo(
        VkDeviceSize allocationSize_= { },
        uint32_t memoryTypeIndex_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        nullptr,
        allocationSize_,
        memoryTypeIndex_
    } { }
# if defined(VK_USE_PLATFORM_ANDROID_KHR)
    inL S_MemoryAllocateInfo& n_VkImportAndroidHardwareBufferInfoANDROID(Aref<S_ImportAndroidHardwareBufferInfoANDROID> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_MemoryAllocateInfo& n_VkImportMemoryWin32HandleInfoKHR(Aref<S_ImportMemoryWin32HandleInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_MemoryAllocateInfo& n_VkExportMemoryWin32HandleInfoKHR(Aref<S_ExportMemoryWin32HandleInfoKHR> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_MemoryAllocateInfo& n_VkExportMemoryWin32HandleInfoNV(Aref<S_ExportMemoryWin32HandleInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
# if defined(VK_USE_PLATFORM_WIN32_KHR)
    inL S_MemoryAllocateInfo& n_VkImportMemoryWin32HandleInfoNV(Aref<S_ImportMemoryWin32HandleInfoNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
# endif
    S_MemoryAllocateInfo& set_next(N_MemoryAllocateInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_MemoryAllocateInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MemoryAllocateInfo*() { return this; }
    inL operator S_MemoryAllocateInfo const* () const { return const_cast<S_MemoryAllocateInfo const*>(this); }
};
template<> struct detail::names_map<VkMemoryAllocateInfo> { using T = S_MemoryAllocateInfo; };
struct S_BindAccelerationStructureMemoryInfoNV : public VkBindAccelerationStructureMemoryInfoNV {
public:
    using Otype = VkBindAccelerationStructureMemoryInfoNV;
public:
    S_BindAccelerationStructureMemoryInfoNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_BindAccelerationStructureMemoryInfoNV(
        VkAccelerationStructureNV accelerationStructure_= { },
        VkDeviceMemory memory_= { },
        VkDeviceSize memoryOffset_= { },
        Array_general<uint32_t> pDeviceIndices_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV,
        nullptr,
        accelerationStructure_,
        memory_,
        memoryOffset_,
        pDeviceIndices_.size(),
        reinterpret_cast<uint32_t*>(pDeviceIndices_.data())
    } { }
    inL S_BindAccelerationStructureMemoryInfoNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BindAccelerationStructureMemoryInfoNV*() { return this; }
    inL operator S_BindAccelerationStructureMemoryInfoNV const* () const { return const_cast<S_BindAccelerationStructureMemoryInfoNV const*>(this); }
};
template<> struct detail::names_map<VkBindAccelerationStructureMemoryInfoNV> { using T = S_BindAccelerationStructureMemoryInfoNV; };
struct N_BindSparseInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_BindSparseInfo& n_VkDeviceGroupBindSparseInfo(Aref<S_DeviceGroupBindSparseInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_BindSparseInfo : public VkBindSparseInfo {
public:
    using Otype = VkBindSparseInfo;
public:
    S_BindSparseInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_BindSparseInfo(
        Array_general<VkSemaphore> pWaitSemaphores_= { },
        Array_general<S_SparseBufferMemoryBindInfo> pBufferBinds_= { },
        Array_general<S_SparseImageOpaqueMemoryBindInfo> pImageOpaqueBinds_= { },
        Array_general<S_SparseImageMemoryBindInfo> pImageBinds_= { },
        Array_general<VkSemaphore> pSignalSemaphores_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BIND_SPARSE_INFO,
        nullptr,
        pWaitSemaphores_.size(),
        reinterpret_cast<VkSemaphore*>(pWaitSemaphores_.data()),
        pBufferBinds_.size(),
        reinterpret_cast<VkSparseBufferMemoryBindInfo*>(pBufferBinds_.data()),
        pImageOpaqueBinds_.size(),
        reinterpret_cast<VkSparseImageOpaqueMemoryBindInfo*>(pImageOpaqueBinds_.data()),
        pImageBinds_.size(),
        reinterpret_cast<VkSparseImageMemoryBindInfo*>(pImageBinds_.data()),
        pSignalSemaphores_.size(),
        reinterpret_cast<VkSemaphore*>(pSignalSemaphores_.data())
    } { }
    S_BindSparseInfo& set_next(N_BindSparseInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_BindSparseInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BindSparseInfo*() { return this; }
    inL operator S_BindSparseInfo const* () const { return const_cast<S_BindSparseInfo const*>(this); }
};
template<> struct detail::names_map<VkBindSparseInfo> { using T = S_BindSparseInfo; };
struct N_BindBufferMemoryInfo{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_BindBufferMemoryInfo& n_VkBindBufferMemoryDeviceGroupInfo(Aref<S_BindBufferMemoryDeviceGroupInfo> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_BindBufferMemoryInfo : public VkBindBufferMemoryInfo {
public:
    using Otype = VkBindBufferMemoryInfo;
public:
    S_BindBufferMemoryInfo(Otype& origin_obj_):Otype(origin_obj_){}
    S_BindBufferMemoryInfo(
        VkBuffer buffer_= { },
        VkDeviceMemory memory_= { },
        VkDeviceSize memoryOffset_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
        nullptr,
        buffer_,
        memory_,
        memoryOffset_
    } { }
    S_BindBufferMemoryInfo& set_next(N_BindBufferMemoryInfo& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_BindBufferMemoryInfo& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_BindBufferMemoryInfo*() { return this; }
    inL operator S_BindBufferMemoryInfo const* () const { return const_cast<S_BindBufferMemoryInfo const*>(this); }
};
template<> struct detail::names_map<VkBindBufferMemoryInfo> { using T = S_BindBufferMemoryInfo; };
struct S_WriteDescriptorSetAccelerationStructureNV : public VkWriteDescriptorSetAccelerationStructureNV {
public:
    using Otype = VkWriteDescriptorSetAccelerationStructureNV;
public:
    S_WriteDescriptorSetAccelerationStructureNV(Otype& origin_obj_):Otype(origin_obj_){}
    S_WriteDescriptorSetAccelerationStructureNV(
        Array_general<VkAccelerationStructureNV> pAccelerationStructures_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
        nullptr,
        pAccelerationStructures_.size(),
        reinterpret_cast<VkAccelerationStructureNV*>(pAccelerationStructures_.data())
    } { }
    inL S_WriteDescriptorSetAccelerationStructureNV& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_WriteDescriptorSetAccelerationStructureNV*() { return this; }
    inL operator S_WriteDescriptorSetAccelerationStructureNV const* () const { return const_cast<S_WriteDescriptorSetAccelerationStructureNV const*>(this); }
};
template<> struct detail::names_map<VkWriteDescriptorSetAccelerationStructureNV> { using T = S_WriteDescriptorSetAccelerationStructureNV; };
struct S_DebugUtilsMessengerCallbackDataEXT : public VkDebugUtilsMessengerCallbackDataEXT {
public:
    using Otype = VkDebugUtilsMessengerCallbackDataEXT;
public:
    S_DebugUtilsMessengerCallbackDataEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DebugUtilsMessengerCallbackDataEXT(
        VkDebugUtilsMessengerCallbackDataFlagsEXT flags_= { },
        Aptr<char> pMessageIdName_= { },
        int32_t messageIdNumber_= { },
        Aptr<char> pMessage_= { },
        Array_general<S_DebugUtilsLabelEXT> pQueueLabels_= { },
        Array_general<S_DebugUtilsLabelEXT> pCmdBufLabels_= { },
        Array_general<S_DebugUtilsObjectNameInfoEXT> pObjects_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
        nullptr,
        flags_,
        pMessageIdName_,
        messageIdNumber_,
        pMessage_,
        pQueueLabels_.size(),
        reinterpret_cast<VkDebugUtilsLabelEXT*>(pQueueLabels_.data()),
        pCmdBufLabels_.size(),
        reinterpret_cast<VkDebugUtilsLabelEXT*>(pCmdBufLabels_.data()),
        pObjects_.size(),
        reinterpret_cast<VkDebugUtilsObjectNameInfoEXT*>(pObjects_.data())
    } { }
    inL S_DebugUtilsMessengerCallbackDataEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DebugUtilsMessengerCallbackDataEXT*() { return this; }
    inL operator S_DebugUtilsMessengerCallbackDataEXT const* () const { return const_cast<S_DebugUtilsMessengerCallbackDataEXT const*>(this); }
};
template<> struct detail::names_map<VkDebugUtilsMessengerCallbackDataEXT> { using T = S_DebugUtilsMessengerCallbackDataEXT; };
struct S_SparseImageMemoryRequirements2 : public VkSparseImageMemoryRequirements2 {
public:
    using Otype = VkSparseImageMemoryRequirements2;
public:
    S_SparseImageMemoryRequirements2(Otype& origin_obj_):Otype(origin_obj_){}
    S_SparseImageMemoryRequirements2(
        S_SparseImageMemoryRequirements memoryRequirements_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
        nullptr,
        memoryRequirements_
    } { }
    inL S_SparseImageMemoryRequirements2& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_SparseImageMemoryRequirements2*() { return this; }
    inL operator S_SparseImageMemoryRequirements2 const* () const { return const_cast<S_SparseImageMemoryRequirements2 const*>(this); }
};
template<> struct detail::names_map<VkSparseImageMemoryRequirements2> { using T = S_SparseImageMemoryRequirements2; };
struct S_HeadlessSurfaceCreateInfoEXT : public VkHeadlessSurfaceCreateInfoEXT {
public:
    using Otype = VkHeadlessSurfaceCreateInfoEXT;
public:
    S_HeadlessSurfaceCreateInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_HeadlessSurfaceCreateInfoEXT(
        VkHeadlessSurfaceCreateFlagsEXT flags_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT,
        nullptr,
        flags_
    } { }
    inL S_HeadlessSurfaceCreateInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_HeadlessSurfaceCreateInfoEXT*() { return this; }
    inL operator S_HeadlessSurfaceCreateInfoEXT const* () const { return const_cast<S_HeadlessSurfaceCreateInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkHeadlessSurfaceCreateInfoEXT> { using T = S_HeadlessSurfaceCreateInfoEXT; };
struct S_DebugMarkerObjectTagInfoEXT : public VkDebugMarkerObjectTagInfoEXT {
public:
    using Otype = VkDebugMarkerObjectTagInfoEXT;
public:
    S_DebugMarkerObjectTagInfoEXT(Otype& origin_obj_):Otype(origin_obj_){}
    S_DebugMarkerObjectTagInfoEXT(
        E_DebugReportObjectTypeEXT objectType_= { },
        uint64_t object_= { },
        uint64_t tagName_= { },
        Array_general<void> pTag_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
        nullptr,
        objectType_,
        object_,
        tagName_,
        pTag_.size(),
        reinterpret_cast<void*>(pTag_.data())
    } { }
    inL S_DebugMarkerObjectTagInfoEXT& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_DebugMarkerObjectTagInfoEXT*() { return this; }
    inL operator S_DebugMarkerObjectTagInfoEXT const* () const { return const_cast<S_DebugMarkerObjectTagInfoEXT const*>(this); }
};
template<> struct detail::names_map<VkDebugMarkerObjectTagInfoEXT> { using T = S_DebugMarkerObjectTagInfoEXT; };

# if defined(VK_USE_PLATFORM_WAYLAND_KHR)
struct S_WaylandSurfaceCreateInfoKHR : public VkWaylandSurfaceCreateInfoKHR {
public:
    using Otype = VkWaylandSurfaceCreateInfoKHR;
public:
    S_WaylandSurfaceCreateInfoKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_WaylandSurfaceCreateInfoKHR(
        VkWaylandSurfaceCreateFlagsKHR flags_= { },
        Aptr<wl_display> display_= { },
        Aptr<wl_surface> surface_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR,
        nullptr,
        flags_,
        display_,
        surface_
    } { }
    inL S_WaylandSurfaceCreateInfoKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_WaylandSurfaceCreateInfoKHR*() { return this; }
    inL operator S_WaylandSurfaceCreateInfoKHR const* () const { return const_cast<S_WaylandSurfaceCreateInfoKHR const*>(this); }
};
template<> struct detail::names_map<VkWaylandSurfaceCreateInfoKHR> { using T = S_WaylandSurfaceCreateInfoKHR; };

#endif
struct S_ImageBlit : public VkImageBlit {
public:
    using Otype = VkImageBlit;
public:
    S_ImageBlit(Otype& origin_obj_):Otype(origin_obj_){}
    S_ImageBlit(
        S_ImageSubresourceLayers srcSubresource_= { },
        std::array<S_Offset3D,2> srcOffsets_= { },
        S_ImageSubresourceLayers dstSubresource_= { },
        std::array<S_Offset3D,2> dstOffsets_= { }
    ) : Otype{
        srcSubresource_,
        { },
        dstSubresource_,
        { }
    } { 
        ::memcpy(&srcOffsets[0], srcOffsets_.data(), srcOffsets_.size() );
        ::memcpy(&dstOffsets[0], dstOffsets_.data(), dstOffsets_.size() );
    }
    inL S_ImageBlit& 
        set_srcOffsets(std::array<VkOffset3D,2> srcOffsets_)
        {  return *this; }
    inL S_ImageBlit& 
        set_dstOffsets(std::array<VkOffset3D,2> dstOffsets_)
        {  return *this; }
    inL S_ImageBlit& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_ImageBlit*() { return this; }
    inL operator S_ImageBlit const* () const { return const_cast<S_ImageBlit const*>(this); }
};
template<> struct detail::names_map<VkImageBlit> { using T = S_ImageBlit; };

# if defined(VK_USE_PLATFORM_MACOS_MVK)
struct S_MacOSSurfaceCreateInfoMVK : public VkMacOSSurfaceCreateInfoMVK {
public:
    using Otype = VkMacOSSurfaceCreateInfoMVK;
public:
    S_MacOSSurfaceCreateInfoMVK(Otype& origin_obj_):Otype(origin_obj_){}
    S_MacOSSurfaceCreateInfoMVK(
        VkMacOSSurfaceCreateFlagsMVK flags_= { },
        Aptr<void> pView_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK,
        nullptr,
        flags_,
        pView_
    } { }
    inL S_MacOSSurfaceCreateInfoMVK& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_MacOSSurfaceCreateInfoMVK*() { return this; }
    inL operator S_MacOSSurfaceCreateInfoMVK const* () const { return const_cast<S_MacOSSurfaceCreateInfoMVK const*>(this); }
};
template<> struct detail::names_map<VkMacOSSurfaceCreateInfoMVK> { using T = S_MacOSSurfaceCreateInfoMVK; };

#endif
struct S_PerformanceMarkerInfoINTEL : public VkPerformanceMarkerInfoINTEL {
public:
    using Otype = VkPerformanceMarkerInfoINTEL;
public:
    S_PerformanceMarkerInfoINTEL(Otype& origin_obj_):Otype(origin_obj_){}
    S_PerformanceMarkerInfoINTEL(
        uint64_t marker_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL,
        nullptr,
        marker_
    } { }
    inL S_PerformanceMarkerInfoINTEL& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PerformanceMarkerInfoINTEL*() { return this; }
    inL operator S_PerformanceMarkerInfoINTEL const* () const { return const_cast<S_PerformanceMarkerInfoINTEL const*>(this); }
};
template<> struct detail::names_map<VkPerformanceMarkerInfoINTEL> { using T = S_PerformanceMarkerInfoINTEL; };
struct S_PipelineExecutablePropertiesKHR : public VkPipelineExecutablePropertiesKHR {
public:
    using Otype = VkPipelineExecutablePropertiesKHR;
public:
    S_PipelineExecutablePropertiesKHR(Otype& origin_obj_):Otype(origin_obj_){}
    S_PipelineExecutablePropertiesKHR(
        VkShaderStageFlags stages_= { },
        std::array<char,VK_MAX_DESCRIPTION_SIZE> name_= { },
        std::array<char,VK_MAX_DESCRIPTION_SIZE> description_= { },
        uint32_t subgroupSize_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR,
        nullptr,
        stages_,
        { },
        { },
        subgroupSize_
    } { 
        ::memcpy(&name[0], name_.data(), name_.size() );
        ::memcpy(&description[0], description_.data(), description_.size() );
    }
    inL S_PipelineExecutablePropertiesKHR& 
        set_name(std::array<char,VK_MAX_DESCRIPTION_SIZE> name_)
        {  return *this; }
    inL S_PipelineExecutablePropertiesKHR& 
        set_description(std::array<char,VK_MAX_DESCRIPTION_SIZE> description_)
        {  return *this; }
    inL S_PipelineExecutablePropertiesKHR& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_PipelineExecutablePropertiesKHR*() { return this; }
    inL operator S_PipelineExecutablePropertiesKHR const* () const { return const_cast<S_PipelineExecutablePropertiesKHR const*>(this); }
};
template<> struct detail::names_map<VkPipelineExecutablePropertiesKHR> { using T = S_PipelineExecutablePropertiesKHR; };
struct S_RefreshCycleDurationGOOGLE : public VkRefreshCycleDurationGOOGLE {
public:
    using Otype = VkRefreshCycleDurationGOOGLE;
public:
    S_RefreshCycleDurationGOOGLE(Otype& origin_obj_):Otype(origin_obj_){}
    S_RefreshCycleDurationGOOGLE(
        uint64_t refreshDuration_= { }
    ) : Otype{
        refreshDuration_
    } { }
    inL S_RefreshCycleDurationGOOGLE& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_RefreshCycleDurationGOOGLE*() { return this; }
    inL operator S_RefreshCycleDurationGOOGLE const* () const { return const_cast<S_RefreshCycleDurationGOOGLE const*>(this); }
};
template<> struct detail::names_map<VkRefreshCycleDurationGOOGLE> { using T = S_RefreshCycleDurationGOOGLE; };
struct N_WriteDescriptorSet{
public: 
    void* pNext = nullptr;
public:
    operator void*() {    return pNext;    }
    operator void*()const{   return const_cast<void*>(pNext);   }
    inL N_WriteDescriptorSet& n_VkWriteDescriptorSetInlineUniformBlockEXT(Aref<S_WriteDescriptorSetInlineUniformBlockEXT> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
    inL N_WriteDescriptorSet& n_VkWriteDescriptorSetAccelerationStructureNV(Aref<S_WriteDescriptorSetAccelerationStructureNV> next_)
        { detail::set_next(const_cast<void const**>(&pNext), (void*)&next_.ref); }
};
struct S_WriteDescriptorSet : public VkWriteDescriptorSet {
public:
    using Otype = VkWriteDescriptorSet;
public:
    S_WriteDescriptorSet(Otype& origin_obj_):Otype(origin_obj_){}
    S_WriteDescriptorSet(
        VkDescriptorSet dstSet_= { },
        uint32_t dstBinding_= { },
        uint32_t dstArrayElement_= { },
        E_DescriptorType descriptorType_= { },
        Array_general<S_DescriptorImageInfo> pImageInfo_= { },
        Array_general<S_DescriptorBufferInfo> pBufferInfo_= { },
        Array_general<VkBufferView> pTexelBufferView_= { }
    ) : Otype{
        VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
        nullptr,
        dstSet_,
        dstBinding_,
        dstArrayElement_,
        pImageInfo_.size(),
        descriptorType_,
        reinterpret_cast<VkDescriptorImageInfo*>(pImageInfo_.data()),
        reinterpret_cast<VkDescriptorBufferInfo*>(pBufferInfo_.data()),
        reinterpret_cast<VkBufferView*>(pTexelBufferView_.data())
    } { }
    S_WriteDescriptorSet& set_next(N_WriteDescriptorSet& next_)
        {    detail::set_next(const_cast<void const**>(&pNext), next_.pNext); return *this;    }
    inL S_WriteDescriptorSet& operator =(Otype const& o_){ ::memcpy(this,&o_,sizeof(o_)); return *this; }
    inL operator Otype*(){ return static_cast<Otype*>(this); }
    inL operator Otype const* () const { return static_cast<Otype const*>(this); }
    inL operator S_WriteDescriptorSet*() { return this; }
    inL operator S_WriteDescriptorSet const* () const { return const_cast<S_WriteDescriptorSet const*>(this); }
};
template<> struct detail::names_map<VkWriteDescriptorSet> { using T = S_WriteDescriptorSet; };


}/* namespace vk */ } /* namespace dawn */
# endif // __dawn_VK_TYPES_HPP__